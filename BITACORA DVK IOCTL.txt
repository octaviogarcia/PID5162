*********************************************************************
M3-IPC
Implementación de M3-IPC mediante IOCTL en KERNEL 4.9.88
DEBIAN 9.4 (called “stretch”)
*********************************************************************

Cuando falla ssh
================
	PermitRootLogin yes
	PasswordAuthentication yes
	ChallengeResponseAuthentication no
	KexAlgorithms +diffie-hellman-group1-sha1
	Ciphers +aes128-cbc
	

COMPILAR EL KERNEL LINUX
=======================

sudo apt-get update
sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc

cp /boot/config-$(uname -r) .config
make menuconfig
sudo make -j 4 && sudo make modules_install -j 4 && sudo make install -j 4
update-initramfs -c -k 4.9.88
update-grub  
update-grub2

BUSCAR ARCHIVOS MAS GRANDES
=========================== 
du -a /home | sort -n -r | head -n 5

----------------------------------------------------------------------------------
20180506:   	OBJETIVO 1: compilar el kernel : CUMPLIDO.
        Instalé DEBIAN 
			Linux uml 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1 (2018-04-29) x86_64 GNU/Linux
			root@uml:/etc# more debian_version 
				9.4
		Baje el kernel linux-source-4.9.tar.xz
			
----------------------------------------------------------------------------------		
20180518: OBJETIVO 2: compilar un modulo ejemplo: CUMPLIDO.
		https://blog.sourcerer.io/writing-a-simple-linux-kernel-module-d9dc3762c234
		OJO al hacer cut and paste en el codigo, las comillas estan mal.
		Cambie "Hello World" por "Hello DVS"
		root@uml:/home/dvs/lkm_example# make
		make -C /lib/modules/4.9.0-6-amd64/build M=/home/dvs/lkm_example modules
		make[1]: Entering directory '/usr/src/linux-headers-4.9.0-6-amd64'
		  CC [M]  /home/dvs/lkm_example/lkm_example.o
		  Building modules, stage 2.
		  MODPOST 1 modules
		  CC      /home/dvs/lkm_example/lkm_example.mod.o
		  LD [M]  /home/dvs/lkm_example/lkm_example.ko
		make[1]: Leaving directory '/usr/src/linux-headers-4.9.0-6-amd64'
		root@uml:/home/dvs/lkm_example# insmod lkm_example.ko
		root@uml:/home/dvs/lkm_example# dmesg | grep DVS
		[ 1380.183433] Hello, DVS!
		root@uml:/home/dvs/lkm_example# rmmod lkm_example.ko
		root@uml:/home/dvs/lkm_example# dmesg | grep DVS
		[ 1380.183433] Hello, DVS!
		[ 1461.511401] Goodbye, DVS!

		También se  puede hacer 
			root@uml:/home/dvs/lkm_example# make test
			dmesg -C
			insmod lkm_example.ko
			rmmod lkm_example.ko
			dmesg | grep DVS
			[ 1873.055605] Hello, DVS!
			[ 1873.068685] Goodbye, DVS!

		OBJETIVO 3: hacer una prueba de ioctl()
		https://github.com/skuhl/sys-prog-examples/tree/master/kernel-module/chardev-ioctl
		modifique el Makefile
		
			root@uml:/home/dvs/chardev-ioctl# make test
			dmesg -C
			insmod chardev.ko
			mknod /dev/char_dev c 100 0
			ls -l /dev/char_dev
			crw-r--r-- 1 root root 100, 0 May 19 09:32 /dev/char_dev
			echo "Hello DVS" > /dev/char_dev
			cat /dev/char_dev
			Hello DVS
			dmesg | grep char_dev
			[ 3467.002037] mknod char_dev c 100 0
			
		El dmesg completo presenta:
			[ 3467.001990] Registeration is a success The major device number is 100.
			[ 3467.002004] If you want to talk to the device driver,
			[ 3467.002016] you'll have to create a device file. 
			[ 3467.002026] We suggest you use:
			[ 3467.002037] mknod char_dev c 100 0
			[ 3467.002048] The device file name is important, because
			[ 3467.002057] the ioctl program assumes that's the
			[ 3467.002067] file you'll use.
			[ 3467.036783] device_open(ffff906a3aae3e00)
			[ 3467.036894] device_write(ffff906a3aae3e00,Hello DVS
						   ,10)
			[ 3467.036984] device_release(ffff906a38beb668,ffff906a3aae3e00)
			[ 3467.044526] device_open(ffff906a3aaba700)
			[ 3467.044603] device_read(ffff906a3aaba700,00007fd005c18000,131072)
			[ 3467.044695] Read 10 bytes, 131062 left
			[ 3467.045650] device_read(ffff906a3aaba700,00007fd005c18000,131072)
			[ 3467.045726] device_release(ffff906a38beb668,ffff906a3aaba700)
			
		Para probar IOCTL esta el programa ioctl que devuelve el mensaje almacenado en el kernel.
			root@uml:/home/dvs/chardev-ioctl# make test
			dmesg -C
			insmod chardev.ko
			ls -l /dev/char_dev
			crw-r--r-- 1 root root 100, 0 May 19 17:26 /dev/char_dev
			echo "Hello DVS. PAP" > /dev/char_dev
			cat /dev/char_dev
			Hello DVS. PAP
			./ioctl
			get_nth_byte message:Hello DVS. PAP

			get_msg message:Hello DVS. PAP

			dmesg | grep char_dev
			[ 1625.157546] mknod /dev/char_dev c 100 0
		
		El dmesg completo da
			root@uml:/home/dvs/chardev-ioctl# dmesg
			[ 1974.024014] Registeration is a success The major device number is 100.
			[ 1974.024030] If you want to talk to the device driver,
			[ 1974.024041] you'll have to create a device file. 
			[ 1974.024052] We suggest you use:
			[ 1974.024063] mknod /dev/char_dev c 100 0
			[ 1974.024074] The device file name is important, because
			[ 1974.024084] the ioctl program assumes that's the
			[ 1974.024188] file you'll use.
			[ 1974.051233] device_open(ffff8c0cb6abc600)
			[ 1974.051330] device_write(ffff8c0cb6abc600,Hello DVS. PAP
						   ,15)
			[ 1974.051414] device_release(ffff8c0cb4959628,ffff8c0cb6abc600)
			[ 1974.058967] device_open(ffff8c0cb6ab4500)
			[ 1974.059057] device_read(ffff8c0cb6ab4500,00007fa3a6692000,131072)
			[ 1974.059167] Read 15 bytes, 131057 left
			[ 1974.061978] device_read(ffff8c0cb6ab4500,00007fa3a6692000,131072)
			[ 1974.062084] device_release(ffff8c0cb4959628,ffff8c0cb6ab4500)
			[ 1974.068528] device_open(ffff8c0cb282a100)
			[ 1974.068963] device_ioctl(ffff8c0cb282a100,-1073454078,0)
			[ 1974.068994] device_ioctl(ffff8c0cb282a100,-1073454078,1)
			[ 1974.068997] device_ioctl(ffff8c0cb282a100,-1073454078,2)
			[ 1974.068999] device_ioctl(ffff8c0cb282a100,-1073454078,3)
			[ 1974.069001] device_ioctl(ffff8c0cb282a100,-1073454078,4)
			[ 1974.069003] device_ioctl(ffff8c0cb282a100,-1073454078,5)
			[ 1974.069005] device_ioctl(ffff8c0cb282a100,-1073454078,6)
			[ 1974.069007] device_ioctl(ffff8c0cb282a100,-1073454078,7)
			[ 1974.069009] device_ioctl(ffff8c0cb282a100,-1073454078,8)
			[ 1974.069011] device_ioctl(ffff8c0cb282a100,-1073454078,9)
			[ 1974.069013] device_ioctl(ffff8c0cb282a100,-1073454078,10)
			[ 1974.069015] device_ioctl(ffff8c0cb282a100,-1073454078,11)
			[ 1974.069017] device_ioctl(ffff8c0cb282a100,-1073454078,12)
			[ 1974.069019] device_ioctl(ffff8c0cb282a100,-1073454078,13)
			[ 1974.069021] device_ioctl(ffff8c0cb282a100,-1073454078,14)
			[ 1974.070412] device_ioctl(ffff8c0cb282a100,-1073454078,15)
			[ 1974.070809] device_ioctl(ffff8c0cb282a100,-2146933759,840104496)
			[ 1974.070864] device_read(ffff8c0cb282a100,00007ffe3212fa30,99)
			[ 1974.070866] Read 15 bytes, 84 left
			[ 1974.071463] device_ioctl(ffff8c0cb282a100,-2146933760,-1945232650)
			[ 1974.071547] device_write(ffff8c0cb282a100,Message passed by ioctl
						   ,25)
			[ 1974.071568] device_release(ffff8c0cb4959628,ffff8c0cb282a100)
			e900	


------------------------------------------------------------------------------------
20180710
	Se toma como base para el desarrollo el driver scull de Linux Device Driver Version3 (ldd3.pdf)
	tuve algun problema para compilar por la localizacion de signal.h que NO  ES linux/sched/signal.h sino linux/signal.h
	Luego de compilar, lo movi al directorio m3ipc-mod donde residira el modulo
	cambie todo los contenidos de los archivos donde decia "scull" por "m3ipc"
	compilo y cargo perfectamente

------------------------------------------------------------------------------------
20180712
	Se creo el nuevo directorio del proyecto principal que se llama (dvs)
	Se cambio la ubicacion de los archivos de header a dvs/include y con varios subdirectorios
	./com ./dvk ./dvs ./mol 
	
	Se creo el directorio dvk-mod para contener al modulo del DVK y se genero una primera 
	aproximacion pasandole como parametros el major, minor y cantidad de dispositivos (33,0,1)
	Se hizo el mknod /dev/dvk c 33 0 


------------------------------------------------------------------------------------
20180713	
	Se crearon todos los esqueletos de las funciones del DVK
	Para probar hacer
		mknod /dev/dvk c 33 0
		dmesg -c 
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1
		./test_dvkio 		
		
		test_dvkio realiza una solicitud DVK_IOCTDVSEND al drivers.
	
[  963.719798] dvk: loading out-of-tree module taints kernel.
[  963.737696] DEBUG 2727:dvk_init_module:210: usage: insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1 d
[  963.737734] DEBUG 2727:dvk_init_module:213: parms:  dvk_major=33 dvk_minor=0 dvk_nr_devs=1
[  963.739583] Registeration is a success The major device number is 33.
[  963.739611] If you want to talk to the device driver,
[  963.739627] you'll have to create a device file. 
[  963.739641] We suggest you use:
[  963.739659] mknod /dev/dvk c 33 0
[  963.739674] The device file name is important, because
[  963.739688] the ioctl program assumes that's the
[  963.739720] file you'll use.
[ 1039.250589] DEBUG 2731:dvk_open:119: 
[ 1039.250803] DEBUG 2731:test_dvkio:153: cmd=E31C arg=1
[ 1039.250862] DEBUG 2731:test_dvkio:173: DVK_CALL=28 (dvs_end) <<<<<<<<<<<

------------------------------------------------------------------------------------
20180714
		se modifico grub para que no tenga submenu y que tome el kernel 4.9.88 como default
			GRUB_DISABLE_SUBMENU=y
			#GRUB_DEFAULT=0
			GRUB_DEFAULT="gnulinux-4.9.88-advanced-903d63e4-e4db-43ec-acf6-9e6fed2a55d0"
			GRUB_TIMEOUT=5
		Luego update-grub2 
		
		Se modifico el kernel	
			include/linux/ 
				sched.h
				init_task.h
			kernel/
				exit.c
				fork.c
				
		Despues de compilar CORRECTAMENTE el kernel 
		Se verifica la exportacion de las 2 funciones.
root@debian9:~#  cat /proc/kallsyms | grep unbind
cd06a380 t exit_unbind
cd06a690 T old_exit_unbind
		
WARNING!!!
		NO APARECE como publico el local_nodeid
		root@debian9:~# dmesg | grep local				
			NO RETORNA NADA
		root@debian9:~#  cat /proc/kallsyms | grep nodeid
			NO RETORNA NADA
			
		Modifique la configuracion del Kernel 
		root@debian9:~# grep KALLSYMS /usr/src/linux/.config
			CONFIG_KALLSYMS=y
			CONFIG_KALLSYMS_ALL=y
			# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
			CONFIG_KALLSYMS_BASE_RELATIVE=y

		root@debian9:~#  cat /proc/kallsyms | grep nodeid
		cd7deb0c r __ksymtab_local_nodeid
		cd7eadb8 r __kcrctab_local_nodeid
		cd7f149a r __kstrtab_local_nodeid
		cd82cd4c D local_nodeid

------------------------------------------------------------------------------------
20180715
		Intente modificar el dvk-mod para modificar el exit_unbind pero falla
		por suerte encontre el modulo reljmp que justamente modifica una 
		version de kernel de printk por su propia version.
		De la version de reljmp tuve que cambiar para compilar 
					text_poke_smp => text_poke
				
		despues de hacer: insmod reljmp.ko 			
		dmesg arroja lo siguiente:
		[ 1501.522613] reljmp: initialize
		[ 1501.541518] reljmp: jump_label_mutex @ 0xd38446dc
		[ 1501.553836] reljmp: text_mutex @ 0xd3833550
		[ 1501.556069] reljmp: text_poke @ 0xd3029520
		[ 1501.558194] reljmp: initialize printk
		[ 1501.561612] reljmp: original printk @ 0xd3168d41: (55 89 e5 0f 1f)
		[ 1501.576825] reljmp: replacement reljmp_printk @ 0xf8653460: (55 89 e5 83 ec)
		[ 1501.579026] reljmp: jump code @ 0xf8655039: (e9 1a a7 4e 25)
		[ 1501.581007] reljmp: register printk
		[ 1501.607380] Redirected: 
		[ 1501.607857] reljmp: patched printk @ 0xd3168d41: (e9 1a a7 4e 25)
		[ 1501.610102] Redirected: 
		[ 1501.610139] reljmp: module loaded
					
		root@debian9:/usr/src/linux# grep text_poke /proc/kallsyms 
			d3028c60 T text_poke_early
			d3029520 T text_poke
			d3029a50 T text_poke_bp
			f8655280 b reljmp_text_poke     [reljmp] <<< esto lo agrega reljmp
			
		Se puede verificar las direcciones que informa reljmp 
			d3168d41 T printk
			f8653460 t reljmp_printk        [reljmp]

			
		SE incorporo el codigo de reljmp  https://github.com/juergh/reljmp
			
		root@debian9:/usr/src/dvs/dvk-mod# dmesg
			[  147.761088] dvk: loading out-of-tree module taints kernel.
			[  147.766130] DEBUG CHILD1:dvk_init_module:266: usage: insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1 
			[  147.766167] DEBUG CHILD1:dvk_init_module:268: parms:  dvk_major=33 dvk_minor=0 dvk_nr_devs=1
			[  147.766241] DEBUG CHILD1:dvk_init_module:285: Registeration is a success The major device number is 33.
			[  147.766266] DEBUG CHILD1:dvk_init_module:286: We suggest you use:
			[  147.766294] DEBUG CHILD1:dvk_init_module:287: mknod /dev/dvk c 33 0
			[  147.766319] DEBUG CHILD1:dvk_init_module:288: OLD local_nodeid=-1
			[  147.766346] DEBUG CHILD1:dvk_init_module:290: NEW local_nodeid=3 <<<<< AQUI SE CAMBIA EL local_nodeid para probar
			[  147.766370] DEBUG CHILD1:dvk_replace_init:140: 
			[  147.766460] DEBUG CHILD1:reljmp_init_once:99: reljmp: initialize
			[  147.772824] DVK: exit_unbind local_nodeid:3
			[  147.779167] reljmp: jump_label_mutex @ 0xdb8446dc
			[  147.790097] reljmp: text_mutex @ 0xdb833550
			[  147.790325] reljmp: text_poke @ 0xdb029520
			[  147.790392] DEBUG CHILD1:reljmp_init:111: reljmp: initialize exit_unbind
			[  147.791028] DEBUG CHILD1:reljmp_init:123: reljmp: original exit_unbind:db06a380
			[  147.805496] DEBUG CHILD1:reljmp_init:133: reljmp: replacement new_exit_unbind:f8726830
			[  147.805538] DEBUG CHILD1:reljmp_init:140: reljmp: jump code f87291d9
			[  147.805590] DEBUG CHILD1:exit_unbind_init_handler:31: 
			[  147.805664] DEBUG CHILD1:reljmp_register:84: register exit_unbind
			[  147.805718] DEBUG CHILD1:reljmp_lock:47: 
			[  147.824218] DEBUG CHILD1:reljmp_unlock:58: 
			[  147.824318] DEBUG CHILD1:reljmp_register:92: reljmp: patched exit_unbind:db06a380
			[  147.825139] DVK: exit_unbind local_nodeid:3
			[  153.686092] DVK: exit_unbind local_nodeid:3

		Prepare el dictorio dvk-test para realizar las pruebas .
		
PROBLEMA:
		Cuando se realiza la prueba en crudo se hace 
			fd = open(DVK_FILE_NAME, 0);
			rcode = ioctl(fd, DVK_IOCTDVSEND);
		Es decir, debe incluirse el FILE DESCRIPTOR
		En cambio en stub_dvkcall.c esta definido como:
			ret = ioctl(DVK_MAJOR,DVK_IOCSDVSINIT, (int) &parm);

Para lo cual habria que:

	todas las funciones de stub_dvkcall.c y stub_dvkcall.c deberian renombrarse: Ejemplo
		long dvk_dc_dump(int dcid)
		{
			long ret;
			ret = ioctl(DVK_MAJOR,DVK_IOCTDCDUMP, dcid);
			return ret;
		}
	Deberia cambiar a stub_dvkcall.c 
		long _dvk_dc_dump(int fd, int dcid)
		{
			long ret;
			ret = ioctl(fd, DVK_IOCTDCDUMP, dcid);
			return ret;
		}	
	Deberia cambiar a stub_dvkcall.h
		#define long dvk_dc_dump(dcid)  _dvk_dc_dump(dvk_fd, dcid)
		long dvk_dc_dump(void);
	cada programa deberia
		dvk_fd = open(DVK_FILE_NAME, 0);
		dvk_dc_dump(dcid);

------------------------------------------------------------------------------------
20180715
		Se incorporaron las funciones dvk_exit_unbind() y dvk_dvs_init verdaderas
		lo que llevo a utilizar funciones de otros archivos
		se opto por poner en la libreria la variable 
			extern int dvk_fd 
		para que el proceso haga el open() del dispositivo y la librearia vea
		esa variable 
		
		Se cambiaron 
			ret = ioctl(DVK_MAJOR,DVK_IOCTDCDUMP, dcid);
		por
			ret = ioctl(dvk_fd, DVK_IOCTDCDUMP, dcid);
			
		
------------------------------------------------------------------------------------
20180716-18
		Incorpore caso todas los codigos fuentes pero no estan todas las funciones habilitadas
	
		mknod /dev/dvk c 33 0
		dmesg -c 
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1
		
root@debian9:/usr/src/dvs/dvk-mod# cd ..
root@debian9:/usr/src/dvs# cd dvk-tests/
root@debian9:/usr/src/dvs/dvk-tests# ls
error.txt  Makefile  test_dvs_init  test_dvs_init.c  test_dvs_init.d
root@debian9:/usr/src/dvs/dvk-tests# ./test_dvs_init 
usage: ./test_dvs_init [-n nodeid] [-V nr_dcs] [-N nr_nodes] [-P nr_procs] [-T nr_tasks] [-B max_copybuf] [-L max_copylen] [-S nr_sysprocs] [-D dbglvl]

root@debian9:/usr/src/dvs/dvk-tests# ./test_dvs_init -n 3 
Open dvk device file /dev/dvk
Initializing DVS. Local node ID 3... 
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
d_max_copybuf=65536 d_max_copylen=1048576
d_dbglvl=0 version=2.1 sizeof(proc)=0
     
root@debian9:/usr/src/dvs/dvk-tests# ls /proc/dvs/
info  nodes  proxies

root@debian9:/usr/src/dvs/dvk-tests# ls -l /proc/dvs/
total 0
-r--r--r-- 1 root root 0 jul 18 18:05 info
-r--r--r-- 1 root root 0 jul 18 18:05 nodes
dr-xr-xr-x 2 root root 0 jul 18 18:05 proxies

root@debian9:/usr/src/dvs/dvk-tests# dmesg
[  119.277845] dvk: loading out-of-tree module taints kernel.
[  119.285227] DEBUG 550:dvk_init_module:254: usage: insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1 
[  119.285277] DEBUG 550:dvk_init_module:256: parms:  dvk_major=33 dvk_minor=0 dvk_nr_devs=1
[  119.285353] DEBUG 550:dvk_init_module:273: Registeration is a success The major device number is 33.
[  119.285382] DEBUG 550:dvk_init_module:274: We suggest you use:
[  119.285456] DEBUG 550:dvk_init_module:275: mknod /dev/dvk c 33 0
[  119.285516] DEBUG 550:dvk_init_module:276: OLD local_nodeid=-1
[  119.285546] DEBUG 550:dvk_replace_init:139: 
[  119.285635] DEBUG 550:reljmp_init_once:99: reljmp: initialize
[  119.296483] reljmp: jump_label_mutex @ 0xcf8446dc
[  119.306838] reljmp: text_mutex @ 0xcf833550
[  119.307058] reljmp: text_poke @ 0xcf029520
[  119.307136] DEBUG 550:reljmp_init:111: reljmp: initialize exit_unbind
[  119.307670] DEBUG 550:reljmp_init:123: reljmp: original exit_unbind:cf06a380
[  119.321501] DEBUG 550:reljmp_init:133: reljmp: replacement new_exit_unbind:f861b971
[  119.321544] DEBUG 550:reljmp_init:140: reljmp: jump code f8624159
[  119.321598] DEBUG 550:exit_unbind_init_handler:30: 
[  119.321673] DEBUG 550:reljmp_register:84: register exit_unbind
[  119.321711] DEBUG 550:reljmp_lock:47: 
[  119.335541] DEBUG 550:reljmp_unlock:58: 
[  119.335639] DEBUG 550:reljmp_register:92: reljmp: patched exit_unbind:cf06a380
[  163.145986] DEBUG 559:dvk_open:174: 
[  163.146089] DEBUG 559:dvk_ioctl:208: cmd=4004E31B arg=BF974464
[  163.146167] DEBUG 559:dvk_ioctl:228: DVK_CALL=27 (dvs_init) 
[  163.146866] DEBUG 559:new_dvs_init:37: d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
[  163.146987] DEBUG 559:new_dvs_init:38: d_max_copybuf=65536 d_max_copylen=1048576
[  163.147028] DEBUG 559:new_dvs_init:39: d_dbglvl=0 version=2.1 sizeof(proc)=0
[  163.149205] DVK: exit_unbind local_nodeid:3
[  176.704421] DVK: exit_unbind local_nodeid:3
[  176.717238] DVK: exit_unbind local_nodeid:3
[  177.034427] DVK: exit_unbind local_nodeid:3
[  177.047923] DVK: exit_unbind local_nodeid:3
[  177.210529] DVK: exit_unbind local_nodeid:3
[  177.224042] DVK: exit_unbind local_nodeid:3
[  178.528433] DVK: exit_unbind local_nodeid:3
[  178.537351] DVK: exit_unbind local_nodeid:3
[  181.510846] DVK: exit_unbind local_nodeid:3
[  186.048803] DVK: exit_unbind local_nodeid:3
		
Como usuario "pap" intente ejecutar la misma prueba
pap@debian9:/usr/src/dvs/dvk-tests$ ./test_dvs_init  -n 5
Open dvk device file /dev/dvk
Initializing DVS. Local node ID 5... 
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
d_max_copybuf=65536 d_max_copylen=1048576
d_dbglvl=0 version=2.1 sizeof(proc)=0
ERROR -1: Initializing DVS. Local node ID 5... 

haciendo luego dmesg 
[  593.066540] ERROR: 581:new_dvs_init:19: rcode=-335
siendo:
#define EDVSPRIVILEGES 	 (_SIGN 335)  	/* The process has no privileges for the call */

------------------------------------------------------------------------------------
20180719

./test_dvs_init -n 3 -D 16777215

root@debian9:/usr/src/dvs/dvk-tests# ./test_dc_init 
dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32 flags=0 dc_nodes=0 dc_name=DC0
dc_dcid=0 dc_warn2proc=27342 dc_warnmsg=0
Open dvk device file /dev/dvk
DC0 has been initialized on node 3
root@debian9:/usr/src/dvs/dvk-tests# cd /proc
root@debian9:/proc# cd dvs
root@debian9:/proc/dvs# ls -l
total 0
dr-xr-xr-x 2 root root 0 jul 19 08:15 DC0
-r--r--r-- 1 root root 0 jul 19 08:15 info
-r--r--r-- 1 root root 0 jul 19 08:15 nodes
dr-xr-xr-x 2 root root 0 jul 19 08:15 proxies
root@debian9:/proc/dvs# cd DC0/
root@debian9:/proc/dvs/DC0# ls -l
total 0
-r--r--r-- 1 root root 0 jul 19 08:15 info
-r--r--r-- 1 root root 0 jul 19 08:15 procs
-r--r--r-- 1 root root 0 jul 19 08:15 stats

[  196.454525] DEBUG 560:dvk_ioctl:228: DVK_CALL=0 (dc_init) 
[  196.454608] DEBUG 560:new_dc_init:358: Current user=0 
[  196.454663] DEBUG 560:new_dc_init:370: This process is running on cpu_id=3 
[  196.4CHILD1:74] DEBUG 560:new_dc_init:392: RLOCK_DC dc=0 count=0
[  196.457140] DEBUG 560:new_dc_init:399: RUNLOCK_DC dc=0 count=0
....
[  196.457284] DEBUG 560:new_dc_init:392: RLOCK_DC dc=0 count=0
[  196.457285] DEBUG 560:new_dc_init:399: RUNLOCK_DC dc=0 count=0
[  196.457578] DEBUG 560:new_dc_init:403: Initializing DC=0 DCname=DC0 on node=3
[  196.457640] DEBUG 560:new_dc_init:406: WLOCK_DC dc=0 count=0
[  196.457769] DEBUG 560:new_dc_init:441: WLOCK_NODE node=3 count=0
[  196.457811] DEBUG 560:new_dc_init:444: WUNLOCK_NODE node=3 count=0
[  196.457880] DEBUG 560:new_dc_init:452: proctab_size=131072 order=5 MAX_ORDER=11
[  196.458014] DEBUG 560:new_dc_init:472: Initializing DC=0 proc[] table on dc_proc=e8980000
[  196.458124] DEBUG 560:init_proc_desc:16: p_name=$noname dcid=0
......
[  196.459821] DEBUG 560:init_proc_desc:16: p_name=$noname dcid=0

[  196.459891] DEBUG 560:new_dc_init:484: Initializing 64 element of system process vector at dc_sid2proc=e9d22700 
[  196.461868] DEBUG 560:new_dc_init:492: Creating DC0 directory on debugfs
[  196.462145] DEBUG 560:new_dc_init:520: /proc/dvs/DC0/info installed
[  196.462217] DEBUG 560:new_dc_init:533: /proc/dvs/DC0/procs installed
[  196.462276] DEBUG 560:new_dc_init:546: /proc/dvs/DC0/stats installed
[  196.462315] DEBUG 560:new_dc_init:551: KREF_GET counter=1
[  196.462417] DEBUG 560:new_dc_init:563: dc_dcid=0 dc_cpumask=FFFFFFFF dc_name=DC0 
[  196.462457] DEBUG 560:new_dc_init:564: dc_dcid=0 dc_warn2proc=27342 dc_warnmsg=0
[  196.462494] DEBUG 560:new_dc_init:566: WUNLOCK_DC dc=0 count=0
		
	
PROBLEMA:	
	Cuando incorpore dvk_bind()  empece a tener problemas con los simbolos

root@debian9:/usr/src/dvs/dvk-mod# insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1
insmod: ERROR: could not insert module dvk.ko: Unknown symbol in module

root@debian9:/usr/src/dvs/dvk-mod# dmesg 
[11158.701446] dvk: Unknown symbol tasklist_lock (err 0)

root@debian9:/usr/src/dvs/dvk-mod# cat /proc/kallsyms | grep  tasklist
da81a1c0 D tasklist_lock

SOLUCION:
		De https://onebitbug.me/2011/03/04/introducing-linux-kernel-symbols/
		Modifique lkm_example.c  para que busque e imprima el simbolo de tasklist_lock
			root@debian9:/usr/src/dvs/lkm_example# insmod lkm_example.ko 
			root@debian9:/usr/src/dvs/lkm_example# dmesg
			[12500.309607] Hello, DVS! tasklist_ptr=DA81A1C0 <<<<<<<<<<<<<<<<<<<<<<<<<<<
			root@debian9:/usr/src/dvs/lkm_example# grep tasklist /proc/kallsyms 
			da81a1c0 D tasklist_lock <<<<<<<<<<<<<<<<<<<<<<<<<<<
			f873c200 b tasklist_ptr [lkm_example]
			root@debian9:/usr/src/dvs/lkm_example# 

		Lleve esto a main.c
		
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c 
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1		
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init 
		./test_bind 0 33
		
[   72.337869] DEBUG 577:dvk_open:174: 
[   72.337900] DEBUG 577:dvk_ioctl:211: cmd=4004E309 arg=BFA5A028
[   72.337903] DEBUG 577:dvk_ioctl:231: DVK_CALL=9 (bind) 
[   72.338153] DEBUG 577:new_bind:1323: oper=0 dcid=0 pid=577 endpoint=33 nodeid=-1
[   72.338404] DEBUG 577:new_bind:1345: RLOCK_DC dc=0 count=0
[   72.338491] DEBUG 577:new_bind:1358: WLOCK_PROC ep=33 count=0
[   72.338544] DEBUG 577:init_proc_desc:16: p_name=$noname dcid=0
[   72.338632] DEBUG 577:new_bind:1396: SELF_BIND PID=577
[   72.338669] DEBUG 577:new_bind:1429: WUNLOCK_PROC ep=33 count=0
[   72.338745] DEBUG 577:new_bind:1431: TASK_LOCK_INIT pid=577
[   72.339068] DEBUG 577:new_bind:1432: WLOCK_TASK pid=577 count=0
[   72.339116] DEBUG 577:new_bind:1433: WLOCK_PROC ep=33 count=0
[   72.339156] DEBUG 577:new_bind:1464: increment the reference count of the task struct=577 count=2
[   72.339222] DEBUG 577:new_bind:1474: process p_name=test_bind *p_name_ptr=test_bind
[   72.339349] DEBUG 577:new_bind:1526: nr=33 endp=33 dcid=0 flags=0 misc=20 lpid=577 nodeid=3 nodemap=8 name=test_bind 
[   72.339393] DEBUG 577:new_bind:1527: nr=33 endp=33 dcid=0 lpid=577 p_cpumask=FFFFFFFF name=test_bind 
[   72.339440] DEBUG 577:new_bind:1540: WUNLOCK_PROC ep=33 count=0
[   72.339491] DEBUG 577:new_bind:1542: WUNLOCK_TASK pid=577 count=0
[   72.339537] DEBUG 577:new_bind:1543: DC_INCREF counter=1
[   72.339582] DEBUG 577:new_bind:1544: RUNLOCK_DC dc=0 count=0
[   82.340185] DVK: exit_unbind local_nodeid:3

		

SE HIZO O MISMO PARA LA FUNCION sched_setaffinity

[   85.572482] DEBUG 567:dvk_init_module:265: Hello, DVS! setaffinity_ptr=D009254

root@debian9:/usr/src/dvs/dvk-tests# grep setaffinity /proc/kallsyms 
d0092540 T sched_setaffinity

[   65.119988] DEBUG 576:dvk_open:174: 
[   65.120034] DEBUG 576:dvk_ioctl:211: cmd=4004E309 arg=BFEFCA68
[   65.120037] DEBUG 576:dvk_ioctl:231: DVK_CALL=9 (bind) 
[   65.120331] DEBUG 576:new_bind:1323: oper=0 dcid=0 pid=576 endpoint=33 nodeid=-1
[   65.120438] DEBUG 576:new_bind:1345: RLOCK_DC dc=0 count=0
[   65.120527] DEBUG 576:new_bind:1358: WLOCK_PROC ep=33 count=0
[   65.120556] DEBUG 576:init_proc_desc:16: p_name=$noname dcid=0
[   65.120800] DEBUG 576:new_bind:1396: SELF_BIND PID=576
[   65.120838] DEBUG 576:new_bind:1429: WUNLOCK_PROC ep=33 count=0
[   65.120910] DEBUG 576:new_bind:1431: TASK_LOCK_INIT pid=576
[   65.120961] DEBUG 576:new_bind:1432: WLOCK_TASK pid=576 count=0
[   65.121009] DEBUG 576:new_bind:1433: WLOCK_PROC ep=33 count=0
[   65.121044] DEBUG 576:new_bind:1438: setaffinity_ptr pid=576 <<<<<<<<<<<< ESTO ES CODIGO DE PRUEBBA 
[   65.121623] DEBUG 576:new_bind:1470: increment the reference count of the task struct=576 count=2
[   65.121690] DEBUG 576:new_bind:1480: process p_name=test_bind *p_name_ptr=test_bind
[   65.121775] DEBUG 576:new_bind:1532: nr=33 endp=33 dcid=0 flags=0 misc=20 lpid=576 nodeid=3 nodemap=8 name=test_bind 
[   65.121819] DEBUG 576:new_bind:1533: nr=33 endp=33 dcid=0 lpid=576 p_cpumask=FFFFFFFF name=test_bind 
[   65.121910] DEBUG 576:new_bind:1546: WUNLOCK_PROC ep=33 count=0
[   65.121963] DEBUG 576:new_bind:1548: WUNLOCK_TASK pid=576 count=0
[   65.122008] DEBUG 576:new_bind:1549: DC_INCREF counter=1
[   65.122185] DEBUG 576:new_bind:1550: RUNLOCK_DC dc=0 count=0
[   75.123912] DVK: exit_unbind local_nodeid:3

ATENCION!!!!!!!!!!!!!!!!!!!11111
root@debian9:/# df
S.ficheros     bloques de 1K   Usados Disponibles Uso% Montado en
udev                  399428        0      399428   0% /dev
tmpfs                 102748     4508       98240   5% /run
/dev/sda1           19994224 18021280      934252  96% /
tmpfs                 513728        0      513728   0% /dev/shm
tmpfs                   5120        0        5120   0% /run/lock
tmpfs                 513728        0      513728   0% /sys/fs/cgroup
tmpfs                 102744        0      102744   0% /run/user/0

REDUCIDO DESPUES DE BORRAR VARIOS KERNELS
Last login: Thu Jul 19 20:52:31 2018 from 192.168.1.5
dfroot@debian9:~# df
S.ficheros     bloques de 1K   Usados Disponibles Uso% Montado en
udev                  399636        0      399636   0% /dev
tmpfs                 102788     3220       99568   4% /run
/dev/sda1           19994224 15263576     3691956  81% /
tmpfs                 513936        0      513936   0% /dev/shm
tmpfs                   5120        0        5120   0% /run/lock
tmpfs                 513936        0      513936   0% /sys/fs/cgroup
tmpfs                 102784        0      102784   0% /run/user/0


------------------------------------------------------------------------------------
20180719
		Se implemento UNBIND . Se probo new_unbind() solo para el proceso que lo invoca
		
[ 1953.755492] DEBUG 1293:dvk_ioctl:211: cmd=4004E30A arg=BFE39B00
[ 1953.755498] DEBUG 1293:dvk_ioctl:231: DVK_CALL=10 (unbind) 
[ 1953.755658] DEBUG 1293:new_unbind:1574: dcid=0 proc_ep=44
[ 1953.755744] DEBUG 1293:new_unbind:1583: RLOCK_DC dc=0 count=0
[ 1953.755828] DEBUG 1293:new_unbind:1595: WLOCK_TASK pid=1293 count=0
[ 1953.755874] DEBUG 1293:new_unbind:1596: RLOCK_PROC ep=44 count=0
[ 1953.755910] DEBUG 1293:new_unbind:1597: RUNLOCK_DC dc=0 count=0
[ 1953.756032] DEBUG 1293:new_unbind:1628: RUNLOCK_PROC ep=44 count=0
[ 1953.756101] DEBUG 1293:new_unbind:1650: WLOCK_DC dc=0 count=0
[ 1953.756168] DEBUG 1293:new_unbind:1651: WLOCK_PROC ep=44 count=0
[ 1953.756314] DEBUG 1293:do_unbind:618: nr=44 endp=44 dcid=0 flags=0 misc=20 lpid=1293 nodeid=3 nodemap=8 name=test_unbind 
[ 1953.756418] DEBUG 1293:do_unbind:647: Caller nr=44 endp=44 dcid=0 flags=0 misc=20 lpid=1293 nodeid=3 nodemap=8 name=test_unbind 
[ 1953.756545] DEBUG 1293:do_unbind:678: wakeup with error those processes trying to send a message to the proc
[ 1953.756588] DEBUG 1293:do_unbind:705: delete notify messages bits sent by the proc
[ 1953.756662] DEBUG 1293:do_unbind:715: WUNLOCK_PROC ep=44 count=0
[ 1953.756728] DEBUG 1293:do_unbind:716: WLOCK_PROC ep=-35 count=0
.....
[ 1953.758346] DEBUG 1293:do_unbind:720: WUNLOCK_PROC ep=219 count=0
[ 1953.758348] DEBUG 1293:do_unbind:712: WLOCK_PROC ep=220 count=0
[ 1953.758350] DEBUG 1293:do_unbind:720: WUNLOCK_PROC ep=220 count=0
[ 1953.758404] DEBUG 1293:do_unbind:753: nr=44 endp=44 dcid=0 flags=0 misc=20 lpid=1293 nodeid=3 nodemap=8 name=test_unbind 
[ 1953.758532] DEBUG 1293:do_unbind:809: wakeup with error those processes waiting this process MIGRATION
[ 1953.758578] DEBUG 1293:do_unbind:858: wakeup those processes waiting this process UNBINDING
[ 1953.758643] DEBUG 1293:do_unbind:891: nr=44 endp=44 dcid=0 flags=0 misc=20 lpid=1293 nodeid=3 nodemap=8 name=test_unbind 
[ 1953.758667] DEBUG 1293:init_proc_desc:16: p_name=test_unbind dcid=0
[ 1953.758695] DEBUG 1293:do_unbind:893: initialized 
[ 1953.758735] DEBUG 1293:do_unbind:894: DC_DECREF counter=1
[ 1953.758797] DEBUG 1293:new_unbind:1696: WUNLOCK_TASK pid=1293 count=0
[ 1953.758847] DEBUG 1293:new_unbind:1700: WUNLOCK_PROC ep=44 count=0
[ 1953.758893] DEBUG 1293:new_unbind:1701: WUNLOCK_DC dc=0 count=0

TODO:	  Todas las funciones de dvk_procs.c SON TRUCHAS !!

	Habilite la funcion nodes_read de dvk_procfs.c
		root@debian9:/proc/dvs# more nodes
		ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
		 3     6      -1        0        0 -------------------------------X node3
		
		El dmesg arroja 
		[   49.000443] DEBUG 551:nodes_read:22: last_node=0 count=1024 ppos=0
		[   49.000569] DEBUG 551:nodes_read:38: RLOCK_NODE node=0 count=0
		[   49.000621] DEBUG 551:nodes_read:50: RUNLOCK_NODE node=0 count=0
		....
		[   49.001008] DEBUG 551:nodes_read:38: RLOCK_NODE node=31 count=0
		[   49.001010] DEBUG 551:nodes_read:50: RUNLOCK_NODE node=31 count=0
		[   49.001267] DEBUG 551:nodes_read:22: last_node=-1 count=1024 ppos=158

	Habilite la funcion info_read de dvk_procfs.c
		root@debian9:/usr/src/dvs/dvk-tests# cat /proc/dvs/info 
		nodeid=3
		nr_dcs=32
		nr_nodes=32
		max_nr_procs=221
		max_nr_tasks=35
		max_sys_procs=64
		max_copy_buf=65536
		max_copy_len=1048576
		dbglvl=FFFFFF
		version=2.1
		sizeof(proc)=376
		sizeof(proc) aligned=512
		sizeof(dc)=120
		sizeof(node)=92
		
		root@debian9:/usr/src/dvs/dvk-tests# dmesg
		[   69.529704] DVK: exit_unbind local_nodeid:3
		[   71.722755] DVK: exit_unbind local_nodeid:3
		[   71.737815] DVK: exit_unbind local_nodeid:3
		[   72.791056] DVK: exit_unbind local_nodeid:3
		[   72.799206] DVK: exit_unbind local_nodeid:3
		[   74.394021] DVK: exit_unbind local_nodeid:3
		[   74.401916] DVK: exit_unbind local_nodeid:3
		[   75.236212] DEBUG 565:info_read:81: last_line=0 count=131072 ppos=0
		[   75.237802] DEBUG 565:info_read:81: last_line=-1 count=131072 ppos=0
		[   75.238327] DVK: exit_unbind local_nodeid:3
	
		
	Habilite la funcion dc_info_read de dvk_procfs.c
	
		root@debian9:/proc/dvs/DC6# more info 
		dcid=6
		flags=0
		nr_procs=221
		nr_tasks=35
		nr_sysprocs=64
		nr_nodes=32
		dc_nodes=8
		warn2proc=27342
		warnmsg=0
		dc_name=DC6
		nodes 33222222222211111111110000000000
			  10987654321098765432109876543210
			  ----------------------------X---
		cpumask=

		[  133.819597] DEBUG 563:dc_info_read:228: last_line=0 count=1024 ppos=0
		[  133.819668] DEBUG 563:dc_info_read:246: dcid=6
		[  133.819801] DEBUG 563:dc_info_read:251: RLOCK_DC dc=0 count=0
		[  133.820062] DEBUG 563:dc_info_read:274: RUNLOCK_DC dc=0 count=0
		[  133.820453] DEBUG 563:dc_info_read:228: last_line=-1 count=1024 ppos=242

------------------------------------------------------------------------------------
20180721
TODO:  Hay q resolver  cpumask_scnprintf o  bitmap_scnprintf
RESUELTO: 
		len += sprintf(page+len,"cpumask=%*pb \n",&dc_ptr->dc_usr.dc_cpumask);
	Interesante los distintos formatos
		https://www.kernel.org/doc/Documentation/printk-formats.txt
	
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c 
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		
		./test_bind 6 33 &
		dmesg -c >> dmesg.txt
		cat /proc/dvs/DC6/procs
		dmesg -c >> dmesg.txt
		
		ls -l /proc/dvs/DC6
		cat /proc/dvs/DC6/info 
		dmesg -c >> dmesg.txt

		ls -l /proc/dvs/
		cat /proc/dvs/info 
		cat /proc/dvs/nodes

		
		
ERROR!!!:
	Despues de haber probado con un test_bind 6 33, al finalizar se intenta OTRO 
	test_bind 6 33 dando error:
		root@debian9:/usr/src/dvs/dvk-tests# ./test_bind 6 33 &
		[1] 553
		root@debian9:/usr/src/dvs/dvk-tests# Open dvk device file /dev/dvk
		Binding process 553 to DC6 with p_nr=33
		DEBUG 553:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=553 endpoint=33 nodeid=-1
		DEBUG 553:dvk_bind_X:378: ioctl ret=-1
		waiting to end ep=-1 errno=337
	El dmesg dice:
		[  140.574778] DEBUG 553:dvk_open:174: 
		[  140.574989] DEBUG 553:dvk_ioctl:211: cmd=4004E309 arg=BFABA3A8
		[  140.574993] DEBUG 553:dvk_ioctl:231: DVK_CALL=9 (bind) 
		[  140.575214] DEBUG 553:new_bind:1323: oper=0 dcid=6 pid=553 endpoint=33 nodeid=-1
		[  140.575326] DEBUG 553:new_bind:1345: RLOCK_DC dc=0 count=0
		[  140.575413] DEBUG 553:new_bind:1358: WLOCK_PROC ep=33 count=0
		[  140.575477] DEBUG 553:new_bind:1362: nr=33 endp=33 dcid=6 flags=0 misc=20 lpid=535 nodeid=3 nodemap=8 name=test_bind 
		[  140.575513] DEBUG 553:new_bind:1363: WUNLOCK_PROC ep=33 count=0
		[  140.575564] DEBUG 553:new_bind:1364: RUNLOCK_DC dc=0 count=0
		[  140.575603] ERROR: 553:new_bind:1364: rcode=-337
		#define EDVSSLOTUSED 	 (_SIGN 337)  	/* BIND the slot is already used */

FALTA EL ENCABEZADO
		root@debian9:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC6/procs 
		6   33     33    565    3    0   20  27342  27342  27342  27342 test_bind  
	RESUELTO
		root@debian9:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC6/procs
		DC p_nr -endp- -lpid- node flag misc -getf- -sndt- -wmig- -prxy- name
		 6   33     33    568    3    0   20  27342  27342  27342  27342 test_bind 
 
ADEMAS, DESPUES DE HABER FINALIZADO SIGUE EN EL LISTADO
		root@debian9:/usr/src/dvs/dvk-tests# 
		[1]+  Hecho                   ./test_bind 6 33
		root@debian9:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC6/procs 
		 6   33     33    565    3    0   20  27342  27342  27342  27342 test_bind  
 
 ALGO BUENO- cuando se prueba test_unbind 
		root@debian9:/usr/src/dvs/dvk-tests# ./test_unbind 6 35 
		Open dvk device file /dev/dvk
		Binding process 591 to DC6 with p_nr=35
		DEBUG 591:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=591 endpoint=35 nodeid=-1
		DEBUG 591:dvk_bind_X:378: ioctl ret=35
		waiting to end ep=35 errno=0
		dvk_unbind ret=0
		root@debian9:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC6/procs 
		 6   33     33    565    3    0   20  27342  27342  27342  27342 test_bind      
		 6   34     34    588    3    0   20  27342  27342  27342  27342 test_bind
 
 TODO:  Resolver el problema del exit_unbind
		habria que hacer lo siguiente
		En el KERNEL
			definir una variable puntero a funcion
				asmlinkage long old_exit_unbind(long code);
				long (*exit_unbind_ptr)() = old_exit_unbind;
				EXPORT_SYMBOL(exit_unbind_ptr);

			iniciarla 
				exit_unbind_ptr = old_exit_unbind;
			y modificar 
				static void exit_unbind(long code)
				{
					printk(KERN_ALERT "DVK: exit_unbind local_nodeid:%d\n",atomic_read(&local_nodeid));
					exit_unbind_ptr(code);
				}
			EXPORT_SYMBOL(exit_unbind);

IMPORTANTE: Se hizo dvk-test/vm_read.c para probar la copia de datos entre espacios de direcciones process_vm_readv.
		FUNCIONA CON MALLOC
		root@debian9:/usr/src/dvs/dvk-tests# ./vm_read 
		BEFORE parent_buf=PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP 
		BEFORE child_buf=CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 
		CHILD AFTER child_buf=PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP nread=100 errno=0
		AFTER parent_buf=PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP
		
TODO:
		Modifique dvk-ipc.c . TODO COMPILA
		Hay que probar
	
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		./test_sendrcv 6 13 14
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		
		root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrcv 6 13 14
		Open dvk device file /dev/dvk
		DEBUG 568:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=568 endpoint=13 nodeid=-1
		DEBUG 568:dvk_bind_X:378: ioctl ret=13
		PARENT BIND dcid=6 parent_pid=568 parent_nr=13 parent_ep=13 m_ptr=0x1688008
		PARENT pause before SEND
		DEBUG PARENT:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=569 endpoint=14 nodeid=-1
		DEBUG PARENT:dvk_bind_X:378: ioctl ret=14
		CHILD BIND dcid=6 child_pid=569 child_nr=14 child_ep=14 m_ptr=0x1688008
		PARENT SEND msg: m_type=15, m1_i1=1, m1_i2=2, m1_i3=3
		PARENT SEND ret=-1

[   94.993177] DEBUG 568:dvk_ioctl:210: cmd=4004E301 arg=BFA60F20
[   94.993183] DEBUG 568:dvk_ioctl:230: DVK_CALL=1 (mini_send) 
[   94.993373] DEBUG 568:new_mini_send:39: dst_ep=14
[   94.993454] DEBUG 568:check_caller:495: caller_pid=568 caller_tgid=568
[   94.993522] DEBUG 568:check_caller:531: WLOCK_PROC ep=13 count=0
[   94.993581] DEBUG 568:check_caller:560: WUNLOCK_PROC ep=13 count=0
[   94.993630] DEBUG 568:check_caller:563: dcid=6
[   94.993688] DEBUG 568:check_caller:567: RLOCK_DC dc=0 count=0
[   94.993726] DEBUG 568:check_caller:CHILD2: RUNLOCK_DC dc=0 count=0
[   94.993772] DEBUG 568:check_caller:577: caller_pid=568 
[   94.993961] DEBUG 568:new_mini_send:51: RLOCK_PROC ep=13 count=0
[   94.994097] DEBUG 568:new_mini_send:55: caller_nr=13 caller_ep=13 dst_ep=14 
[   94.994144] DEBUG 568:new_mini_send:58: RUNLOCK_PROC ep=13 count=0
[   94.994195] DEBUG 568:new_mini_send:60: dcid=6
[   94.994262] DEBUG 568:new_mini_send:64: RLOCK_DC dc=0 count=0
[   94.994303] DEBUG 568:new_mini_send:67: RUNLOCK_DC dc=0 count=0
[   94.994437] DEBUG 568:new_mini_send:82: WLOCK_PROC ep=13 count=0
[   94.994518] DEBUG 568:new_mini_send:86: WLOCK_PROC ep=14 count=0
[   94.994555] DEBUG 568:new_mini_send:90: dst_nr=14 dst_ep=14
[   94.994626] DEBUG 568:new_mini_send:109: dst_ptr->p_usr.p_nodeid=3
[   94.994682] DEBUG 568:new_mini_send:113: RLOCK_DC dc=0 count=0
[   94.994729] DEBUG 568:new_mini_send:117: RUNLOCK_DC dc=0 count=0
[   94.994785] DEBUG 568:new_mini_send:125: dcid=6 caller_pid=568 caller_nr=13 dst_ep=14 
[   94.994937] DEBUG 568:new_mini_send:203: destination is waiting. Copy the message and wakeup destination
[   94.995201] DEBUG 568:copy_usr2usr:829: source=13 src_pid=568 src_addr=01688008 dst_pid=569 dst_addr=01688008 bytes=36
[   94.995248] DEBUG 568:copy_usr2usr:834: WRITE
[   94.995386] DEBUG 568:copy_usr2usr:853: len=-22 !!!!!!!!!!!!!!!!!!! #define EDVSINVAL (_SIGN 22)  /* invalid argument */
[   94.995416] ERROR: 568:copy_usr2usr:854: rcode=-22
[   94.995488] DEBUG 568:new_mini_send:208: WUNLOCK_PROC ep=13 count=0
[   94.995550] DEBUG 568:new_mini_send:208: WUNLOCK_PROC ep=14 count=0
[   94.995587] ERROR: 568:new_mini_send:209: rcode=-22

SEGUN EL MANUAL
Errors
EINVAL
The sum of the iov_len values of either local_iov or remote_iov overflows a ssize_t value.
EINVAL
flags is not 0.
EINVAL
liovcnt or riovcnt is too large.			 

YA ESTA LA RAZON DEL PROBLEMA!!!!!!!!!!!!!!!!!!!
	El vector de copia DEBE estar en MODO USUARIO no formar parte del kernel !!!!
			
SOLUCION 1:
		En la libraria dvk-lib en SEND, RECEIVE, etc. crear los vectores en modo usuario y pasarlos
		como parametros al kernel.
		El uno de los parametros debera ser completado por el kernel (el que corresponde a la direccion del OTRO proceso)
		de esa forma los vectores estan en modo usuario.

SOLUCION 2: MODIFICAR EL CODIGO DEL KERNEL 
			USR2USR_COPY DADO QUE SE PIERDE TIEMPO EN LA COPIA A MODO USUARIO
			VER https://elixir.bootlin.com/linux/v4.9.88/source/lib/iov_iter.c#L1237
			
------------------------------------------------------------------------------------
20180721: Se opto por la solucion 2.

		Se modificaron 
			process_vm_access.c
			iov_iter.c
			read_write.c 
			y varios .h en include/linux/
		creando nuevas funciones que empiezan por dvk_XXXX()
		Todo el codigo se puso como comentario el //#ifdef CONFIG_DVK previendo
		la inclusion en el KCONFIG de LINUX
		Y para facilitar la localizacion del codigo modificado.
	
			
------------------------------------------------------------------------------------
20180724:	
		Se modifico el copy_usr2usr() y el dvk_send() FUNCIONA!!  (receiver esperando).
		
			root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrcv 6 13 14
			Open dvk device file /dev/dvk
			DEBUG 552:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=552 endpoint=13 nodeid=-1
			DEBUG 553:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=553 endpoint=14 nodeid=-1
			DEBUG 552:dvk_bind_X:378: ioctl ret=13
			DEBUG 553:dvk_bind_X:378: ioctl ret=14
			CHILD BIND dcid=6 child_pid=553 child_nr=14 child_ep=14 m_ptr=0x1a30008
			PARENT BIND dcid=6 parent_pid=552 parent_nr=13 parent_ep=13 m_ptr=0x1a30008
			PARENT pause before SEND
			PARENT SEND msg: m_type=15, m1_i1=1, m1_i2=2, m1_i3=3
			CHILD RECEIVE msg: m_source=0, m_type=15, m1_i1=1, m1_i2=2, m1_i3=3
		El dmesg
		[   81.665132] DEBUG 552:new_mini_send:125: dcid=6 caller_pid=552 caller_nr=13 dst_ep=14 
		[   81.665183] DEBUG 552:new_mini_send:203: destination is waiting. Copy the message and wakeup destination
		[   81.665441] DEBUG 552:copy_usr2usr:830: source=13 src_pid=552 src_addr=01a30008 dst_pid=553 dst_addr=01a30008 bytes=36
		[   81.665483] DEBUG 552:copy_usr2usr:835: WRITE
		[   81.665568] DEBUG 552:dvk_vm_rw:327: pid=553 liovcnt=1 riovcnt=1 flags=0 vm_write=1
		[   81.665645] DEBUG 552:dvk_check_iovect:1280: type=1 nr_segs=1
		[   81.665695] DEBUG 552:dvk_rw_check_kvector:862: type=1 nr_segs=1
		[   81.666114] DEBUG 552:dvk_rw_check_kvector:862: type=-1 nr_segs=1 <<< #define CHECK_IOVEC_ONLY -1
		[   81.666955] DEBUG 552:copy_usr2usr:852: len=36
		[   81.667044] DEBUG 552:inherit_cpu:287: cpuid=1
			
------------------------------------------------------------------------------------
20180727:
		Se comenzo con la integración de namespaces (NS) al DC.
		Primero habria que hacer y probar test_dvs_info
		asmlinkage long new_getdvsinfo(dvs_usr_t *dvs_usr_ptr);
		/*			new_getdvsinfo								*/
		/* On return: if (ret >= 0 ) return local_nodeid 		*/
		
		para luego el test_dc_init cambie el hostname del NS a local_nodeid.
		

		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215

		
		root@debian9:/usr/src/dvs/dvk-tests# ./test_dc_init -d 4
		PARENT dc_dcid=4 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32 flags=0 dc_nodes=0 dc_name=DC4
		PARENT dc_dcid=4 dc_warn2proc=27342 dc_warnmsg=0
		PARENT  Open dvk device file /dev/dvk
		PARENT Sysname:  Linux
		PARENT Nodename: debian9
		PARENT Release:  4.9.88
		PARENT Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
		PARENT Machine:  i686
		PARENT link_name:/proc/4479/ns/pid file_name=pid:[4026531836]
		CHILD link_name:/proc/4480/ns/pid file_name=pid:[4026532619]
		PARENT child_pid=4480
		PARENT child_pid=4480
		4480/ns/pid file_nameCHILD dc_dcid=4 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32 flags=0 dc_nodes=0 dc_name=DC4
		CHILD dc_dcid=4 dc_warn2proc=27342 dc_warnmsg=0
		DC4 has been initialized on node 3
		CHILD n_nodeid=3 n_proxies=-1 n_flags=6 n_dcs=70 n_name=node3
		CHILD Sysname:  Linux
		CHILD Nodename: node3
		CHILD Release:  4.9.88
		CHILD Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
		CHILD Machine:  i686

		AHORA, teniendo bloqueado como demonio el proceso child = 4480  pruebo el comando nsenter
			root@debian9:~# nsenter -p -t 4480
			root@debian9:~# echo $$
			2							<<<<< PID en el NS
			root@debian9:~# exit
			logout
			root@debian9:~# echo $$
			4489						<<<<<< PID REAL 

		El proceso test_dc_init se conviertio en demonio

------------------------------------------------------------------------------------
20180728:
		Para arrancar un proceso dentro del DC deberia utilizar nsenter 	
			PROBLEMA: Como obtengo el PID del demonio.
			SOLUCIONADO: Guardando en el dc_usr_t un campo que sea dc_id el cual se llena cuando 
						se hace el dvk_dc_init

				root@debian9:/usr/src/dvs/dvk-tests# ./test_dc_init -d 4
				PARENT dc_dcid=4 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
				PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC4
				PARENT dc_dcid=4 dc_warn2proc=27342 dc_warnmsg=0
				PARENT  Open dvk device file /dev/dvk
				CHILD  PID=1 PPID=0
				CHILD before dc_dcid=4 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
				CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC4 <<<<<<<<<<<<<<<<<<<<<<<<<<
				CHILD before dc_dcid=4 dc_warn2proc=27342 dc_warnmsg=0
				CHILD I am a daemon
				DC4 has been initialized on node 3
				CHILD n_nodeid=3 n_proxies=-1 n_flags=6 n_dcs=10 n_name=node3
				CHILD after  dc_dcid=4 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
				CHILD after  flags=0 dc_nodes=8 dc_pid=1602 dc_name=DC4 <<<<<<<<<<<<<<<<<<<<<<<<
				CHILD after  dc_dcid=4 dc_warn2proc=27342 dc_warnmsg=0
				CHILD Sysname:  Linux
				CHILD Nodename: node3
				CHILD Release:  4.9.88
				CHILD Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
				CHILD Machine:  i686
				CHILD pid:1
				PARENT Sysname:  Linux
				PARENT Nodename: debian9
				PARENT Release:  4.9.88
				PARENT Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
				PARENT Machine:  i686
				PARENT link_name:/proc/1601/ns/pid file_name=pid:[4026531836]
				CHILD link_name:/proc/1602/ns/pid file_name=pid:[4026532495]
				PARENT exiting - child_pid=1602
				CHILD pid:1
						
	PROBLEMA: Como puedo usar ese pid para usar nsenter ??
		RESPUESTA: se podría utilizar una variable de enterno con el mismo nombre del DC.
				NO SIRVE: porque se cambian las variables de entorno del propio proceso y no 
					del padre que es la shell.
				SOLUCION: Se crea un archivo <nombre_DC>.sh con los permisos de root
					root@debian9:/usr/src/dvs/dvk-tests# ./test_dc_init -d 10
					PARENT dc_dcid=10 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
					PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC10
					PARENT dc_dcid=10 dc_warn2proc=27342 dc_warnmsg=0
					PARENT  Open dvk device file /dev/dvk
					CHILD  PID=1 PPID=0
					CHILD before dc_dcid=10 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
					CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC10
					CHILD before dc_dcid=10 dc_warn2proc=27342 dc_warnmsg=0
					CHILD I am a daemon
					DC10 has been initialized on node 3
					CHILD n_nodeid=3 n_proxies=-1 n_flags=6 n_dcs=E7C01FFE n_name=node3
					CHILD after  dc_dcid=10 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
					CHILD after  flags=0 dc_nodes=8 dc_pid=988 dc_name=DC10
					CHILD after  dc_dcid=10 dc_warn2proc=27342 dc_warnmsg=0
					CHILD Sysname:  Linux
					CHILD Nodename: node3
					CHILD Release:  4.9.88
					CHILD Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
					CHILD Machine:  i686
					PARENT Sysname:  Linux
					PARENT Nodename: debian9
					PARENT Release:  4.9.88
					PARENT Version:  #9 SMP Tue Jul 24 19:07:43 -03 2018
					PARENT Machine:  i686
					PARENT link_name:/proc/987/ns/pid file_name=pid:[4026531836]
					CHILD link_name:/proc/988/ns/pid file_name=pid:[4026533383]
					PARENT exiting - child_pid=988
					
					root@debian9:/usr/src/dvs/dvk-tests# ls -l DC10.sh 
					-rwx------ 1 root root 33 jul 28 15:16 DC10.sh
					
					root@debian9:/usr/src/dvs/dvk-tests# . ./DC10.sh 
					root@debian9:/usr/src/dvs/dvk-tests# echo $DC10
					988
					root@debian9:/usr/src/dvs/dvk-tests# ./test_bind
					Usage: ./test_bind <dcid> <p_nr> 

					root@debian9:/usr/src/dvs/dvk-tests#  nsenter -p -t$DC10 ./test_bind 10 3
					Open dvk device file /dev/dvk
					Binding process 3 to DC10 with p_nr=3
					DEBUG 3:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=10 pid=3 endpoint=3 nodeid=-1
					DEBUG 3:dvk_bind_X:378: ioctl ret=-1
	ERROR!!!   		waiting to end ep=-1 errno=304 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

	
	dmesg>> [21436.046125] DEBUG 1003:dvk_open:173: 
			[21436.046276] DEBUG 1003:dvk_ioctl:210: cmd=4004E309 arg=BF9DDFF8
			[21436.046279] DEBUG 1003:dvk_ioctl:230: DVK_CALL=9 (bind) 
			[21436.047015] DEBUG 1003:new_bind:1333: oper=0 dcid=10 pid=3 endpoint=3 nodeid=-1
			[21436.047158] DEBUG 1003:new_bind:1355: RLOCK_DC dc=0 count=0
			[21436.047502] DEBUG 1003:new_bind:1368: WLOCK_PROC ep=3 count=0
			[21436.047553] DEBUG 1003:init_proc_desc:16: p_name=$noname dcid=10
			[21436.047704] DEBUG 1003:new_bind:1403: WUNLOCK_PROC ep=3 count=0
			[21436.047747] DEBUG 1003:new_bind:1404: RUNLOCK_DC dc=0 count=0
			[21436.047782] ERROR: 1003:new_bind:1404: rcode=-304


		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 0
		. ./DC0.sh
		echo $DC0
		nsenter -p -t$DC0 ./test_bind 0 3
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		
ESTA ES LA INFO IMPORTANTE [  212.089454] DEBUG 579:new_bind:1389: pid=2 real_pid=-372909696 task_pid=579 
[   93.164792] DEBUG 567:new_bind:1390: vpid=2 rpid=567 pvnr=2

		Resumiendo:
				El PID virtual en el NS actual es:
					pvnr = pid_vnr(get_task_pid(current, PIDTYPE_PID));
					siendo 
						struct pid *get_task_pid(struct task_struct *task, enum pid_type type)
						pid_t pid_vnr(struct pid *pid);
						
				El PID real en el NS de init/root es:
					rpid = task_pid_nr(current);	
					
				Se puede obtener el PID en un NS dado: 
					pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns);
				Este NS se puede obtener de la info guardada en el dc_usr_t
					struct task_struct *find_task_by_vpid(pid_t nr);
				
				/*  Must be called under rcu_read_lock(). */
						struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
				que es lo mismo que
						return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
						
				DESPUES DE LAS MODIFICACIONES, SELF BIND FUNCIONA BIEN
				root@debian9:/usr/src/dvs/dvk-tests# nsenter -p -t$DC0 ./test_bind 0 3
				Open dvk device file /dev/dvk
				Binding process 2 to DC0 with p_nr=3
				DEBUG 2:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=0 pid=2 endpoint=3 nodeid=-1
				DEBUG 2:dvk_bind_X:378: ioctl ret=3
				waiting to end ep=3 errno=0
								
				[  350.767234] DEBUG 1934:new_bind:1334: oper=0 dcid=0 param_pid=2 endpoint=3 nodeid=-1
				[  350.767325] DEBUG 1934:new_bind:1356: RLOCK_DC dc=0 count=0
				[  350.767397] DEBUG 1934:new_bind:1369: WLOCK_PROC ep=3 count=0
				[  350.767439] DEBUG 1934:init_proc_desc:16: p_name=$noname dcid=0
				[  350.767580] DEBUG 1934:new_bind:1391: param_pid=2 rpid=1934 vpid=2 tid=1934
				[  350.767627] DEBUG 1934:new_bind:1414: SELF_BIND param_pid=2 rpid=1934 vpid=2 tid=1934
				[  350.767662] DEBUG 1934:new_bind:1453: WUNLOCK_PROC ep=3 count=0
				[  350.767738] DEBUG 1934:new_bind:1456: WLOCK_TASK pid=1934 count=0
				[  350.767772] DEBUG 1934:new_bind:1457: WLOCK_PROC ep=3 count=0
				[  350.767806] DEBUG 1934:new_bind:1495: increment the reference count of the task struct=1934 count=2
				[  350.767866] DEBUG 1934:new_bind:1505: process p_name=test_bind *p_name_ptr=test_bind
				[  350.767993] DEBUG 1934:new_bind:1557: nr=3 endp=3 dcid=0 flags=0 misc=20 lpid=2 nodeid=3 nodemap=8 name=test_bind 
				[  350.768026] DEBUG 1934:new_bind:1558: nr=3 endp=3 dcid=0 lpid=2 p_cpumask=FFFFFFFF name=test_bind 
				[  350.768064] DEBUG 1934:new_bind:1CHILD2: WUNLOCK_PROC ep=3 count=0
				[  350.768118] DEBUG 1934:new_bind:1573: WUNLOCK_TASK pid=1934 count=0
				[  350.768159] DEBUG 1934:new_bind:1574: DC_INCREF counter=1
				[  350.768195] DEBUG 1934:new_bind:1575: RUNLOCK_DC dc=0 count=0

------------------------------------------------------------------------------------
20180730:		
	Se incorporo campo p_vcopy a la estructura proc_t para soportar las copias entre
	diferentes espacios de usuario y el kernels
			
	Se cambio test_sendrcv.c para que se pruebe el send y el receive esperando primero el receive y 
	luego el send.

	cd /usr/src/dvs/dvk-mod
	mknod /dev/dvk c 33 0
	dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
	insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
	dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
	cd /usr/src/dvs/dvk-tests
	./test_dvs_init -n 3 -D 16777215
	./test_dc_init -d 6
	dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
	./test_sendrcv 6 13 14
	dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
	
	root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrcv 6 13 14
	Open dvk device file /dev/dvk
	DEBUG 681:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=681 endpoint=13 nodeid=-1
	DEBUG 682:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=682 endpoint=14 nodeid=-1
	DEBUG 682:dvk_bind_X:378: ioctl ret=14
	CHILD BIND dcid=6 child_pid=682 child_nr=14 child_ep=14 m_ptr=0x22fe008
	CHILD FIRST RECEIVE
	DEBUG 681:dvk_bind_X:378: ioctl ret=13
	PARENT BIND dcid=6 parent_pid=681 parent_nr=13 parent_ep=13 m_ptr=0x22fe008
	PARENT pause before SEND
	PARENT FIRST SEND msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD RECEIVE msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	PARENT SECOND SEND msg:source=0 >>>>>>>>>type=11<<<<<< m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD SECOND RECEIVE
	CHILD RECEIVE msg:source=0 >>>>>>>>>type=10<<<<<<< ERROR  m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			
			
SI ANULO LA PRIMER TRANSFERENCIA DE MENSAJES SIGUE DANDO ERROR
	root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrcv 6 11 12
	Open dvk device file /dev/dvk
	DEBUG 693:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=693 endpoint=11 nodeid=-1
	DEBUG 693:dvk_bind_X:378: ioctl ret=11
	PARENT BIND dcid=6 parent_pid=693 parent_nr=11 parent_ep=11 m_ptr=0x21cc008
	PARENT pause before SEND
	DEBUG 694:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=694 endpoint=12 nodeid=-1
	DEBUG 694:dvk_bind_X:378: ioctl ret=12
	CHILD BIND dcid=6 child_pid=694 child_nr=12 child_ep=12 m_ptr=0x21cc008
	PARENT SECOND SEND msg:source=0 type=11 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD SECOND RECEIVE
	CHILD RECEIVE msg:source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			
	PROBLEMA EN USR2USR error copy and paste

AHORA FUNCIONA
	root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrcv 6 2 3
	Open dvk device file /dev/dvk
	DEBUG 576:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=576 endpoint=2 nodeid=-1
	DEBUG 576:dvk_bind_X:378: ioctl ret=2
	PARENT BIND dcid=6 parent_pid=576 parent_nr=2 parent_ep=2 m_ptr=0xd2e008
	PARENT pause before SEND
	DEBUG 577:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=577 endpoint=3 nodeid=-1
	DEBUG 577:dvk_bind_X:378: ioctl ret=3
	CHILD BIND dcid=6 child_pid=577 child_nr=3 child_ep=3 m_ptr=0xd2e008
	CHILD FIRST RECEIVE
	PARENT FIRST SEND msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	PARENT SECOND SEND msg:source=0 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD RECEIVE msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD SECOND RECEIVE
	CHILD RECEIVE msg:source=0 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	
ERROR: SE RECIBE CON source=0 !!!
	SOLUCION:
		En USR2USR hay que poner  m.source en el mensaje en modo usuario via put_user 
			put_user (	value_x, usr_ptr);

------------------------------------------------------------------------------------
20180730/31:	
	
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
	
	se prueba SENDREC - OK!
		root@debian9:/usr/src/dvs/dvk-tests# ./test_sendrec 6 11 12
		Open dvk device file /dev/dvk
		DEBUG 626:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=626 endpoint=11 nodeid=-1
		DEBUG 626:dvk_bind_X:378: ioctl ret=11
		PARENT BIND dcid=6 parent_pid=626 parent_nr=11 parent_ep=11 m_ptr=0xe15008
		PARENT pause before SENDREC
		DEBUG 627:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=627 endpoint=12 nodeid=-1
		DEBUG 627:dvk_bind_X:378: ioctl ret=12
		CHILD BIND dcid=6 child_pid=627 child_nr=12 child_ep=12 m_ptr=0xe15008
		CHILD FIRST RECEIVE
		PARENT FIRST SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD RECEIVE msg:source=11 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD FIRST SEND
		PARENT FIRST REPLY msg:source=12 type=254 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		PARENT SECOND SENDREC msg:source=12 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD SECOND RECEIVE
		CHILD RECEIVE msg:source=11 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD SECOND SEND
		PARENT SECOND REPLY msg:source=12 type=239 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 


	SE PRUEBA NOTIFY - OK!
		root@debian9:/usr/src/dvs/dvk-tests# ./test_ntfyrcv 6 9 10
		Open dvk device file /dev/dvk
		DEBUG 656:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=656 endpoint=9 nodeid=-1
		DEBUG 656:dvk_bind_X:378: ioctl ret=9
		PARENT BIND dcid=6 parent_pid=656 parent_nr=9 parent_ep=9 m_ptr=0x158b008
		PARENT pause before NOTIFY
		DEBUG 657:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=657 endpoint=10 nodeid=-1
		DEBUG 657:dvk_bind_X:378: ioctl ret=10
		CHILD BIND dcid=6 child_pid=657 child_nr=10 child_ep=10 m_ptr=0x158b008
		CHILD FIRST RECEIVE
		PARENT FIRST NOTIFY
		PARENT FIRST NOTIFY
		CHILD RECEIVE msg:source=9 type=4105 m1i1=0 m1i2=0 m1i3=1533077896 m1p1=0x2094bbff m1p2=(nil) m1p3=(nil) 
		CHILD SECOND RECEIVE
		CHILD RECEIVE msg:source=9 type=4105 m1i1=0 m1i2=0 m1i3=1533077906 m1p1=0x2104d8ed m1p2=(nil) m1p3=(nil) 

	SE PRUEBAN RCVRQST Y REPLY - OK!
		root@debian9:/usr/src/dvs/dvk-tests# ./test_rr_rply 6 7 8
		Open dvk device file /dev/dvk
		DEBUG 671:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=671 endpoint=7 nodeid=-1
		DEBUG 671:dvk_bind_X:378: ioctl ret=7
		PARENT BIND dcid=6 parent_pid=671 parent_nr=7 parent_ep=7 m_ptr=0x14b0008
		PARENT pause before SENDREC
		DEBUG 672:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=672 endpoint=8 nodeid=-1
		DEBUG 672:dvk_bind_X:378: ioctl ret=8
		CHILD BIND dcid=6 child_pid=672 child_nr=8 child_ep=8 m_ptr=0x14b0008
		CHILD FIRST RCVRQST
		PARENT FIRST SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD RCVRQST msg:source=7 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD FIRST REPLY
		PARENT FIRST REPLY msg:source=8 type=254 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		PARENT SECOND SENDREC msg:source=8 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD SECOND RCVRQST
		CHILD RCVRQST msg:source=7 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		CHILD SECOND REPLY
		PARENT SECOND REPLY msg:source=8 type=239 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 

------------------------------------------------------------------------------------
20180801:	SE PRUEBA VCOPY LOCAL
 
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		./test_lclvcopy 6 11 12 50
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		
		root@debian9:/usr/src/dvs/dvk-tests# ./test_lclvcopy 6 7 8  8192 
		Open dvk device file /dev/dvk
	PARENT buffer before = 012345678901234567890123456789012345678901234567890123456789
		DEBUG 1248:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=1248 endpoint=7 nodeid=-1
		DEBUG 1248:dvk_bind_X:378: ioctl ret=7
		PARENT BIND dcid=6 parent_pid=1248 parent_nr=7 parent_ep=7 m_ptr=0x1a3a008
		PARENT pause before SENDREC
	CHILD buffer before = ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ
		DEBUG 1249:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=1249 endpoint=8 nodeid=-1
		DEBUG 1249:dvk_bind_X:378: ioctl ret=8
		CHILD BIND dcid=6 child_pid=1249 child_nr=8 child_ep=8 m_ptr=0x1a3a008
		CHILD FIRST RECEIVE
		PARENT FIRST SENDREC msg:source=0 type=10 m1i1=8192 m1i2=2 m1i3=3 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
		CHILD RECEIVE msg:source=7 type=10 m1i1=8192 m1i2=2 m1i3=3 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
	VCOPY child_ep=8 to m_ptr->m_source=7 
		CHILD FIRST SEND
		PARENT FIRST REPLY msg:source=8 type=254 m1i1=8192 m1i2=2 m1i3=3 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
	PARENT buffer after = ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ
	
	PARENT buffer before = 012345678901234567890123456789012345678901234567890123456789
		PARENT SECOND SENDREC msg:source=8 type=11 m1i1=8192 m1i2=6 m1i3=7 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
		CHILD SECOND RECEIVE
		CHILD RECEIVE msg:source=7 type=11 m1i1=8192 m1i2=6 m1i3=7 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
	VCOPY m_ptr->m_source=7 to child_ep=8 
	CHILD buffer after = 012345678901234567890123456789012345678901234567890123456789
		CHILD SECOND SEND
		PARENT SECOND REPLY msg:source=8 type=239 m1i1=8192 m1i2=6 m1i3=7 m1p1=0x1a3b000 m1p2=(nil) m1p3=(nil) 
			
		
SE habilito DCx/procs/stats en dvk_procs.c
		root@debian9:~# cat /proc/dvs/DC6/stats 
		DCID p_nr -endp- -lpid- node --lsnt-- --rsnt-- -lcopy-- -rcopy-- name
		   6   11     11    585    3        0        0        0        0  test_bind		

Se habilito dvk_getep
		root@debian9:/usr/src/dvs/dvk-tests# ./test_bind 6 12
		Open dvk device file /dev/dvk
		Binding process 573 to DC6 with p_nr=12
		DEBUG 573:dvk_bind_X:370: dvk_bind_X cmd=0 dcid=6 pid=573 endpoint=12 nodeid=-1
		DEBUG 573:dvk_bind_X:378: ioctl ret=12
		dvk_getep=12
		waiting to end ep=12 errno=0
		root@debian9:/usr/src/dvs/dvk-tests# dmesg | grep getep
		[  481.527355] DEBUG 573:dvk_ioctl:230: DVK_CALL=29 (getep) 
		[  481.527440] DEBUG 573:new_getep:1899: pid=573
		[  481.529155] DEBUG 573:new_getep:1904: caller_pid=573 dcid=6
		[  481.529204] DEBUG 573:new_getep:1929: RLOCK_PROC ep=12 count=0
		[  481.529250] DEBUG 573:new_getep:1948: RUNLOCK_PROC ep=12 count=0
		[  481.529287] DEBUG 573:new_getep:1951: dcid=6
		[  481.529325] DEBUG 573:new_getep:1952: RLOCK_DC dc=0 count=0
		[  481.529360] DEBUG 573:new_getep:1955: RUNLOCK_DC dc=0 count=0
		[  481.529391] DEBUG 573:new_getep:1958: endpoint=12
	
	
Se habilito dvk_wait4bind 
root@debian9:/usr/src/dvs/dvk-tests# ./test_wait4bind 6 13 14
			Open dvk device file /dev/dvk
			PARENT: Test for self binding BEFORE binding 
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=35534 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=-1
			PARENT: dvk_wait4bind_T SELF rcode=-1
			PARENT: binding itself (627) to DC6 with parent_nr=13
			DEBUG 627:dvk_bind_X:420: cmd=0 dcid=6 pid=627 endpoint=13 nodeid=-1
			DEBUG 627:dvk_bind_X:428: ioctl ret=13
			PARENT: dvk_bind rcode=13
			PARENT: Test for self binding AFTER binding 
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=35534 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=13
			PARENT: dvk_wait4bind_T SELF rcode=13
			PARENT: waiting for child binding: 14
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=14 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=-1
			PARENT: waiting for child binding rcode=-1
			PARENT: waiting for child binding TIMEOUT
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=14 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=-1
			PARENT: waiting for child binding rcode=-1
			PARENT: waiting for child binding TIMEOUT
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=14 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=-1
			PARENT: waiting for child binding rcode=-1
			PARENT: waiting for child binding TIMEOUT
			DEBUG 627:dvk_wait4bindep_X:238: cmd=0 endpoint=14 timeout=1000
			CHILD: Binding process 628 to DC6 with p_nr=14
			DEBUG 628:dvk_bind_X:420: cmd=0 dcid=6 pid=628 endpoint=14 nodeid=-1
			DEBUG 628:dvk_bind_X:428: ioctl ret=14
			CHILD: dvk_bind child_ep=14
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=14
			PARENT: waiting for child binding rcode=14
			PARENT: Child 14 is bound
			PARENT: waiting for child 14 unbound
			DEBUG 627:dvk_wait4bindep_X:238: cmd=1 endpoint=14 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=-1
			PARENT: waiting for child unbinding rcode=-1
			PARENT: dvk_wait4unbind_T rcode=-1
			CHILD: exit
			DEBUG 627:dvk_wait4bindep_X:238: cmd=1 endpoint=14 timeout=1000
			DEBUG 627:dvk_wait4bindep_X:243: ioctl ret=0
			PARENT: waiting for child unbinding rcode=0

 
------------------------------------------------------------------------------------
20180802: Se habilitaron las llamadas
		new_add_node(int dcid, int nodeid)
		new_del_node(int dcid, int nodeid)
		Pero no pudieron probarse
		
			REDEFINI LOS NROS DE SYSCALLS Y ESO PROVOCO PROBLEMAS con dvk_vcopy()
[37354.786714] test_lclvcopy[1364]: segfault at 11 ip b75bdd6f sp bfcd9c4c error 4 in libc-2.24.so[b7548000+1b1000]
[37354.786825] DVK: exit_unbind local_nodeid:3

------------------------------------------------------------------------------------
20180803: Se soluciono el problema del vcopy,  en realidad erea un problema de un LIBDEBUG
		que en donde habia deberia haber habido un %d, habia un %s.
		
		
------------------------------------------------------------------------------------
20180804:
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt	
		./test_priv 6 1 2 
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt	
		
		
		root@debian9:/usr/src/dvs/dvk-tests# ./test_priv 6 5 6
		Open dvk device file /dev/dvk
		DEBUG 1319:dvk_bind_X:431: cmd=0 dcid=6 pid=1319 endpoint=5 nodeid=-1
		DEBUG 1319:dvk_bind_X:439: ioctl ret=5
		PARENT BIND dcid=6 parent_pid=1319 parent_nr=5 parent_ep=5 m_ptr=0x18fd008
		DEBUG 1320:dvk_bind_X:431: cmd=0 dcid=6 pid=1320 endpoint=6 nodeid=-1
		DEBUG 1320:dvk_bind_X:439: ioctl ret=6
		CHILD BIND dcid=6 child_pid=1320 child_nr=6 child_ep=6 m_ptr=0x18fd008
		CHILD RECEIVE
		DEBUG 1320:dvk_receive_T:292: endpoint=31438 timeout=-1
		DEBUG 1319:dvk_getpriv:367: dcid=6 endpoint=5 
		DEBUG 1319:dvk_getpriv:372: ioctl ret=0
		
	PARENT PRIV BEFORE :priv_id=40 priv_warn=27342 priv_level=0 trap=0 call=0

		PARENT pause before SENDREC
		PARENT SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		DEBUG 1319:dvk_sendrec_T:307: endpoint=6 timeout=-1
		DEBUG 1320:dvk_receive_T:297: ioctl ret=0
		CHILD RECEIVE msg:source=5 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 

	CHILD SET PRIV:priv_id=12 priv_warn=85 priv_level=4 trap=AA call=18

		DEBUG 1320:dvk_setpriv:353: dcid=6 endpoint=5 
		DEBUG 1320:dvk_setpriv:358: ioctl ret=0
		CHILD SEND
		DEBUG 1320:dvk_send_T:277: endpoint=5 timeout=-1
		DEBUG 1319:dvk_sendrec_T:312: ioctl ret=0
		PARENT REPLY msg:source=6 type=254 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		DEBUG 1319:dvk_getpriv:367: dcid=6 endpoint=5 
		DEBUG 1319:dvk_getpriv:372: ioctl ret=0
		
	PARENT PRIV AFTER :priv_id=12 priv_warn=85 priv_level=4 trap=AA call=18
		
		DEBUG 1320:dvk_send_T:282: ioctl ret=0

------------------------------------------------------------------------------------
20180807:
		Se habilitaron en dvk_hyper.c
			asmlinkage long new_wakeup(int dcid, int proc_ep)
			asmlinkage long new_proxies_bind(char *px_name, int px_nr, int spid, int rpid, int maxbuf)
			asmlinkage long new_proxies_unbind(int px_nr)
			asmlinkage long new_proxy_conn(int px_nr, int status)
			asmlinkage long new_node_up(char *node_name, int nodeid, int px_nr)
			asmlinkage long new_node_down(int nodeid)
		
		
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 6
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		
		root@debian9:/usr/src/dvs/dvk-tests# ./test_wakeup  6 14
			Open dvk device file /dev/dvk
			PARENT pause before WAKEUP
			DEBUG 682:dvk_bind_X:478: cmd=0 dcid=6 pid=682 endpoint=14 nodeid=-1
			DEBUG 682:dvk_bind_X:486: ioctl ret=14 errno=0
			CHILD BIND dcid=6 child_pid=682 child_nr=14 child_ep=14 m_ptr=0x1907008
			CHILD RECEIVE ANY
			DEBUG 682:dvk_receive_T:330: endpoint=31438 timeout=-1
			PARENT WAKEUP child_ep=14
			DEBUG 680:dvk_wakeup:184: dcid=6 dst_ep=14
			DEBUG 680:dvk_wakeup:188: ioctl ret=0 errno=0
			PARENT wait for child
			DEBUG 682:dvk_receive_T:335: ioctl ret=-1 errno=348
			ERROR: 682:dvk_receive_T:336: rcode=-348
			CHILD RECEIVE ret=-348 errno=348

			CHILD RECEIVE ANY
			[  558.713794] DEBUG 682:dvk_ioctl:204: cmd=4004E303 arg=BFE5CD70
			[  558.713797] DEBUG 682:dvk_ioctl:224: DVK_CALL=3 (mini_receive) 
			[  558.713837] DEBUG 682:io_mini_receive:35: 
			[  558.713925] DEBUG 682:new_mini_receive:288: src_ep=31438
			[  558.714025] DEBUG 682:check_caller:495: caller_pid=682 caller_tgid=682
			[  558.714270] DEBUG 682:check_caller:531: WLOCK_PROC ep=14 count=0
			[  558.714329] DEBUG 682:check_caller:560: WUNLOCK_PROC ep=14 count=0
			[  558.714373] DEBUG 682:check_caller:563: dcid=6
			[  558.714481] DEBUG 682:check_caller:567: RLOCK_DC dc=0 count=0
			[  558.714515] DEBUG 682:check_caller:CHILD2: RUNLOCK_DC dc=0 count=0
			[  558.714556] DEBUG 682:check_caller:577: caller_pid=682 
			[  558.714621] DEBUG 682:new_mini_receive:299: RLOCK_PROC ep=14 count=0
			[  558.714655] DEBUG 682:new_mini_receive:303: caller_nr=14 caller_ep=14 src_ep=31438 
			[  558.714689] DEBUG 682:new_mini_receive:307: dcid=6
			[  558.714745] DEBUG 682:new_mini_receive:311: RUNLOCK_PROC ep=14 count=0
			[  558.714798] DEBUG 682:new_mini_receive:313: RLOCK_DC dc=0 count=0
			[  558.714834] DEBUG 682:new_mini_receive:316: RUNLOCK_DC dc=0 count=0
			[  558.714897] DEBUG 682:new_mini_receive:366: WLOCK_PROC ep=14 count=0
			[  558.715014] DEBUG 682:new_mini_receive:465: Any suitable message from 31438 was not found.
			[  558.715065] DEBUG 682:sleep_proc:311: timeout=-1
			[  558.715116] DEBUG 682:sleep_proc:322: BEFORE DOWN lpid=682 p_sem=0 timeout=-1
			[  558.715141] DEBUG 682:sleep_proc:325: WUNLOCK_PROC ep=14 count=0
			[  558.715177] DEBUG 682:sleep_proc:326: endpoint=14 flags=8
			PARENT WAKEUP 
			[  561.711482] DEBUG 680:dvk_ioctl:204: cmd=4004E322 arg=BFE5CD74
			[  561.711489] DEBUG 680:dvk_ioctl:224: DVK_CALL=34 (wakeup) 
			[  561.711984] DEBUG 680:io_wakeup:353: 
			[  561.712154] DEBUG 680:new_wakeup:2339: dcid=6 proc_ep=14
			[  561.712232] DEBUG 680:new_wakeup:2346: caller_pid=680 caller_tgid=680
			[  561.717564] DEBUG 680:new_wakeup:2351: RLOCK_DC dc=0 count=0
			[  561.717631] DEBUG 680:new_wakeup:2354: RUNLOCK_DC dc=0 count=0
			[  561.717801] DEBUG 680:new_wakeup:2372: WLOCK_PROC ep=14 count=0
			[  561.717867] DEBUG 680:new_wakeup:2374: nr=14 endp=14 dcid=6 flags=8 misc=20 lpid=682 nodeid=3 nodemap=8 name=test_wakeup 
			[  561.718076] DEBUG 680:inherit_cpu:287: cpuid=1
			[  561.718964] DEBUG 680:inherit_cpu:295: nr=14 endp=14 dcid=6 lpid=682 p_cpumask=FFFFFFFF name=test_wakeup 
			[  561.719070] DEBUG 680:new_wakeup:2418: BEFORE UP lpid=682 p_sem=-1 rcode=-348
			[  561.719157] DEBUG 680:new_wakeup:2433: WUNLOCK_PROC ep=14 count=0
			CHILD WOKEN UP 
			[  561.720097] DEBUG 682:sleep_proc:334: endpoint=14 ret=0 p_rcode=-348 <<< 
			[  561.720149] DEBUG 682:sleep_proc:336: endpoint=14 flags=0 cpuid=1
			[  561.720208] DEBUG 682:sleep_proc:338: WLOCK_PROC ep=14 count=0
			[  561.720264] DEBUG 682:sleep_proc:353: pid=682 ret=-348
			[  561.720619] DEBUG 682:sleep_proc:376: nr=14 endp=14 dcid=6 lpid=682 p_cpumask=FFFFFFFF name=test_wakeup 
			[  561.720657] DEBUG 682:sleep_proc:378: someone wakeups me: sem=0 p_rcode=-348
			[  561.720761] DEBUG 682:new_mini_receive:482: WUNLOCK_PROC ep=14 count=0
			[  561.720831] ERROR: 682:new_mini_receive:483: rcode=-348
			[  561.720892] ERROR: 682:dvk_ioctl:228: rcode=-348<<<<<<<<<<<<<<<<<<<<<< EDVSWOKENUP
			
			
	Se modifico stub_dvkcall.c de tal modo que
		si el kernel devuelve un numero negativo en el return() entonces IOCTL retorna (-1) y errno=(-rcode)
		Esto afecta a todas las APIs que retorna endpoints, dado que estos son negativos.
		Ademas, cuando todas las APIS retornan un valor negativo, estas deben retornar (-errno);
	
		SOLUCION PARA A stop job is running for Session
				DefaultTimeoutStartSec=10s
				DefaultTimeoutStopSec=10s

------------------------------------------------------------------------------------
20180808: 	Se modificaron tests y loops en la impresion de errores
			Hay problemas con los PIDs cuando no esta encerrado en un NAMESPACE
			ERROR: Segfault cuando aparentemente hace ERROR_RETURN.
			
------------------------------------------------------				
	Se creo el directorio dvk_loops
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 0
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		. ./DC0.sh 
		cd /usr/src/dvs/dvk-loops
		echo $DC0
		
  EJECUTANDO CON NAMESPACE 		
	root@debian9:/usr/src/dvs/dvk-loops# nsenter -p -t$DC0 ./loop_dvk_ipc1 2
	Open dvk device file /dev/dvk
	
	DEBUG 2:dvk_bind_X:478: cmd=0 dcid=0 pid=2 endpoint=2 nodeid=-1
	DEBUG 2:dvk_bind_X:486: ioctl ret=2 errno=0
	BIND DESTINATION dcid=0 dst_pid=2 dst_nr=2 dst_ep=2
	
	DEBUG 2:dvk_bind_X:478: cmd=1 dcid=0 pid=3 endpoint=1 nodeid=-1
	DEBUG 2:dvk_bind_X:486: ioctl ret=1 errno=0
	BIND SOURCE dcid=0 src_pid=3 src_nr=1 src_ep=1

	RECEIVER pause before RECEIVE
	CHILD: dvk_wait4bind_T
	m_ptr 0x4e9000

	DEBUG 2:dvk_receive_T:330: endpoint=31438 timeout=-1
	
	DEBUG 3:dvk_wait4bindep_X:268: cmd=0 endpoint=35534 timeout=500
	DEBUG 3:dvk_wait4bindep_X:273: ioctl ret=1 errno=0
	CHILD: dvk_wait4bind_T  ret=1
	m_ptr 0x4e9000

	DEBUG 3:dvk_getep:89: pid=2
	DEBUG 3:dvk_getep:91: ioctl ret=2 errno=0

	SEND 3: source=0 type=255 m1i1=0 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	DEBUG 3:dvk_send_T:314: endpoint=2 timeout=-1
	DEBUG 3:dvk_send_T:319: ioctl ret=-1 errno=3
	ERROR: 3:dvk_send_T:320: rcode=-3  <<<<<<<<< EDVSSRCH /* no such process */
	
[   60.985087] DEBUG 566:dvk_ioctl:204: cmd=4004E302 arg=BF9C6580
[   60.985090] DEBUG 566:dvk_ioctl:224: DVK_CALL=2 (mini_send) 
[   60.985143] DEBUG 566:io_mini_send:24: 
[   60.985349] DEBUG 566:new_mini_send:39: dst_ep=2
[   60.985377] DEBUG 566:check_caller:495: caller_pid=566 caller_tgid=566
[   60.985380] DEBUG 566:check_caller:531: WLOCK_PROC ep=1 count=0
[   60.985497] DEBUG 566:check_caller:560: WUNLOCK_PROC ep=1 count=0
[   60.985501] DEBUG 566:check_caller:563: dcid=0
[   60.985503] DEBUG 566:check_caller:567: RLOCK_DC dc=0 count=0
[   60.985505] DEBUG 566:check_caller:CHILD2: RUNLOCK_DC dc=0 count=0
[   60.985507] DEBUG 566:check_caller:577: caller_pid=566 
[   60.985560] DEBUG 566:new_mini_send:51: RLOCK_PROC ep=1 count=0
[   60.985591] DEBUG 566:new_mini_send:55: caller_nr=1 caller_ep=1 dst_ep=2 
[   60.985615] DEBUG 566:new_mini_send:58: RUNLOCK_PROC ep=1 count=0
[   60.985647] DEBUG 566:new_mini_send:60: dcid=0
[   60.986829] DEBUG 566:new_mini_send:64: RLOCK_DC dc=0 count=0
[   60.986882] DEBUG 566:new_mini_send:67: RUNLOCK_DC dc=0 count=0
[   60.987037] DEBUG 566:new_mini_send:82: WLOCK_PROC ep=1 count=0
[   60.987101] DEBUG 566:new_mini_send:86: WLOCK_PROC ep=2 count=0
[   60.987129] DEBUG 566:new_mini_send:90: dst_nr=2 dst_ep=2
[   60.987172] DEBUG 566:new_mini_send:109: dst_ptr->p_usr.p_nodeid=3
[   60.987222] DEBUG 566:new_mini_send:113: RLOCK_DC dc=0 count=0
[   60.987266] DEBUG 566:new_mini_send:117: RUNLOCK_DC dc=0 count=0
[   60.987335] DEBUG 566:new_mini_send:132: dcid=0 caller_pid=566 caller_nr=1 dst_ep=2 
[   60.987403] DEBUG 566:new_mini_send:210: destination is waiting. Copy the message and wakeup destination
[   60.987691] DEBUG 566:copy_usr2usr:832: src_ep=1 src_pid=566 src_addr=004e9000 dst_ep=2 dst_pid=565 dst_addr=004e9000 bytes=36
[   60.987740] DEBUG 566:copy_usr2usr:836: task_pid_nr(current)=566
[   60.987786] DEBUG 566:copy_usr2usr:839: WRITE
[   60.987873] DEBUG 566:dvk_vm_rw:327: pid=565 liovcnt=1 riovcnt=1 flags=0 vm_write=1
[   60.987934] DEBUG 566:dvk_check_iovect:1280: type=1 nr_segs=1
[   60.987984] DEBUG 566:dvk_rw_check_kvector:862: type=1 nr_segs=1
[   60.988122] DEBUG 566:dvk_rw_check_kvector:862: type=-1 nr_segs=1
[   60.988298] DEBUG 566:copy_usr2usr:856: len=-3
[   60.988327] ERROR: 566:copy_usr2usr:857: rcode=-3
[   60.988385] DEBUG 566:new_mini_send:215: WUNLOCK_PROC ep=1 count=0
[   60.988421] DEBUG 566:new_mini_send:215: WUNLOCK_PROC ep=2 count=0
[   60.988452] ERROR: 566:new_mini_send:216: rcode=-3
[   60.988491] ERROR: 566:dvk_ioctl:228: rcode=-3
[   60.995677] loop_dvk_ipc1[566]: segfault at 76 ip b75b3d6f sp bf9c3a9c error 4 in libc-2.24.so[b753e000+1b1000]
[   60.997536] DVK: exit_unbind local_nodeid:3

PARA MI ES QUE 
		len = dvk_vm_rw(dst_proc->p_usr.p_lpid, lvec, 1, rvec, 1, 0, RW_WRITE);
que es equivalente a 
		static ssize_t process_vm_rw(pid_t pid, const struct iovec *lvec, 
			unsigned long liovcnt, const struct iovec *rvec, unsigned long riovcnt, unsigned long flags, int vm_write)
utilizan VPID.

SOLUCION: En el descriptor del proceso insertar el p_vpid para facilitar su gestion
MEJORA 1: Imprimirlo en DCx/procs como columna rpid/vpid
MEJORA 2: Imprimir	en DCx/info como columan el PID del demonio

CUANDO SE EJECUTA FUERA DE UN NAMESPACE 
root@debian9:/usr/src/dvs/dvk-loops# ./loop_dvk_ipc1 2
Open dvk device file /dev/dvk
DEBUG 575:dvk_bind_X:478: cmd=0 dcid=0 pid=575 endpoint=2 nodeid=-1
CHILD: dvk_wait4bind_T
DEBUG 575:dvk_bind_X:486: ioctl ret=2 errno=0
BIND DESTINATION dcid=0 dst_pid=575 dst_nr=2 dst_ep=2
DEBUG 575:dvk_bind_X:478: cmd=1 dcid=0 pid=576 endpoint=1 nodeid=-1
DEBUG 575:dvk_bind_X:486: ioctl ret=-1 errno=304
ERROR: 575:dvk_bind_X:492: rcode=-304 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
ViolaciÃ³n de segmento <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
DEBUG 576:dvk_wait4bindep_X:268: cmd=0 endpoint=35534 timeout=500
DEBUG 576:dvk_wait4bindep_X:273: ioctl ret=-1 errno=61
ERROR: 576:dvk_wait4bindep_X:280: rcode=-61
CHILD: dvk_wait4bind_T  ret=-61
CHILD: dvk_wait4bind_T TIMEOUT
DEBUG 576:dvk_wait4bindep_X:268: cmd=0 endpoint=35534 timeout=500
DEBUG 576:dvk_wait4bindep_X:273: ioctl ret=-1 errno=61
ERROR: 576:dvk_wait4bindep_X:280: rcode=-61
CHILD: dvk_wait4bind_T  ret=-61
CHILD: dvk_wait4bind_T TIMEOUT
DEBUG 576:dvk_wait4bindep_X:268: cmd=0 endpoint=35534 timeout=500
DEBUG 576:dvk_wait4bindep_X:273: ioctl ret=-1 errno=61
ERROR: 576:dvk_wait4bindep_X:280: rcode=-61
CHILD: dvk_wait4bind_T  ret=-61
CHILD: dvk_wait4bind_T TIMEOUT
DEBUG 576:dvk_wait4bindep_X:268: cmd=0 endpoint=35534 timeout=500
DEBUG 576:dvk_wait4bindep_X:273: ioctl ret=-1 errno=61
ERROR: 576:dvk_wait4bindep_X:280: rcode=-61
CHILD: dvk_wait4bind_T  ret=-61
CHILD: dvk_wait4bind_T TIMEOUT


[  397.196898] DEBUG 575:dvk_ioctl:204: cmd=4004E309 arg=BFBE5258
[  397.196972] DEBUG 575:dvk_ioctl:224: DVK_CALL=9 (bind) 
[  397.197040] DEBUG 575:io_bind:97: 
[  397.197173] DEBUG 575:new_bind:1334: oper=0 dcid=0 param_pid=575 endpoint=2 nodeid=-1
[  397.197270] DEBUG 575:new_bind:1356: RLOCK_DC dc=0 count=0
[  397.197365] DEBUG 575:new_bind:1369: WLOCK_PROC ep=2 count=0
[  397.197429] DEBUG 575:init_proc_desc:16: p_name=$noname dcid=0
[  397.197704] DEBUG 575:new_bind:1391: param_pid=575 rpid=575 vpid=575 tid=575
[  397.197754] DEBUG 575:new_bind:1414: SELF_BIND param_pid=575 rpid=575 vpid=575 tid=575
[  397.197813] DEBUG 575:new_bind:1453: WUNLOCK_PROC ep=2 count=0
[  397.197899] DEBUG 575:new_bind:1456: WLOCK_TASK pid=575 count=0
[  397.197936] DEBUG 575:new_bind:1457: WLOCK_PROC ep=2 count=0
[  397.198205] DEBUG 575:new_bind:1495: increment the reference count of the task struct=575 count=2
[  397.198523] DEBUG 575:new_bind:1505: process p_name=loop_dvk_ipc1 *p_name_ptr=loop_dvk_ipc1
[  397.198602] DEBUG 575:new_bind:1557: nr=2 endp=2 dcid=0 flags=0 misc=20 lpid=575 nodeid=3 nodemap=8 name=loop_dvk_ipc1 
[  397.198635] DEBUG 575:new_bind:1558: nr=2 endp=2 dcid=0 lpid=575 p_cpumask=FFFFFFFF name=loop_dvk_ipc1 
[  397.198692] DEBUG 575:new_bind:1CHILD2: WUNLOCK_PROC ep=2 count=0
[  397.198739] DEBUG 575:new_bind:1573: WUNLOCK_TASK pid=575 count=0
[  397.198783] DEBUG 575:new_bind:1574: DC_INCREF counter=1
[  397.198837] DEBUG 575:new_bind:1575: RUNLOCK_DC dc=0 count=0
[  397.198936] ERROR: 575:dvk_ioctl:228: rcode=2
[  397.202632] DEBUG 575:dvk_ioctl:204: cmd=4004E309 arg=BFBE5258
[  397.202638] DEBUG 575:dvk_ioctl:224: DVK_CALL=9 (bind) 
[  397.202640] DEBUG 575:io_bind:97: 
[  397.202644] DEBUG 575:new_bind:1334: oper=1 dcid=0 param_pid=576 endpoint=1 nodeid=-1
[  397.202647] DEBUG 575:new_bind:1356: RLOCK_DC dc=0 count=0
[  397.202649] DEBUG 575:new_bind:1369: WLOCK_PROC ep=1 count=0
[  397.202651] DEBUG 575:init_proc_desc:16: p_name=$noname dcid=0
[  397.202655] DEBUG 575:new_bind:1391: param_pid=576 rpid=575 vpid=575 tid=575
[  397.202766] DEBUG 575:new_bind:1425: WUNLOCK_PROC ep=1 count=0
[  397.202824] DEBUG 575:new_bind:1426: RUNLOCK_DC dc=0 count=0
[  397.202858] ERROR: 575:new_bind:1426: rcode=-304
[  397.202870] ERROR: 575:dvk_ioctl:228: rcode=-304
[  397.203691] loop_dvk_ipc1[575]: segfault at 34 ip b7595d91 sp bfbe278c error 4 in libc-2.24.so[b7520000+1b1000]

------------------------------------------------------------------------------------
20180809:
PROBAR en TEST_BIND todos los tipos de BINDS!!
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 3 -D 16777215
		./test_dc_init -d 0
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		. ./DC0.sh 
		echo $DC0
		
	FUNCION BIEN - HABIA PROBLEMAS EN EL BIND 
		root@debian9:/usr/src/dvs/dvk-tests# nsenter -p -t$DC0 ./test_bind 0 7
		Open dvk device file /dev/dvk
		PARENT dvk_bind Binding process 2 to DC0 with p_nr=7
		DEBUG 2:dvk_bind_X:478: cmd=0 dcid=0 pid=2 endpoint=7 nodeid=-1
		DEBUG 2:dvk_bind_X:486: ioctl ret=7 errno=0
		DEBUG 2:dvk_getep:89: pid=2
		DEBUG 2:dvk_getep:91: ioctl ret=7 errno=0
		PARENT ep=7 dvk_getep=7
		PARENT dvk_lclbind 3 to DC0 with p_nr+index=8
		DEBUG 2:dvk_bind_X:478: cmd=1 dcid=0 pid=3 endpoint=8 nodeid=-1
		DEBUG 2:dvk_bind_X:486: ioctl ret=8 errno=0
		DEBUG 2:dvk_getep:89: pid=3
		DEBUG 2:dvk_getep:91: ioctl ret=8 errno=0
		PARENT ep=8 dvk_getep=8
		PARENT waiting children index=2
		CHILD[1] dvk_lclbind
		CHILD[2] dvk_replbind Binding process 4 to DC0 with p_nr=9
		DEBUG 4:dvk_bind_X:478: cmd=4 dcid=0 pid=4 endpoint=9 nodeid=-1
		DEBUG 4:dvk_bind_X:486: ioctl ret=9 errno=0
		DEBUG 4:dvk_getep:89: pid=4
		DEBUG 4:dvk_getep:91: ioctl ret=9 errno=0
		CHILD[2] ep=9 dvk_getep=9
		DEBUG 3:dvk_getep:89: pid=3
		DEBUG 3:dvk_getep:91: ioctl ret=8 errno=0
		CHILD[1] dvk_getep=8
		CHILD[2] exit
		PARENT waiting children index=1
		CHILD[1] exit


		root@debian9:~# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
		 0   7     7   595/    2  3    0   20 27342 27342 27342 27342 test_bind      
		 0   8     8   596/    3  3    0   20 27342 27342 27342 27342 test_bind      
		 0   9     9   597/    4  3    0   A0 27342 27342 27342 27342 test_bind  
 
 
		root@debian9:~# cat /proc/dvs/DC0/info 
		dcid=0
		flags=0
		nr_procs=221
		nr_tasks=35
		nr_sysprocs=64
		nr_nodes=32
		dc_nodes=8
		dc_pid=565 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< OK!!
		warn2proc=27342
		warnmsg=0
		dc_name=DC0
		nodes 33222222222211111111110000000000
			  10987654321098765432109876543210
			  ----------------------------X---
		cpumask=f 

PRUEBA DE BIND CON THREADS
		root@debian9:/usr/src/dvs/dvk-tests#  nsenter -p -t$DC0 ./test_tbind 0 17
		Open dvk device file /dev/dvk
		PARENT 8 starting thread 0
		
		root@debian9:/usr/src/dvs/dvk-tests#  nsenter -p -t$DC0 ./test_tbind 0 20
		Open dvk device file /dev/dvk
		PARENT 11 starting thread 0
		THREAD 12 BIND Binding process 11 to DC0 with p_nr=20
		DEBUG 11:dvk_bind_X:478: cmd=0 dcid=0 pid=11 endpoint=20 nodeid=-1
		DEBUG 11:dvk_bind_X:486: ioctl ret=20 errno=0
		DEBUG 11:dvk_getep:89: pid=11
		DEBUG 11:dvk_getep:91: ioctl ret=20 errno=0
		THREAD 12 BIND ep=20 dvk_getep=20
		DEBUG 11:dvk_getep:89: pid=11
		DEBUG 11:dvk_getep:91: ioctl ret=20 errno=0
		PARENT pid=11 tid=11 BIND ep=0 dvk_getep=20
		PARENT 11 starting thread 1
		PARENT 11 waiting children i=0
		THREAD 13 TBIND Binding process 13 to DC0 with p_nr+1=21
		DEBUG 11:dvk_bind_X:478: cmd=0 dcid=0 pid=13 endpoint=21 nodeid=-1
		DEBUG 11:dvk_bind_X:486: ioctl ret=21 errno=0
		DEBUG 11:dvk_getep:89: pid=13
		DEBUG 11:dvk_getep:91: ioctl ret=21 errno=0
		THREAD 13 TBIND ep=21 dvk_getep=21
		THREAD 12 BIND exit
		PARENT 11 exiting

		root@debian9:~# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
		 0  20    20   891/11     3    0   20 27342 27342 27342 27342 test_tbind     
		 0  21    21   894/13     3    0    0 27342 27342 27342 27342 test_tbind  
 
 ------------------------------------------------------------------------------------
20180810:
		Se migraron los proxies TCP y TIPC  y sus versiones con LZ4 pero estas ultimas fallan en compilar 
		Se desarrollo TCP con batch de comandos.
		
		root@debian9:/usr/src/dvs/dvk-proxies# ./tcp_proxy node1 1 > node1.txt 2> error1.txt &

		El PS los muestra activos 
		root      2245   574  0 19:36 pts/0    00:00:00 ./tcp_proxy node1 1
		root      2246  2245  0 19:36 pts/0    00:00:00 ./tcp_proxy node1 1
		root      2247  2245  0 19:36 pts/0    00:00:00 ./tcp_proxy node1 

		El NETSTAT muestra el proxy receiver escuchando para el nodo=1 (3001)
		Proto Recv-Q Send-Q Local Address           Foreign Address         State      
		tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN  

		
 ------------------------------------------------------------------------------------
20180810/11:
		Se cambio la direccion IP del host a 192.168.1.100
		se seteo el hostname a node0
		se configuro el /etc/hosts 
		
		Se modifico el proxy.h para que contenga 
			#define _DEFAULT_SOURCE 
			#define _POSIX_C_SOURCE 
		necesarios para que funcione gethostbyname()
		
		Se modifico dvk_fsproc  para que muestre info y proc de proxies
		
		root@debian9:~# cat /proc/dvs/proxies/procs 
		ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
		 1 send    657      0      1        0        0  27342  27342  27342 tcp_proxy      
		 1 recv    658      0      1        0        0  27342  27342  27342 tcp_proxy  
		 
		root@debian9:~# cat /proc/dvs/proxies/info 
		Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
			  1     1    657      658           node1 ------------------------------X-
			  
		root@debian9:~# netstat -nat | grep 3001
		tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN     

		root@debian9:~# ps -ef | grep tcp_proxy
		root       656   531  0 11:51 pts/0    00:00:00 ./tcp_proxy node1 1
		root       657   656  0 11:51 pts/0    00:00:00 ./tcp_proxy node1 1
		root       658   656  0 11:51 pts/0    00:00:00 ./tcp_proxy node1 1
	
	PROBLEMA: El resto de los NODOS es porque no pudieron resolverse 
	SOLUCION: Se dieron de alta todos los nodos 0-31 en /etc/hosts
	
	./tcp_proxy node1  1  > node1.txt  2> error1.txt  &
	./tcp_proxy node2  2  > node2.txt  2> error2.txt  &
	./tcp_proxy node3  3  > node3.txt  2> error3.txt  &
	./tcp_proxy node4  4  > node4.txt  2> error4.txt  &
	./tcp_proxy node5  5  > node5.txt  2> error5.txt  &
	./tcp_proxy node6  6  > node6.txt  2> error6.txt  &
	./tcp_proxy node7  7  > node7.txt  2> error7.txt  &
	./tcp_proxy node8  8  > node8.txt  2> error8.txt  &
	./tcp_proxy node9  9  > node9.txt  2> error9.txt  &
	./tcp_proxy node10 10 > node10.txt 2> error10.txt &
	./tcp_proxy node11 11 > node11.txt 2> error11.txt &
	./tcp_proxy node12 12 > node12.txt 2> error12.txt &
	
root@node0:~# cat /proc/dvs/proxies/info 
Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
      1     1    576      578           node1 ------------------------------X-
      2     1    581      582           node2 -----------------------------X--
      3     1    574      575           node3 ----------------------------X---
      4     1    579      580           node4 ---------------------------X----
      5     1    583      584           node5 --------------------------X-----
      6     1    586      587           node6 -------------------------X------
      7     1    588      589           node7 ------------------------X-------
      8     1    591      592           node8 -----------------------X--------
      9     1    594      595           node9 ----------------------X---------
     10     1    599      600          node10 ---------------------X----------
     11     1    597      598          node11 --------------------X-----------
     12     1    603      604          node12 -------------------X------------
root@node0:~# cat /proc/dvs/proxies/procs 
ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
 1   send    576      0      1        0        0  27342  27342  27342 tcp_proxy      
 1   recv    578      0      1        0        0  27342  27342  27342 tcp_proxy      
 2   send    581      0      1        0        0  27342  27342  27342 tcp_proxy      
 2   recv    582      0      1        0        0  27342  27342  27342 tcp_proxy      
 3   send    574      0      1        0        0  27342  27342  27342 tcp_proxy      
 3   recv    575      0      1        0        0  27342  27342  27342 tcp_proxy      
 4   send    579      0      1        0        0  27342  27342  27342 tcp_proxy      
 4   recv    580      0      1        0        0  27342  27342  27342 tcp_proxy      
 5   send    583      0      1        0        0  27342  27342  27342 tcp_proxy      
 5   recv    584      0      1        0        0  27342  27342  27342 tcp_proxy      
 6   send    586      0      1        0        0  27342  27342  27342 tcp_proxy      
 6   recv    587      0      1        0        0  27342  27342  27342 tcp_proxy      
 7   send    588      0      1        0        0  27342  27342  27342 tcp_proxy      
 7   recv    589      0      1        0        0  27342  27342  27342 tcp_proxy      
 8   send    591      0      1        0        0  27342  27342  27342 tcp_proxy      
 8   recv    592      0      1        0        0  27342  27342  27342 tcp_proxy      
 9   send    594      0      1        0        0  27342  27342  27342 tcp_proxy      
 9   recv    595      0      1        0        0  27342  27342  27342 tcp_proxy      
10   send    599      0      1        0        0  27342  27342  27342 tcp_proxy      
10   recv    600      0      1        0        0  27342  27342  27342 tcp_proxy      
11   send    597      0      1        0        0  27342  27342  27342 tcp_proxy      
11   recv    598      0      1        0        0  27342  27342  27342 tcp_proxy      
12   send    603      0      1        0        0  27342  27342  27342 tcp_proxy      
12   recv    604      0      1        0        0  27342  27342  27342 tcp_proxy      
root@node0:~# netstat -nat 
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:3003            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3004            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3005            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3006            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3007            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3008            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3009            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3010            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3011            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3012            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3001            0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:3002            0.0.0.0:*               LISTEN     

Se instalo spread y se configuraron todos los nodos de 0-31 

Se incluyo en la libreria dvk_open() para que haga el open del dispositivo y listo e incluya a la variable dvk_fd 
Se modificaron todos los programas que hacen el fopen por dvk_open()

 ------------------------------------------------------------------------------------
20180812:

PROBAR PROXIES 
		root@node0:/usr/src/dvs/dvk-tests# cat /proc/dvs/DC0/info 
		dcid=0
		flags=0
		nr_procs=221
		nr_tasks=35
		nr_sysprocs=64
		nr_nodes=32
		dc_nodes=3
		dc_pid=580
		warn2proc=27342
		warnmsg=0
		dc_name=DC0
		nodes 33222222222211111111110000000000
			  10987654321098765432109876543210
			  ------------------------------XX
		cpumask=f 

		 0     6      -1        0        0 -------------------------------X node0           
		 1     2       1        0        0 -------------------------------X node1 

------------------------------------------------------------------------------------
20180822:
	Se creo el directorio dvk_loops
		cd /usr/src/dvs/dvk-mod
		mknod /dev/dvk c 33 0
		echo 0 > /proc/sys/kernel/hung_task_timeout_secs
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		insmod dvk.ko dvk_major=33 dvk_minor=0 dvk_nr_devs=1	
		dmesg -c > /usr/src/dvs/dvk-tests/dmesg.txt
		cd /usr/src/dvs/dvk-tests
		./test_dvs_init -n 1 -D 16777215
		./test_dc_init -d 0
		dmesg -c >> /usr/src/dvs/dvk-tests/dmesg.txt
		. ./DC0.sh 
		cd /usr/src/dvs/dvk-loops
		echo $DC0
		
		cd /usr/src/dvs/dvk-proxies/
		./tcp_proxy node1  1  > node1.txt  2> error1.txt  &

		./tcp_proxy node0  0  > node0.txt  2> error0.txt  &

		nsenter -p -t$DC0 ./loop_r-s_server 1 10 0

		
  EJECUTANDO CON NAMESPACE 		
	root@debian9:/usr/src/dvs/dvk-loops# nsenter -p -t$DC0 ./loop_dvk_ipc1 10
	
	En varias funciones donde se utilizaba p_lpid, se reemplazo por p_vpid
	
		Se probaron los loops loop_sr_mpeer  y loop_rr_mpeer.
		
------------------------------------------------------------------------------------
20180826:
	En NODE0
		root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -t$DC0 ./loop_r-s_server 1 10 0
		DEBUG 2:dvk_open:40: /dev/dvkDEBUG 2:dvk_getdcinfo:153: dcid=0
		DEBUG 2:dvk_getdcinfo:157: ioctl ret=0 errno=0
		 loop_r-s_server.c:main:118:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		 loop_r-s_server.c:main:119:flags=0 dc_nodes=3 dc_pid=542 dc_name=DC0
		 loop_r-s_server.c:main:140:MAIN SERVER m_ptr=0x2068000
		DEBUG 2:dvk_bind_X:502: cmd=0 dcid=0 pid=2 endpoint=0 nodeid=-1
		DEBUG 2:dvk_bind_X:510: ioctl ret=0 errno=0
		 loop_r-s_server.c:main:149:BIND MAIN SERVER dcid=0 svr_pid=2 SVR_NR=0 svr_ep=0
		DEBUG 2:dvk_bind_X:502: cmd=2 dcid=0 pid=-1075366268 endpoint=1 nodeid=1
		DEBUG 2:dvk_bind_X:510: ioctl ret=1 errno=0
		 loop_r-s_server.c:main:160:MAIN SERVER dvk_rmtbind 1: process client1 on node 1 
		 loop_r-s_server.c:main:164:child fork 0
		 loop_r-s_server.c:main:169:MAIN SERVER child_pid[0]=3
		 loop_r-s_server.c:main:173:MAIN SERVER: START synchronization from 1 children: REQUEST
		DEBUG 2:dvk_receive_T:338: endpoint=2 timeout=-1
		 loop_r-s_server.c:child_function:19:child 0: loops=10 child_nr=2
		DEBUG 3:dvk_bind_X:502: cmd=0 dcid=0 pid=3 endpoint=2 nodeid=-1
		DEBUG 2:dvk_receive_T:343: ioctl ret=-1 errno=108
		ERROR: 2:dvk_receive_T:344: rcode=-108
		DEBUG 3:dvk_bind_X:510: ioctl ret=2 errno=0
		 loop_r-s_server.c:child_function:25:CHILD child=0 child_nr=2 child_ep=2 child_pid=3
		DEBUG 3:dvk_bind_X:502: cmd=2 dcid=0 pid=-1075366376 endpoint=3 nodeid=1
		DEBUG 3:dvk_bind_X:510: ioctl ret=3 errno=0
		DEBUG 3:dvk_sendrec_T:354: endpoint=0 timeout=-1
		DEBUG 2:dvk_receive_T:338: endpoint=2 timeout=-1
		DEBUG 2:dvk_receive_T:343: ioctl ret=0 errno=108
		 loop_r-s_server.c:main:186:MAIN SERVER: START synchronization from 1 children: REPLY 
		DEBUG 2:dvk_send_T:322: endpoint=2 timeout=-1
		DEBUG 2:dvk_send_T:327: ioctl ret=0 errno=108
		 loop_r-s_server.c:main:197:MAIN SERVER: Waiting START message from remote CLIENT
		DEBUG 2:dvk_receive_T:338: endpoint=31438 timeout=-1
		DEBUG 3:dvk_sendrec_T:359: ioctl ret=0 errno=0
		 loop_r-s_server.c:child_function:48:CHILD 0: Starting loop
		DEBUG 3:dvk_receive_T:338: endpoint=3 timeout=-1



	EN NODE1
		root@node1:/usr/src/dvs/dvk-proxies/test# nsenter -p -t$DC0 ./loop_sr_client 1 10 0
		DEBUG 2:dvk_open:40: /dev/dvkDEBUG 2:dvk_getdcinfo:153: dcid=0
		DEBUG 2:dvk_getdcinfo:157: ioctl ret=0 errno=0
		 loop_sr_client.c:main:110:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		 loop_sr_client.c:main:111:flags=0 dc_nodes=3 dc_pid=492 dc_name=DC0
		MAIN CLIENT m_ptr=0xd33000
		DEBUG 2:dvk_bind_X:502: cmd=0 dcid=0 pid=2 endpoint=1 nodeid=-1
		DEBUG 2:dvk_bind_X:510: ioctl ret=1 errno=0
		BIND MAIN CLIENT dcid=0 clt_pid=2 CLT_NR=1 clt_ep=1
		child fork 0
		MAIN CLIENT child_pid[0]=3
		MAIN CLIENT: START 1 children synchronization: REQUEST
		DEBUG 2:dvk_receive_T:338: endpoint=3 timeout=-1
		DEBUG 2:dvk_receive_T:343: ioctl ret=-1 errno=108
		ERROR: 2:dvk_receive_T:344: rcode=-108
		child 0: loops=10 child_nr=3
		DEBUG 3:dvk_bind_X:502: cmd=2 dcid=0 pid=-1079736232 endpoint=2 nodeid=0
		DEBUG 3:dvk_bind_X:510: ioctl ret=2 errno=0
		DEBUG 3:dvk_bind_X:502: cmd=0 dcid=0 pid=3 endpoint=3 nodeid=-1
		DEBUG 3:dvk_bind_X:510: ioctl ret=3 errno=0
		CHILD child=0 child_nr=3 child_ep=3 child_pid=3
		DEBUG 3:dvk_sendrec_T:354: endpoint=1 timeout=-1
		DEBUG 2:dvk_receive_T:338: endpoint=3 timeout=-1
		DEBUG 2:dvk_receive_T:343: ioctl ret=0 errno=108
		DEBUG 2:dvk_bind_X:502: cmd=2 dcid=0 pid=-1079736128 endpoint=0 nodeid=0
		DEBUG 2:dvk_bind_X:510: ioctl ret=0 errno=108
		MAIN CLIENT dvk_rmtbind 0: process server0 on node 0 
		MAIN CLIENT: Sending START message to remote SERVER    <<<<<<<<<<<< SE ENVIA EL MENSAJE AL SERVER
		DEBUG 2:dvk_sendrec_T:354: endpoint=0 timeout=-1

	Esto se puede ver en el DMESG en el que desde NODE1,ep=1 se envia un mensaje a NODE0 ep=0
		[ 1353.804315] DEBUG 497:new_get2rmt:532: Someone wakes up the sender proxy
	[ 1353.804351] DEBUG 497:new_get2rmt:127: LIST_FOR_EACH_ENTRY_SAFE
	[ 1353.804389] DEBUG 518:sleep_proc:323: BEFORE DOWN lpid=518 p_sem=0 timeout=-1
	[ 1353.804396] DEBUG 497:new_get2rmt:131: RUNLOCK_PROC ep=27342 count=0
	[ 1353.804435] DEBUG 518:sleep_proc:326: WUNLOCK_PROC ep=1 count=0
	[ 1353.804496] DEBUG 518:sleep_proc:327: endpoint=1 flags=200C
	[ 1353.804544] DEBUG 497:new_get2rmt:132: WLOCK_PROC ep=1 count=0
	[ 1353.804605] DEBUG 497:new_get2rmt:133: WLOCK_PROC ep=27342 count=0
	[ 1353.804643] DEBUG 497:new_get2rmt:136: Found a message. p_endpoint=1 c_cmd=3
	[ 1353.804737] DEBUG 497:new_get2rmt:149: nr=1 endp=1 dcid=0 flags=200C misc=20 lpid=518 vpid=2 nodeid=1 name=loop_sr_client 
	[ 1353.804799] DEBUG 497:new_get2rmt:155: cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	[ 1353.805000] DEBUG 497:new_get2rmt:158: source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=  (null) m1p2=  (null) m1p3=  (null) 
	[ 1353.805066] DEBUG 497:new_get2rmt:162: n_nodeid=0 n_proxies=0 n_flags=E n_dcs=1 n_name=node0
	[ 1353.805200] DEBUG 497:new_get2rmt:171: WUNLOCK_PROC ep=27342 count=0
	[ 1353.805264] DEBUG 497:new_get2rmt:173: WUNLOCK_PROC ep=1 count=0
	[ 1353.805467] DEBUG 497:new_get2rmt:179: RLOCK_DC dc=0 count=0
	[ 1353.805545] DEBUG 497:new_get2rmt:185: RUNLOCK_DC dc=0 count=0
	[ 1353.805623] DEBUG 497:new_get2rmt:186: WLOCK_PROC ep=27342 count=0
	[ 1353.805665] DEBUG 497:new_get2rmt:189: WUNLOCK_PROC ep=27342 count=0
	[ 1353.805739] DEBUG 497:new_get2rmt:194: WLOCK_PROC ep=1 count=0
	[ 1353.807309] DEBUG 497:new_get2rmt:231: WUNLOCK_PROC ep=1 count=0
	[ 1353.807428] DEBUG 497:new_get2rmt:231: WLOCK_PROC ep=0 count=0
	[ 1353.807486] DEBUG 497:new_get2rmt:231: WLOCK_PROC ep=1 count=0
	[ 1353.807553] DEBUG 497:new_get2rmt:245: WUNLOCK_PROC ep=0 count=0
	[ 1353.807656] DEBUG 497:new_get2rmt:251: TIMESTAMP sec=1535320723 nsec=413911659
	[ 1353.808941] DEBUG 497:new_get2rmt:401: LOCAL nr=1 endp=1 dcid=0 flags=200C misc=20 lpid=518 vpid=2 nodeid=1 name=loop_sr_client 
	[ 1353.809284] DEBUG 497:new_get2rmt:457: CMD_SNDREC_MSG
	[ 1353.809493] DEBUG 497:new_get2rmt:465: source=1 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=  (null) m1p2=  (null) m1p3=  (null) 
	[ 1353.809583] DEBUG 497:new_get2rmt:504: cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	[ 1353.809647] DEBUG 497:new_get2rmt:506: WLOCK_PROC ep=27342 count=0
	[ 1353.809743] DEBUG 497:new_get2rmt:514: WUNLOCK_PROC ep=1 count=0
    [ 1353.809845] DEBUG 497:new_get2rmt:522: RUNLOCK_PROC ep=27342 count=0

	EL PROXY DE NODE1 LO OBTIENE DEL KERNEL Y LO ENVIA A NODE0
	 tcp_proxy.c:ps_start_serving:422:SPROXY 497: Waiting a message
	DEBUG 497:dvk_get2rmt_T:434: timeout=30000
	DEBUG 497:dvk_get2rmt_	T:439: ioctl ret=0 errno=61
	 tcp_proxy.c:ps_start_serving:442:SPROXY: 497 cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0 <<<<<<<<<<<<<<<<<< 
	 tcp_proxy.c:ps_start_serving:449:SPROXY: source=1 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	 tcp_proxy.c:ps_send_remote:393:SPROXY:cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	 tcp_proxy.c:ps_send_header:329:SPROXY: send header=88 
	 tcp_proxy.c:ps_send_header:347:SPROXY: socket=4 sent header=88 
	
	
	EL PROXY DE NODE0 LO RECIBE PERO CUANDO QUIERE HACER EL PUT2LCL 
	 tcp_proxy.c:pr_receive_header:108:RPROXY: n:88 | received:88 | HEADER_SIZE:88
	 tcp_proxy.c:pr_receive_header:110:RPROXY: cmd=0x0 dcid=0 src=0 dst=0 snode=0 dnode=0 rcode=0 len=0
	 tcp_proxy.c:pr_process_message:135:RPROXY:cmd=0x0 dcid=0 src=0 dst=0 snode=0 dnode=0 rcode=0 len=0
	 tcp_proxy.c:pr_process_message:132:RPROXY: About to receive header
	 tcp_proxy.c:pr_receive_header:102:socket=5
	 tcp_proxy.c:pr_receive_header:108:RPROXY: n:88 | received:88 | HEADER_SIZE:88
	 tcp_proxy.c:pr_receive_header:110:RPROXY: cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	 tcp_proxy.c:pr_process_message:135:RPROXY:cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	 tcp_proxy.c:pr_process_message:154:RPROXY: source=1 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	 tcp_proxy.c:pr_process_message:165:RPROXY: put2lcl
	DEBUG 547:dvk_put2lcl:205: 
	DEBUG 547:dvk_put2lcl:209: ioctl ret=-1 errno=3
	 tcp_proxy.c:pr_start_serving:255:RPROXY: Message processing failure [-3]

	EN EL DMESG DE NODO0 
			[ 1346.464613] DEBUG 547:dvk_ioctl:204: cmd=4004E314 arg=BFF09094
		[ 1346.464621] DEBUG 547:dvk_ioctl:224: DVK_CALL=20 (put2lcl) 
		[ 1346.464717] DEBUG 547:io_put2lcl:217: 
		[ 1346.464930] DEBUG 547:check_caller:496: caller_pid=547 caller_tgid=547
		[ 1346.464935] DEBUG 547:check_caller:532: WLOCK_PROC ep=27342 count=0
		[ 1346.464939] DEBUG 547:check_caller:561: WUNLOCK_PROC ep=27342 count=0
		[ 1346.464942] DEBUG 547:check_caller:578: caller_pid=547 
		[ 1346.465033] DEBUG 547:new_put2lcl:543: WLOCK_PROC ep=27342 count=0
		[ 1346.465163] DEBUG 547:new_put2lcl:567: WUNLOCK_PROC ep=27342 count=0
		[ 1346.465305] DEBUG 547:new_put2lcl:568: cmd=0x3 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
		[ 1346.465349] DEBUG 547:new_put2lcl:574: dcid=0
		[ 1346.465478] DEBUG 547:new_put2lcl:590: WLOCK_DC dc=0 count=0
		[ 1346.465627] DEBUG 547:new_put2lcl:620: TIMESTAMP sec=1535320723 nsec=395738671
		[ 1346.465755] DEBUG 547:new_put2lcl:625: WLOCK_PROC ep=0 count=0
		[ 1346.465814] DEBUG 547:new_put2lcl:625: WLOCK_PROC ep=1 count=0
		[ 1346.466128] DEBUG 547:new_put2lcl:673: REMOTE source OK endpoint=1
		[ 1346.466218] DEBUG 547:new_put2lcl:681: LOCAL destination OK endpoint=0
		[ 1346.467732] DEBUG 547:new_put2lcl:752: WLOCK_PROC ep=27342 count=0
		[ 1346.467787] DEBUG 547:new_put2lcl:754: WUNLOCK_PROC ep=27342 count=0
		[ 1346.467851] DEBUG 547:new_put2lcl:755: RUNLOCK_DC dc=0 count=0
		[ 1346.467956] DEBUG 547:new_put2lcl:763: CMD_SNDREC_MSG dcid=0 rmt_ep=1 rmt_nr=1 lcl_ep=0 lcl_nr=0
		[ 1346.468138] DEBUG 547:send_rmt2lcl:37: cmd=3 dcid=0 src_ep=1 src_flags=1000 dst_ep=0 dst_flags=8
		[ 1346.468396] DEBUG 547:send_rmt2lcl:44: source=1 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=  (null) m1p2=  (null) m1p3=  (null) 
		[ 1346.468468] DEBUG 547:send_rmt2lcl:51: destination is waiting. p_umsg=2068000
		[ 1346.468636] DEBUG 547:copy_usr2usr:833: src_ep=27342 src_lpid=547 src_vpid=-1 src_addr=01054034 dst_ep=0 dst_lpid=589 dst_vpid=2 dst_addr=02068000 bytes=36
		[ 1346.468687] DEBUG 547:copy_usr2usr:837: task_pid_nr(current)=547
		[ 1346.468733] DEBUG 547:copy_usr2usr:840: WRITE
		[ 1346.468885] DEBUG 547:dvk_vm_rw:327: pid=2 liovcnt=1 riovcnt=1 flags=0 vm_write=1
		[ 1346.468981] DEBUG 547:dvk_check_iovect:1280: type=1 nr_segs=1
		[ 1346.469064] DEBUG 547:dvk_rw_check_kvector:862: type=1 nr_segs=1
		[ 1346.469247] DEBUG 547:dvk_rw_check_kvector:862: type=-1 nr_segs=1
		[ 1346.469702] DEBUG 547:copy_usr2usr:857: len=-3  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  EDVSSRCH         (_SIGN  3)  /* no such process */ 
		[ 1346.469750] ERROR: 547:copy_usr2usr:858: rcode=-3
		[ 1346.469835] ERROR: 547:send_rmt2lcl:92: rcode=-3
		[ 1346.469916] DEBUG 547:new_put2lcl:848: WUNLOCK_PROC ep=0 count=0
		[ 1346.470031] DEBUG 547:new_put2lcl:848: WUNLOCK_PROC ep=1 count=0
		[ 1346.470622] DEBUG 547:new_put2lcl:864: WLOCK_PROC ep=27342 count=0
		[ 1346.470733] DEBUG 547:new_put2lcl:866: WUNLOCK_PROC ep=27342 count=0
		[ 1346.470815] ERROR: 547:new_put2lcl:869: rcode=-3
		[ 1346.470882] ERROR: 547:dvk_ioctl:228: rcode=-3
	
	
	ESTO SE DE A
			Cuando se hace copia copy_usr2usr por ejemplo, las copias se hacen utilizando
			len = dvk_vm_rw(dst_proc->p_usr.p_vpid, lvec, 1, rvec, 1, 0, RW_WRITE);
			len = dvk_vm_rw(src_proc->p_usr.p_vpid, lvec, 1, rvec, 1, 0, RW_READ);
			Que utilizan p_vpid, pero resulta que los PROXIES NO TIENEN CONTAINER!!!!	
	
	
	RCU_READ_LOCK;
	dc_ptr->dc_pid_ns			= task_active_pid_ns(current);
	RCU_READ_UNLOCK;
	
	struct pid_namespace *px_pid_ns;    /* para apuntar al ns de PIDs */

	rproxy_ptr->p_pid_ns= task_active_pid_ns(current);
	
------------------------------------------------------------------------------------
20180912:
		Durante la prueba de IPC remoto.

ERRORES VARIOS 

		Hubo un error que no registre relacionado con dvk_vm_rw.
		El error restaba relacionado con un DVKDEBUG donde se imprime task_pid_nr(task)
		Agregue un log a copy_usr2usr para que compruebe si la tarea era correcta.
				
		
	Al tratar de ejecutar en NODE0 
		cd /usr/src/dvs/dvk-tests
		./tests.sh 0 0
		. ./DC0.sh
		cd ../dvk-proxies/test
		nsenter -p -t$DC0 ./loop_r-s_server 1 10 0
	
	Si no se arranca el proxy de NODE1 entonces da un error aparentemente en exit.
	lo ultimo loggeado es
		Sep 12 23:38:58 node0 kernel: [  579.872113] DEBUG 507:new_getnodeinfo:1809: n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=1 n_name=node0
		Sep 12 23:38:58 node0 kernel: [  579.872154] DEBUG 507:new_getnodeinfo:1811: RLOCK_NODE node=0 count=0
		Sep 12 23:38:58 node0 kernel: [  579.872212] DEBUG 507:new_getnodeinfo:1813: RUNLOCK_NODE node=0 count=0
		Sep 12 23:38:58 node0 kernel: [  579.874957] DEBUG 507:dvk_ioctl:204: cmd=8004E30E arg=1E970E4
		Sep 12 23:38:58 node0 kernel: [  579.874962] DEBUG 507:dvk_ioctl:224: DVK_CALL=14 (getdcinfo) 
		Sep 12 23:38:58 node0 kernel: [  579.875040] DEBUG 507:io_getdcinfo:153: 
		Sep 12 23:38:58 node0 kernel: [  579.875128] DEBUG 507:new_getdcinfo:1764: dcid=0 
		Sep 12 23:38:58 node0 kernel: [  579.875183] DEBUG 507:check_caller:496: caller_pid=507 caller_tgid=507
		Sep 12 23:38:58 node0 kernel: [  579.875185] ERROR: 507:check_caller:530: rcode=-310
		Sep 12 23:38:58 node0 kernel: [  579.875247] DEBUG 507:new_getdcinfo:1776: RLOCK_DC dc=0 count=0
		Sep 12 23:38:58 node0 kernel: [  579.875288] DEBUG 507:new_getdcinfo:1778: RUNLOCK_DC dc=0 count=0
		Sep 12 23:38:58 node0 kernel: [  579.907459] DVK: exit_unbind local_nodeid:0
		Sep 12 23:38:58 node0 kernel: [  579.907549] DEBUG 508:new_exit_unbind:201: code=-713684952
		Sep 12 23:38:58 node0 kernel: [  579.907557] DEBUG 508:new_exit_unbind:205: WLOCK_TASK pid=508 count=0
		Sep 12 23:38:58 node0 kernel: [  579.907559] DEBUG 508:new_exit_unbind:336: Process not bound pid=508 systemd-journal
		Sep 12 23:38:58 node0 kernel: [  579.907564] DEBUG 508:new_exit_unbind:338: WUNLOCK_TASK pid=508 count=0

	
	Si se arranca el proxy en NODE1 Se cuelga y aparentemente lo hace en una funcion del kernel relacionada con la espera.
		El ultimo log en syslog es:
		Sep 12 23:06:15 node0 kernel: [  408.572848] DEBUG 537:new_get2rmt:530: Any message was not found.
		Sep 12 23:06:15 node0 kernel: [  408.572851] DEBUG 537:sleep_proc:312: timeout=30000
		Sep 12 23:06:15 node0 kernel: [  408.572855] DEBUG 537:sleep_proc:323: BEFORE DOWN lpid=537 p_sem=0 timeout=30000
		Sep 12 23:06:15 node0 kernel: [  408.572858] DEBUG 537:sleep_proc:326: WUNLOCK_PROC ep=27342 count=0
		Sep 12 23:06:15 node0 kernel: [  408.572861] DEBUG 537:sleep_proc:327: endpoint=27342 flags=8
	En NODE0 
	 loop_r-s_server.c:main:197:MAIN SERVER: Waiting START message from remote CLIENT
		DEBUG 2:dvk_receive_T:338: endpoint=31438 timeout=-1
		DEBUG 2:dvk_receive_T:343: ioctl ret=0 errno=108
		DEBUG 2:dvk_send_T:322: endpoint=1 timeout=-1
		DEBUG 2:dvk_send_T:327: ioctl ret=0 errno=108
		 loop_r-s_server.c:main:207:MAIN SERVER: Waiting STOP message from remote MAIN CLIENT
		DEBUG 2:dvk_receive_T:338: endpoint=1 timeout=-1

		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.334460] CPU: 0 PID: 551 Comm: loop_r-s_server Tainted: G        W  O    4.9.88 #10
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.335692] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.338337] task: d44b7340 task.stack: d44bc000
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.353520] Stack:
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.355945]  d4484a58 00000000 00000000 a20695ad d4484a00 ffffffff 00000000 d44bde18
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.358397]  f87c10d9 f87de904 00000227 f87db5c8 00000153 00000002 00000000 00000000
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.360524]  00000000 009ac0bc 00000003 d44849f8 d44b7340 d4484b84 00000000 d44b7340
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.362419] Call Trace:
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.364272]  [<f87c10d9>] ? sleep_proc+0x3e0/0x55c [dvk]
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.366707]  [<d20a9fb0>] ? prepare_to_wait_event+0xd0/0xd0
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.368941]  [<f87d0d85>] ? new_mini_receive+0xe63/0x1658 [dvk]
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.371063]  [<f87af888>] ? io_mini_receive+0x71/0xc3 [dvk]
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.373185]  [<f87af1e8>] ? dvk_ioctl+0xf0/0x184 [dvk]
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.375412]  [<f87af0f8>] ? dvk_write+0x3e/0x3e [dvk]
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.377889]  [<d21efb24>] ? do_vfs_ioctl+0x94/0x730
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.379926]  [<d25b77b3>] ? __switch_to_asm+0x33/0x4c
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.382521]  [<d2021dd6>] ? __switch_to+0x1d6/0x560
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.385130]  [<d25b2f98>] ? __schedule+0x268/0x770
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.388285]  [<d21f0220>] ? SyS_ioctl+0x60/0x70
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.391756]  [<d2003728>] ? do_fast_syscall_32+0x98/0x160
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.396915]  [<d25b7882>] ? sysenter_past_esp+0x47/0x75
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.402217] Code: 65 33 0d 14 00 00 00 89 f0 0f 85 06 01 00 00 83 c4 10 5b 5e 5f 5d c3 66 90 64 a1 48 d2 96 d2 8b 93 44 04 00 00 8b 80 48 04 00 00 <8b> 40 14 39 42 14 74 21 39 42 04 74 1c 8b 83 44 04 00 00 ba 17
		Message from syslogd@node0 at Sep 12 23:56:05 ...
		 kernel:[  760.411261] EIP: [<d2092632>] 
 
	
	En NODE1 pasa algo similar 
	Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  540.996418]  [<d6021dd6>] ? __switch_to+0x1d6/0x560
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  540.998220]  [<d65b77a7>] ? __switch_to_asm+0x27/0x4c
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.000029]  [<d65b2f98>] ? __schedule+0x268/0x770
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.001861]  [<d605fa53>] ? kmap_atomic_prot+0xd3/0xf0
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.003719]  [<d606b80b>] ? do_wait+0xdb/0x210
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.005727]  [<d606ca1f>] ? SyS_waitpid+0x6f/0xf0
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.007640]  [<d606a520>] ? task_stopped_code+0x60/0x60
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.009571]  [<d6003728>] ? do_fast_syscall_32+0x98/0x160
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.011535]  [<d65b7882>] ? sysenter_past_esp+0x47/0x75
		Message from syslogd@node1 at Sep 12 23:07:25 ...
		 kernel:[  541.013566] Code: 89 0d ff ff ff 8b 4d e4 85 c9 75 0b 8b 56 18 85 d2 0f 85 54 fd ff ff 31 c9 31 d2 89 f0 e8 6a 7f 01 00 89 45 e0 8b 86 44 04 00 00 <8b> 50 04 64 a1 48 d2 96 d6 8b 80 48 04 00 00 8b 40 6c e8 ba 97

 
 EN NODE0 el proxy envia un SEND 
		tcp_proxy.c:ps_start_serving:442:SPROXY: 530 cmd=0x1 dcid=0 src=0 dst=1 snode=0 dnode=1 rcode=0 len=0
	el proxy RECEIVER recibe SEND_ACK
		tcp_proxy.c:pr_receive_header:110:RPROXY: cmd=0x2001 dcid=0 src=1 dst=0 snode=1 dnode=0 rcode=0 len=0
	luego recibe un SENDREC
		tcp_proxy.c:pr_receive_header:110:RPROXY: cmd=0x3 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0

En NODE 0
[  725.886440] DEBUG 551:new_bind:1401: param_pid=3 lpid=551 vpid=3 tid=551
[  725.886442] DEBUG 551:new_bind:1425: SELF_BIND param_pid=3 lpid=551 vpid=3 tid=551
[  725.886444] DEBUG 551:new_bind:1446: WUNLOCK_PROC ep=2 count=0
[  725.886449] DEBUG 551:new_bind:1449: WLOCK_TASK pid=551 count=0
[  725.886451] DEBUG 551:new_bind:1450: WLOCK_PROC ep=2 count=0
[  725.886453] DEBUG 551:new_bind:1486: increment the reference count of the task struct=551 count=2
[  725.886455] DEBUG 551:new_bind:1496: process p_name=loop_r-s_server*\xffffffff\xffffffff\xffffffff\xffffffff\xffffff8cwK\xffffffd4 *p_name_ptr=loop_r-s_server
[  725.886458] DEBUG 551:new_bind:1549: nr=2 endp=2 dcid=0 flags=0 misc=20 lpid=551 vpid=3 nodeid=0 name=loop_r-s_server*\xffffffff\xffffffff\xffffffff\xffffffff\xffffff8cwK\xffffffd4 
[  725.886460] DEBUG 551:new_bind:1550: nr=2 endp=2 dcid=0 lpid=551 p_cpumask=FFFFFFFF nodemap=1 name=loop_r-s_server*\xffffffff\xffffffff\xffffffff\xffffffff\xffffff8cwK\xffffffd4 
[  725.886462] DEBUG 551:new_bind:1564: WUNLOCK_TASK pid=551 count=0
[  725.886464] DEBUG 551:new_bind:1570: WUNLOCK_PROC ep=2 count=0



[  760.322727] DEBUG 531:dvk_ioctl:204: cmd=4004E314 arg=BF89C7A4
[  760.322732] DEBUG 531:dvk_ioctl:224: DVK_CALL=20 (put2lcl) 
[  760.322735] DEBUG 531:io_put2lcl:217: 
[  760.322738] DEBUG 531:check_caller:496: caller_pid=531 caller_tgid=531
[  760.322741] DEBUG 531:check_caller:532: WLOCK_PROC ep=27342 count=0
[  760.322743] DEBUG 531:check_caller:561: WUNLOCK_PROC ep=27342 count=0
[  760.322745] DEBUG 531:check_caller:578: caller_pid=531 
[  760.322747] DEBUG 531:new_put2lcl:543: WLOCK_PROC ep=27342 count=0
[  760.322749] DEBUG 531:new_put2lcl:567: WUNLOCK_PROC ep=27342 count=0
[  760.322752] DEBUG 531:new_put2lcl:568: cmd=0x3 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
[  760.322754] DEBUG 531:new_put2lcl:574: dcid=0
[  760.322756] DEBUG 531:new_put2lcl:590: WLOCK_DC dc=0 count=0
[  760.322759] DEBUG 531:new_put2lcl:620: TIMESTAMP sec=1536807365 nsec=508907961
[  760.322761] DEBUG 531:new_put2lcl:625: WLOCK_PROC ep=2 count=0
[  760.322762] DEBUG 531:new_put2lcl:625: WLOCK_PROC ep=3 count=0
[  760.322764] DEBUG 531:new_put2lcl:673: REMOTE source OK endpoint=3
[  760.322765] DEBUG 531:new_put2lcl:681: LOCAL destination OK endpoint=2
[  760.322767] DEBUG 531:new_put2lcl:752: WLOCK_PROC ep=27342 count=0
[  760.322769] DEBUG 531:new_put2lcl:754: WUNLOCK_PROC ep=27342 count=0
[  760.322770] DEBUG 531:new_put2lcl:755: RUNLOCK_DC dc=0 count=0
[  760.322772] DEBUG 531:new_put2lcl:763: CMD_SNDREC_MSG dcid=0 rmt_ep=3 rmt_nr=3 lcl_ep=2 lcl_nr=2
[  760.322775] DEBUG 531:send_rmt2lcl:37: cmd=3 dcid=0 src_ep=3 src_flags=1000 dst_ep=2 dst_flags=8
[  760.322780] DEBUG 531:send_rmt2lcl:44: source=3 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=  (null) m1p2=  (null) m1p3=  (null) 
[  760.322819] DEBUG 531:send_rmt2lcl:51: destination is waiting. p_umsg=171A000
[  760.322824] DEBUG 531:copy_usr2usr:833: src_ep=27342 src_lpid=531 src_vpid=-1 src_addr=01acc034 dst_ep=2 dst_lpid=551 dst_vpid=3 dst_addr=0171a000 bytes=36
[  760.322825] DEBUG 531:copy_usr2usr:837: task_pid_nr(current)=531
[  760.322827] DEBUG 531:copy_usr2usr:840: WRITE
[  760.322828] DEBUG 531:copy_usr2usr:845: task_pid_nr(dst_proc->p_task)=551
[  760.322831] DEBUG 531:dvk_vm_rw:429: pid=551 liovcnt=1 riovcnt=1 flags=0 vm_write=1
[  760.322833] DEBUG 531:dvk_check_iovect:1280: type=1 nr_segs=1
[  760.322835] DEBUG 531:dvk_rw_check_kvector:862: type=1 nr_segs=1
[  760.322837] DEBUG 531:dvk_rw_check_kvector:862: type=-1 nr_segs=1
[  760.323014] ------------[ cut here ]------------
[  760.323224] WARNING: CPU: 0 PID: 531 at kernel/fork.c:390 __put_task_struct+0xdf/0x160
[  760.323285] Modules linked in: dvk(O) fuse iptable_filter snd_ens1371 snd_ac97_codec ac97_bus gameport snd_rawmidi snd_seq_device snd_pcm vmwgfx vmw_balloon joydev snd_timer snd ttm evdev serio_raw pcspkr drm_kms_helper soundcore sg drm shpchp vmw_vmci ac button ip_tables x_tables autofs4 crc32c_generic ext4 crc16 jbd2 fscrypto mbcache sr_mod cdrom ata_generic sd_mod hid_generic usbhid hid psmouse ata_piix mptspi scsi_transport_spi mptscsih mptbase libata ehci_pci pcnet32 mii i2c_piix4 uhci_hcd ehci_hcd scsi_mod usbcore
[  760.323893] CPU: 0 PID: 531 Comm: tcp_proxy Tainted: G           O    4.9.88 #10
[  760.323916] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015
[  760.324130]  d44b9c90 d22f7442 00000000 00000000 d2067a3a d2760598 00000000 00000213
[  760.324220]  d276a260 00000186 d206515f 00000186 00000009 d206515f d44b7340 cfd35000
[  760.324226]  d44b9d0c d44b9ca4 d2067b4a 00000009 00000000 00000000 d44b9cb4 d206515f
[  760.324299] Call Trace:
[  760.324914]  [<d22f7442>] ? dump_stack+0x55/0x73
[  760.324930]  [<d2067a3a>] ? __warn+0xea/0x110
[  760.324934]  [<d206515f>] ? __put_task_struct+0xdf/0x160
[  760.324937]  [<d206515f>] ? __put_task_struct+0xdf/0x160
[  760.324940]  [<d2067b4a>] ? warn_slowpath_null+0x2a/0x30
[  760.324943]  [<d206515f>] ? __put_task_struct+0xdf/0x160
[  760.324948]  [<d21ada23>] ? dvk_vm_rw+0x1f3/0x340
[  760.324954]  [<d20c3347>] ? vprintk_default+0x37/0x40
[  760.325341]  [<f87c3d50>] ? copy_usr2usr+0x230/0x35f [dvk]
[  760.325352]  [<f87c9df6>] ? send_rmt2lcl+0x365/0x3c5 [dvk]
[  760.325359]  [<f87cda6d>] ? new_put2lcl+0xeeb/0x1802 [dvk]
[  760.325373]  [<f87b048c>] ? io_put2lcl+0x6a/0xbc [dvk]
[  760.325379]  [<f87af1e8>] ? dvk_ioctl+0xf0/0x184 [dvk]
[  760.325384]  [<f87af0f8>] ? dvk_write+0x3e/0x3e [dvk]
[  760.325388]  [<d21efb24>] ? do_vfs_ioctl+0x94/0x730
[  760.325392]  [<d21dc5bd>] ? vfs_write+0x15d/0x1c0
[  760.325422]  [<d21f0220>] ? SyS_ioctl+0x60/0x70
[  760.325425]  [<d2003728>] ? do_fast_syscall_32+0x98/0x160
[  760.325433]  [<d25b7882>] ? sysenter_past_esp+0x47/0x75
[  760.325591] ---[ end trace 94af0696bfa637db ]---
[  760.325651] ------------[ cut here ]------------
[  760.325656] WARNING: CPU: 0 PID: 531 at kernel/fork.c:359 free_task+0x5f/0x70
[  760.325657] Modules linked in: dvk(O) fuse iptable_filter snd_ens1371 snd_ac97_codec ac97_bus gameport snd_rawmidi snd_seq_device snd_pcm vmwgfx vmw_balloon joydev snd_timer snd ttm evdev serio_raw pcspkr drm_kms_helper soundcore sg drm shpchp vmw_vmci ac button ip_tables x_tables autofs4 crc32c_generic ext4 crc16 jbd2 fscrypto mbcache sr_mod cdrom ata_generic sd_mod hid_generic usbhid hid psmouse ata_piix mptspi scsi_transport_spi mptscsih mptbase libata ehci_pci pcnet32 mii i2c_piix4 uhci_hcd ehci_hcd scsi_mod usbcore
[  760.325695] CPU: 0 PID: 531 Comm: tcp_proxy Tainted: G        W  O    4.9.88 #10
[  760.325697] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015
[  760.325698]  d44b9c94 d22f7442 00000000 00000000 d2067a3a d2760598 00000000 00000213
[  760.325704]  d276a260 00000167 d206506f 00000167 00000009 d206506f d44b7340 cfd35000
[  760.325710]  d44b9d0c d44b9ca8 d2067b4a 00000009 00000000 00000000 d44b9cb4 d206506f
[  760.325715] Call Trace:
[  760.325719]  [<d22f7442>] ? dump_stack+0x55/0x73
[  760.325722]  [<d2067a3a>] ? __warn+0xea/0x110
[  760.325725]  [<d206506f>] ? free_task+0x5f/0x70
[  760.325728]  [<d206506f>] ? free_task+0x5f/0x70
[  760.325731]  [<d2067b4a>] ? warn_slowpath_null+0x2a/0x30
[  760.325734]  [<d206506f>] ? free_task+0x5f/0x70
[  760.325736]  [<d21ada23>] ? dvk_vm_rw+0x1f3/0x340
[  760.325740]  [<d20c3347>] ? vprintk_default+0x37/0x40
[  760.325747]  [<f87c3d50>] ? copy_usr2usr+0x230/0x35f [dvk]
[  760.325753]  [<f87c9df6>] ? send_rmt2lcl+0x365/0x3c5 [dvk]
[  760.325759]  [<f87cda6d>] ? new_put2lcl+0xeeb/0x1802 [dvk]
[  760.325766]  [<f87b048c>] ? io_put2lcl+0x6a/0xbc [dvk]
[  760.325771]  [<f87af1e8>] ? dvk_ioctl+0xf0/0x184 [dvk]
[  760.325776]  [<f87af0f8>] ? dvk_write+0x3e/0x3e [dvk]
[  760.325779]  [<d21efb24>] ? do_vfs_ioctl+0x94/0x730
[  760.325782]  [<d21dc5bd>] ? vfs_write+0x15d/0x1c0
[  760.325785]  [<d21f0220>] ? SyS_ioctl+0x60/0x70
[  760.325788]  [<d2003728>] ? do_fast_syscall_32+0x98/0x160
[  760.325790]  [<d25b7882>] ? sysenter_past_esp+0x47/0x75
[  760.325794] ---[ end trace 94af0696bfa637dc ]---
[  760.325811] DEBUG 531:copy_usr2usr:859: len=36
[  760.325814] DEBUG 531:inherit_cpu:288: cpuid=0
[  760.325819] ERROR: 531:inherit_cpu:292: rcode=-22
[  760.325822] DEBUG 531:inherit_cpu:296: nr=2 endp=2 dcid=0 lpid=551 p_cpumask=FFFFFFFF nodemap=1 name=loop_r-s_server*\xffffffff\xffffffff\xffffffff\xffffffff\xffffff8cwK\xffffffd4 
[  760.325825] DEBUG 531:send_rmt2lcl:73: BEFORE UP lpid=551 p_sem=-1 rcode=0
[  760.325833] DEBUG 531:new_put2lcl:848: WUNLOCK_PROC ep=2 count=0
[  760.325835] DEBUG 531:new_put2lcl:848: WUNLOCK_PROC ep=3 count=0
[  760.329330] DEBUG 551:sleep_proc:335: endpoint=2 ret=0 p_rcode=0
[  760.329335] DEBUG 551:sleep_proc:337: endpoint=2 flags=0 cpuid=0
[  760.329337] DEBUG 551:sleep_proc:339: WLOCK_PROC ep=2 count=0
[  760.329895] BUG: unable to handle kernel NULL pointer dereference at 00000014
[  760.330287] IP: [<d2092632>] sched_setaffinity+0x82/0x180
[  760.330575] *pdpt = 0000000029676001 *pde = 0000000000000000 

[  760.330911] Oops: 0000 [#1] SMP
[  760.331208] Modules linked in: dvk(O) fuse iptable_filter snd_ens1371 snd_ac97_codec ac97_bus gameport snd_rawmidi snd_seq_device snd_pcm vmwgfx vmw_balloon joydev snd_timer snd ttm evdev serio_raw pcspkr drm_kms_helper soundcore sg drm shpchp vmw_vmci ac button ip_tables x_tables autofs4 crc32c_generic ext4 crc16 jbd2 fscrypto mbcache sr_mod cdrom ata_generic sd_mod hid_generic usbhid hid psmouse ata_piix mptspi scsi_transport_spi mptscsih mptbase libata ehci_pci pcnet32 mii i2c_piix4 uhci_hcd ehci_hcd scsi_mod usbcore
[  760.334460] CPU: 0 PID: 551 Comm: loop_r-s_server Tainted: G        W  O    4.9.88 #10
[  760.335692] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015
[  760.338337] task: d44b7340 task.stack: d44bc000
[  760.339745] EIP: 0060:[<d2092632>] EFLAGS: 00010246 CPU: 0
[  760.341184] EIP is at sched_setaffinity+0x82/0x180
[  760.342718] EAX: 00000000 EBX: d44b7340 ECX: cff6d5c0 EDX: 00000000
[  760.344319] ESI: d44b7350 EDI: ffffffea EBP: d44bddb8 ESP: d44bdd9c
[  760.345818]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
[  760.347391] CR0: 80050033 CR2: 00000014 CR3: 364ef640 CR4: 000006f0
[  760.353520] Stack:
[  760.355945]  d4484a58 00000000 00000000 a20695ad d4484a00 ffffffff 00000000 d44bde18
[  760.358397]  f87c10d9 f87de904 00000227 f87db5c8 00000153 00000002 00000000 00000000
[  760.360524]  00000000 009ac0bc 00000003 d44849f8 d44b7340 d4484b84 00000000 d44b7340
[  760.362419] Call Trace:
[  760.364272]  [<f87c10d9>] ? sleep_proc+0x3e0/0x55c [dvk]
[  760.366707]  [<d20a9fb0>] ? prepare_to_wait_event+0xd0/0xd0
[  760.368941]  [<f87d0d85>] ? new_mini_receive+0xe63/0x1658 [dvk]
[  760.371063]  [<f87af888>] ? io_mini_receive+0x71/0xc3 [dvk]
[  760.373185]  [<f87af1e8>] ? dvk_ioctl+0xf0/0x184 [dvk]
[  760.375412]  [<f87af0f8>] ? dvk_write+0x3e/0x3e [dvk]
[  760.377889]  [<d21efb24>] ? do_vfs_ioctl+0x94/0x730
[  760.379926]  [<d25b77b3>] ? __switch_to_asm+0x33/0x4c
[  760.382521]  [<d2021dd6>] ? __switch_to+0x1d6/0x560
[  760.385130]  [<d25b2f98>] ? __schedule+0x268/0x770
[  760.388285]  [<d21f0220>] ? SyS_ioctl+0x60/0x70
[  760.391756]  [<d2003728>] ? do_fast_syscall_32+0x98/0x160
[  760.396915]  [<d25b7882>] ? sysenter_past_esp+0x47/0x75
[  760.402217] Code: 65 33 0d 14 00 00 00 89 f0 0f 85 06 01 00 00 83 c4 10 5b 5e 5f 5d c3 66 90 64 a1 48 d2 96 d2 8b 93 44 04 00 00 8b 80 48 04 00 00 <8b> 40 14 39 42 14 74 21 39 42 04 74 1c 8b 83 44 04 00 00 ba 17
[  760.411261] EIP: [<d2092632>] 
[  760.411343] sched_setaffinity+0x82/0x180
[  760.414047]  SS:ESP 0068:d44bdd9c
[  760.423425] CR2: 0000000000000014
[  760.432265] ---[ end trace 94af0696bfa637dd ]---
[  760.435270] DVK: exit_unbind local_nodeid:0
[  760.440990] DEBUG 551:new_exit_unbind:201: code=-764016600

El error lo da en
	static ssize_t dvk_vm_rw(struct task_struct *task,.......
		funcion 
		rc = dvk_vm_rw_core(task, &iter, rvec, riovcnt, flags, vm_write);

------------------------------------------------------------------------------------
20180914:
		EN NODE0

DEBUG 3:dvk_send_T:345: endpoint=3 timeout=-1
DEBUG 3:dvk_send_T:350: ioctl ret=0 errno=0
DEBUG 3:dvk_receive_T:362: endpoint=3 timeout=-1

Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.896074] CPU: 0 PID: 1541 Comm: tcp_proxy Tainted: G        W  O    4.9.88 #10
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.897546] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.900556] task: e99a1500 task.stack: e999e000
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.911162] Stack:
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.912856]  e999fc88 e999fc7c d0168dcb 0099fcb4 e99a0758 e99a0280 00000012 e999fca0
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.914599]  d0072885 e9d69400 00000012 e99a0280 e999fcb4 d00653e4 00000000 00000001
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.916410]  e999fd0c e999fd5c d01ad980 e999fcf4 00000605 d05ce408 000001ad 00000618
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.918275] Call Trace:
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.920164]  [<d0168dcb>] ? printk+0x1a/0x1c
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.922101]  [<d0072885>] ? ptrace_may_access+0x25/0x40
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.924130]  [<d00653e4>] ? mm_access+0x54/0x80
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.926132]  [<d01ad980>] ? dvk_vm_rw+0x150/0x340
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.928156]  [<d00c3347>] ? vprintk_default+0x37/0x40
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.930485]  [<f87d6c7f>] ? copy_usr2usr+0x230/0x35f [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.933598]  [<f87dcd25>] ? send_rmt2lcl+0x365/0x3c5 [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.936424]  [<f87e099c>] ? new_put2lcl+0xeeb/0x1802 [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.938804]  [<f87c348c>] ? io_put2lcl+0x6a/0xbc [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.941854]  [<f87c21e8>] ? dvk_ioctl+0xf0/0x184 [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.944363]  [<f87c20f8>] ? dvk_write+0x3e/0x3e [dvk]
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.947086]  [<d01efb24>] ? do_vfs_ioctl+0x94/0x730
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.949640]  [<d01dc5bd>] ? vfs_write+0x15d/0x1c0
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.952006]  [<d01f0220>] ? SyS_ioctl+0x60/0x70
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.954815]  [<d0003728>] ? do_fast_syscall_32+0x98/0x160
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.957732]  [<d05b7882>] ? sysenter_past_esp+0x47/0x75
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.959815] Code: 38 45 f3 0f 85 c4 00 00 00 8b 86 7c 04 00 00 39 82 7c 04 00 00 0f 84 92 00 00 00 85 ff 75 5e 8b 51 04 8b 49 08 8b 86 44 04 00 00 <3b> 50 14 75 05 39 50 0c 74 58 8b 40 6c 89 da e8 4e ff ff ff 85
Message from syslogd@node0 at Sep 14 20:36:38 ...
 kernel:[26977.966466] EIP: [<d00720fe>] 

PROBLEMA EN EL PROXY RECEIVER  
	new_put2lcl
		send_rmt2lcl 
			copy_usr2usr
				dvk_vm_rw
					mm_access
 
 ------------------------------------------------------------------------------------
20180915:
	
en NODE0:	
		cd /usr/src/dvs/dvk-tests
		./tests.sh 0 0
		. ./DC0.sh
		cd ../dvk-proxies/test	
		nsenter -p -t$DC0 ./loop_r-s_server 1 10 0
en NODE1:		
		cd /usr/src/dvs/dvk-tests
		./tests.sh 1 0
		. ./DC0.sh
		cd ../dvk-proxies/test
		nsenter -p -t$DC0 ./loop_sr_client 1 10 0

		LISTO !! FUNCIONO LA TRANSFERENCIA REMOTA DE MENSAJES
		
		El error estaba en process_vm_access funcion dvk_vm_rw_core
		/* Get process information */
		if (!task) {
			rc = -ESRCH;
			goto free_proc_pages;
		}else{
			rcu_read_lock();<<<<  FALTABA ESTO
			get_task_struct(task); <<<<  FALTABA ESTO
			rcu_read_unlock();<<<<  FALTABA ESTO
		}
		
		LISTO !! FUNCIONO LA TRANSFERENCIA REMOTA DE DATOS 
		
	PROBADOS: 
			new_put2lcl
			new_get2rmt
			
	SE MODIFICO copy_usr2usr y por ahora sleep_proc que dispara la funcion copy_trampoline
		tambien se modifico la prueba de copia en 3 partes. test_vcopy4.
		
	FALTA PROBAR TODO.
	Usage: ./test_lclvcopy3 <dcid> <parent_nr> <child1_nr> <child2_nr> <maxbuf>  

		nsenter -p -t$DC0 ./test_lclvcopy3 0 1 2 3 60
		
root@node0:/usr/src/dvs/dvk-tests# nsenter -p -t$DC0 ./test_lclvcopy3 0 1 2 3 60
		DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
		DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=2 endpoint=1 nodeid=-1
		DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0
		PARENT BIND dcid=0 parent_pid=2 parent_nr=1 parent_ep=1 m_ptr=0xca1058
		DEBUG 4:dvk_bind_X:536: cmd=0 dcid=0 pid=4 endpoint=3 nodeid=-1
		DEBUG 4:dvk_bind_X:544: ioctl ret=3 errno=0
		DEBUG 3:dvk_bind_X:536: cmd=0 dcid=0 pid=3 endpoint=2 nodeid=-1
		DEBUG 3:dvk_bind_X:544: ioctl ret=2 errno=0
		CHILD2 BIND dcid=0 child2_pid=4 child2_nr=3 child2_ep=3 buffer=0xca2000
		CHILD1 BIND dcid=0 child1_pid=3 child1_nr=2 child1_ep=2 buffer=0xca2000
	CHILD1 buffer before = ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJÉÿ
		CHILD1 SENDREC msg:source=0 type=10 m1i1=60 m1i2=2 m1i3=3 m1p1=0xca2000 m1p2=(nil) m1p3=(nil) 
		DEBUG 3:dvk_sendrec_T:379: endpoint=1 timeout=-1
	CHILD2 buffer before = 012345678901234567890123456789012345678901234567890123456789Éÿ
		CHILD2 SENDREC msg:source=0 type=10 m1i1=60 m1i2=2 m1i3=3 m1p1=0xca2000 m1p2=(nil) m1p3=(nil) 
		DEBUG 4:dvk_sendrec_T:379: endpoint=1 timeout=-1
		CHILD1 RECEIVE
		DEBUG 2:dvk_receive_T:362: endpoint=2 timeout=-1
		DEBUG 2:dvk_receive_T:367: ioctl ret=36 errno=0
		ERROR: test_lclvcopy3.c:main:64: rcode=36
		CHILD1 RECEIVE msg:source=2 type=10 m1i1=60 m1i2=2 m1i3=3 m1p1=0xca2000 m1p2=(nil) m1p3=(nil) 
		CHILD2 RECEIVE
		DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1
		DEBUG 2:dvk_receive_T:367: ioctl ret=36 errno=0
		ERROR: test_lclvcopy3.c:main:69: rcode=36
		CHILD2 RECEIVE msg:source=3 type=10 m1i1=60 m1i2=2 m1i3=3 m1p1=0xca2000 m1p2=(nil) m1p3=(nil) 
	CHILD1 to CHILD2 VCOPY child1_ep=2 to child1_ep=3
		DEBUG 2:dvk_vcopy:52: src_ep=2 dst_ep=3 bytes=60
		DEBUG 2:dvk_vcopy:60: ioctl ret=60 errno=0
		ERROR: test_lclvcopy3.c:main:74: rcode=60
		CHILD1 SEND
		DEBUG 2:dvk_send_T:345: endpoint=2 timeout=-1
		DEBUG 2:dvk_send_T:350: ioctl ret=36 errno=0
		ERROR: test_lclvcopy3.c:main:79: rcode=36
		CHILD2 SEND
		DEBUG 2:dvk_send_T:345: endpoint=3 timeout=-1
		DEBUG 2:dvk_send_T:350: ioctl ret=36 errno=0
		ERROR: test_lclvcopy3.c:main:84: rcode=36
		DEBUG 4:dvk_sendrec_T:384: ioctl ret=0 errno=0
		CHILD2 REPLY msg:source=1 type=254 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD2 buffer after = ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJÉÿ
		DEBUG 3:dvk_sendrec_T:384: ioctl ret=0 errno=0
		CHILD1 REPLY msg:source=1 type=254 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
	CHILD1 buffer after = ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJÉÿ
	
	TODO:	Probar el loop de vcopy
		nsenter -p -t$DC0 ./loop_dvk_copy1 10 50 
	
	root@node0:/usr/src/dvs/dvk-loops# nsenter -p -t$DC0 ./loop_dvk_copy1 5 50
			m_ptr 0x6fb000
			DEBUG 8:dvk_open:40: Open dvk device file /dev/dvk
			DEBUG 8:dvk_bind_X:536: cmd=0 dcid=0 pid=8 endpoint=2 nodeid=-1
			DEBUG 8:dvk_bind_X:544: ioctl ret=2 errno=0
			BIND DESTINATION dcid=0 dst_pid=8 dst_nr=2 dst_ep=2
			RECEIVER pause before RECEIVE
			CHILD BEFORE buffer:ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ
			DEBUG 9:dvk_bind_X:536: cmd=0 dcid=0 pid=9 endpoint=1 nodeid=-1
			DEBUG 9:dvk_bind_X:544: ioctl ret=1 errno=0
			BIND SOURCE dcid=0 src_pid=9 src_nr=1 src_ep=1
			SEND msg: source=0 type=1 m1i1=0 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			DEBUG 9:dvk_sendrec_T:379: endpoint=2 timeout=-1
			DEBUG 8:dvk_getep:102: pid=9
			DEBUG 8:dvk_getep:104: ioctl ret=1 errno=0
			PARENT buffer:01234567890123456789012345678901234567890123456789
			DEBUG 8:dvk_receive_T:362: endpoint=31438 timeout=-1
			DEBUG 8:dvk_receive_T:367: ioctl ret=36 errno=0
			DEBUG 8:dvk_vcopy:52: src_ep=2 dst_ep=1 bytes=50
			DEBUG 8:dvk_vcopy:60: ioctl ret=50 errno=0
			DEBUG 8:dvk_vcopy:52: src_ep=2 dst_ep=1 bytes=50
			DEBUG 8:dvk_vcopy:60: ioctl ret=50 errno=0
			DEBUG 8:dvk_vcopy:52: src_ep=2 dst_ep=1 bytes=50
			DEBUG 8:dvk_vcopy:60: ioctl ret=50 errno=0
			DEBUG 8:dvk_vcopy:52: src_ep=2 dst_ep=1 bytes=50
			DEBUG 8:dvk_vcopy:60: ioctl ret=50 errno=0
			DEBUG 8:dvk_vcopy:52: src_ep=2 dst_ep=1 bytes=50
			DEBUG 8:dvk_vcopy:60: ioctl ret=50 errno=0
			DEBUG 8:dvk_send_T:345: endpoint=1 timeout=-1
			DEBUG 8:dvk_send_T:350: ioctl ret=36 errno=0
			UNBIND DESTINATION dcid=0 dst_pid=8 dst_nr=2 dst_ep=2
			DEBUG 8:dvk_unbind_T:329: dcid=0 endpoint=2 timeout=-1
			DEBUG 8:dvk_unbind_T:334: ioctl ret=0 errno=0
			t_start=1537144158.87 t_stop=1537144158.87 t_total=0.00
			transfer size=50 #transfers=5 loopbysec=5902.482409
			Throuhput = 295124.120462 [bytes/s]
			DEBUG 9:dvk_sendrec_T:384: ioctl ret=0 errno=0
			CHILD AFTER buffer:01234567890123456789012345678901234567890123456789
			UNBIND SOURCE dcid=0 src_pid=9 src_nr=1 src_ep=1
			DEBUG 9:dvk_unbind_T:329: dcid=0 endpoint=1 timeout=-1
			DEBUG 9:dvk_unbind_T:334: ioctl ret=0 errno=0
	
	TODO: 	Probar copia remota .
		NODE0
			nsenter -p -t$DC0 ./loop_copy_server 1 5 50
			
			t_start=1537144912.22 t_stop=1537144912.28 t_total=0.05
			transfer size=50 #transfers=5 loopbysec=94.229459
			Throuhput = 4711.472964 [bytes/s]

		NODE1
			nsenter -p -t$DC0 ./loop_copy_client 1 
			
			root@node1:/usr/src/dvs/dvk-proxies/test# nsenter -p -t$DC0 ./loop_copy_client 1 
			DEBUG 6:dvk_open:40: Open dvk device file /dev/dvk
			DEBUG 6:dvk_getdcinfo:163: dcid=0
			DEBUG 6:dvk_getdcinfo:167: ioctl ret=0 errno=0
			 loop_copy_client.c:main:132:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
			 loop_copy_client.c:main:133:flags=0 dc_nodes=3 dc_pid=600 dc_name=DC0
			DEBUG 6:dvk_bind_X:536: cmd=0 dcid=0 pid=6 endpoint=1 nodeid=-1
			DEBUG 6:dvk_bind_X:544: ioctl ret=1 errno=0
			 loop_copy_client.c:main:151:BIND MAIN CLIENT dcid=0 clt_pid=6 CLT_NR=1 clt_ep=1
			DEBUG 6:dvk_bind_X:536: cmd=2 dcid=0 pid=-1080802192 endpoint=0 nodeid=0
			DEBUG 6:dvk_bind_X:544: ioctl ret=0 errno=0
			 loop_copy_client.c:main:162:MAIN CLIENT dvk_rmtbind 0: process server0 on node 0 
			 loop_copy_client.c:main:166:child fork 0
			 loop_copy_client.c:main:171:MAIN CLIENT child_pid[0]=7
			MAIN CLIENT: m_ptr=0x1b88000
			DEBUG 6:dvk_receive_T:362: endpoint=3 timeout=-1
			DEBUG 6:dvk_receive_T:367: ioctl ret=-1 errno=108
			ERROR: 6:dvk_receive_T:368: rcode=-108
			CHILD child_nr=3: child=0
			CHILD child_nr=3: m_ptr=0x1b88000
 loop_copy_client.c:child_function:44:CHILD child_nr=3: buffer before = ABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJKLMNOPQRSTUVWXYABCDEFGHIJ
			DEBUG 7:dvk_bind_X:536: cmd=2 dcid=0 pid=-1080802280 endpoint=2 nodeid=0
			DEBUG 7:dvk_bind_X:544: ioctl ret=2 errno=0
			DEBUG 7:dvk_bind_X:536: cmd=0 dcid=0 pid=7 endpoint=3 nodeid=-1
			DEBUG 7:dvk_bind_X:544: ioctl ret=3 errno=0
			 loop_copy_client.c:child_function:61:CHILD child_nr=3: child_ep=3 child_pid=7
			DEBUG 7:dvk_sendrec_T:379: endpoint=1 timeout=-1
			DEBUG 6:dvk_receive_T:362: endpoint=3 timeout=-1
			DEBUG 6:dvk_receive_T:367: ioctl ret=36 errno=108
			 loop_copy_client.c:main:196:MAIN CLIENT: Sending START message to remote SERVER
			DEBUG 6:dvk_sendrec_T:379: endpoint=0 timeout=-1
			DEBUG 6:dvk_sendrec_T:384: ioctl ret=0 errno=0
			DEBUG 6:dvk_send_T:345: endpoint=3 timeout=-1
			DEBUG 6:dvk_send_T:350: ioctl ret=36 errno=0
			DEBUG 7:dvk_sendrec_T:384: ioctl ret=0 errno=0
			 loop_copy_client.c:child_function:75:CHILD child_nr=3:Sending message to start loop. buffer=B7397000
			DEBUG 7:dvk_sendrec_T:379: endpoint=2 timeout=-1
			DEBUG 6:dvk_receive_T:362: endpoint=3 timeout=-1
			DEBUG 7:dvk_sendrec_T:384: ioctl ret=0 errno=0
 loop_copy_client.c:child_function:82:CHILD child_nr=3: buffer after = abcdefghijklmnopqrstuvwxyabcde
			DEBUG 7:dvk_sendrec_T:379: endpoint=1 timeout=-1
			DEBUG 6:dvk_receive_T:367: ioctl ret=0 errno=0
			 loop_copy_client.c:main:224:MAIN CLIENT: Sending STOP message to remote SERVER
			DEBUG 6:dvk_sendrec_T:379: endpoint=0 timeout=-1
			DEBUG 6:dvk_sendrec_T:384: ioctl ret=0 errno=0
			DEBUG 6:dvk_send_T:345: endpoint=3 timeout=-1
			DEBUG 6:dvk_send_T:350: ioctl ret=36 errno=0
			DEBUG 7:dvk_sendrec_T:384: ioctl ret=0 errno=0
			 loop_copy_client.c:child_function:91:CHILD child_nr=3: unbinding 2
			DEBUG 7:dvk_unbind_T:329: dcid=0 endpoint=2 timeout=-1
			DEBUG 7:dvk_unbind_T:334: ioctl ret=0 errno=0
			 loop_copy_client.c:child_function:93:CHILD child_nr=3:exiting
			DEBUG 6:dvk_unbind_T:329: dcid=0 endpoint=0 timeout=-1
			DEBUG 6:dvk_unbind_T:334: ioctl ret=0 errno=0
			MAIN CLIENT END

			
 ------------------------------------------------------------------------------------
20180918:			
			Se incluyo en stub_dvkcall.h el prototipo de  dvk_getprocinfo
			Luego se modifico test_sendrec.c para que presente la info del proceso 
			
			DEBUG 2:dvk_getprocinfo:517: ioctl ret=0 errno=0
			nr=1 endp=1 dcid=0 flags=0 misc=20 lpid=672 vpid=2 nodeid=0 name=test_sendrec 
			endp=1 dcid=0 flags=0 p_getfrom=27342 p_sendto=27342 p_waitmigr=27342 p_waitunbind=27342 p_proxy=27342
			nr=1 endp=1 dcid=0 p_lclsent=2 p_rmtsent=0 p_lclcopy=0 p_rmtcopy=0 

		Para ingresar en el namespace como usuario "pap" tengo que hacer 
			nsenter -p -t$DC0 -S 1000 <<<<< 1000 es el uid de pap
			luego aparece la shell
			pap@node0:/usr/src/dvs/dvk-tests$ ./test_sendrec 0  1 2
			DEBUG 19:dvk_open:40: Open dvk device file /dev/dvk
			DEBUG 19:dvk_bind_X:536: cmd=0 dcid=0 pid=19 endpoint=1 nodeid=-1
			DEBUG 19:dvk_bind_X:544: ioctl ret=-1 errno=335
			ERROR: 19:dvk_bind_X:551: rcode=-335 <<< EDVSPRIVILEGES
			ERROR: test_sendrec.c:main:35: rcode=-335 <<< EDVSPRIVILEGES
			PARENT BIND dcid=0 parent_pid=19 parent_nr=1 parent_ep=-335 <<< EDVSPRIVILEGES m_ptr=0x17b4008
			PARENT pause before SENDREC
			DEBUG 20:dvk_bind_X:536: cmd=0 dcid=0 pid=20 endpoint=2 nodeid=-1
			DEBUG 20:dvk_bind_X:544: ioctl ret=-1 errno=335
			ERROR: 20:dvk_bind_X:551: rcode=-335 <<< EDVSPRIVILEGES
			ERROR: test_sendrec.c:main:80: rcode=-335 <<< EDVSPRIVILEGES
			CHILD BIND dcid=0 child_pid=20 child_nr=2 child_ep=-335 <<< EDVSPRIVILEGES m_ptr=0x17b4008
			CHILD FIRST RECEIVE
			DEBUG 20:dvk_receive_T:362: endpoint=31438 timeout=-1
			DEBUG 20:dvk_receive_T:367: ioctl ret=-1 errno=310
			ERROR: 20:dvk_receive_T:368: rcode=-310
			ERROR: test_sendrec.c:main:86: rcode=-310
			CHILD RECEIVE msg:source=0 type=0 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			CHILD FIRST SEND
			DEBUG 20:dvk_send_T:345: endpoint=0 timeout=-1
			DEBUG 20:dvk_send_T:350: ioctl ret=-1 errno=310
			ERROR: 20:dvk_send_T:351: rcode=-310
			ERROR: test_sendrec.c:main:92: rcode=-310
			PARENT FIRST SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			DEBUG 19:dvk_sendrec_T:379: endpoint=2 timeout=-1
			DEBUG 19:dvk_sendrec_T:384: ioctl ret=-1 errno=310
			ERROR: 19:dvk_sendrec_T:385: rcode=-310
			ERROR: test_sendrec.c:main:55: rcode=-310
			PARENT FIRST REPLY msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			PARENT SECOND SENDREC msg:source=0 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			DEBUG 19:dvk_sendrec_T:379: endpoint=2 timeout=-1
			DEBUG 19:dvk_sendrec_T:384: ioctl ret=-1 errno=310
			ERROR: 19:dvk_sendrec_T:385: rcode=-310
			ERROR: test_sendrec.c:main:65: rcode=-310
			PARENT SECOND REPLY msg:source=0 type=11 m1i1=5 m1i2=6 m1i3=7 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			CHILD SECOND RECEIVE
			DEBUG 20:dvk_receive_T:362: endpoint=31438 timeout=-1
			DEBUG 20:dvk_receive_T:367: ioctl ret=-1 errno=310
			ERROR: 20:dvk_receive_T:368: rcode=-310
			ERROR: test_sendrec.c:main:98: rcode=-310
			CHILD RECEIVE msg:source=0 type=254 m1i1=0 m1i2=0 m1i3=0 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			CHILD SECOND SEND
			DEBUG 20:dvk_send_T:345: endpoint=0 timeout=-1
			DEBUG 20:dvk_send_T:350: ioctl ret=-1 errno=310
			ERROR: 20:dvk_send_T:351: rcode=-310
			ERROR: test_sendrec.c:main:104: rcode=-310
			DEBUG 19:dvk_getprocinfo:512: dcid=0 p_nr=1 
			DEBUG 19:dvk_getprocinfo:517: ioctl ret=-1 errno=335
			ERROR: 19:dvk_getprocinfo:518: rcode=-335 <<< EDVSPRIVILEGES
			ERROR: test_sendrec.c:main:72: rcode=-335 <<< EDVSPRIVILEGES
			pap@node0:/usr/src/dvs/dvk-tests$ 

		Se modificaron las dvk_calls que requerian privilegios de root por capabitities.
		#ifdef DVS_CAPABILITIES
			 if ( !capable(CAP_DVS_ADMIN)) ERROR_RETURN(EDVSPRIVILEGES);
		#else
			if(get_current_cred()->euid.val != USER_ROOT) ERROR_RETURN(EDVSPRIVILEGES);
		#endif 
			
		Se definieron 2 capabilities identicas a CAP_SYS_ADMIN pero de tal forma que puedan ser modificadas	
		#define CAP_DVS_ADMIN	CAP_SYS_ADMIN // para funciones de dvs, proxies, nodos, etc. 
		#define CAP_VOS_ADMIN	CAP_SYS_ADMIN // para funciones que usan los programas
		
 ------------------------------------------------------------------------------------
20180922:
		SE modifico el hostname del UTS namespace para que sea el nombre del DC 
		
		root@node0:/usr/src/dvs/dvk-tests# ./test_dc_init -d 1
		PARENT dc_dcid=1 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC1
		PARENT dc_dcid=1 dc_warn2proc=27342 dc_warnmsg=0
		DEBUG 660:dvk_open:40: Open dvk device file /dev/dvk
		CHILD  PID=1 PPID=0
		CHILD before dc_dcid=1 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC1
		CHILD before dc_dcid=1 dc_warn2proc=27342 dc_warnmsg=0
		CHILD I am a daemon
		DEBUG 1:dvk_dc_init:80: 
		DEBUG 1:dvk_dc_init:82: ioctl ret=0 errno=0
		DC1 has been initialized on node 0
		DEBUG 1:dvk_getnodeinfo:177: nodeid=0
		DEBUG 1:dvk_getnodeinfo:181: ioctl ret=0 errno=0
		CHILD n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=3 n_name=node0
		DEBUG 1:dvk_getdcinfo:163: dcid=1
		DEBUG 1:dvk_getdcinfo:167: ioctl ret=0 errno=0
		CHILD after  dc_dcid=1 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		CHILD after  flags=0 dc_nodes=1 dc_pid=661 dc_name=DC1
		CHILD after  dc_dcid=1 dc_warn2proc=27342 dc_warnmsg=0
		CHILD Sysname:  Linux
		CHILD Nodename: DC1 			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		CHILD Release:  4.9.88
		CHILD Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
		CHILD Machine:  i686
		PARENT Sysname:  Linux
		PARENT Nodename: node0			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		PARENT Release:  4.9.88
		PARENT Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
		PARENT Machine:  i686
		PARENT link_name:/proc/660/ns/pid file_name=pid:[4026531836]
		CHILD link_name:/proc/661/ns/pid file_name=pid:[4026532557]
		PARENT exiting - child_pid=661
		root@node0:/usr/src/dvs/dvk-tests# . ./DC1.sh 
		root@node0:/usr/src/dvs/dvk-tests# echo $DC1
		661
		root@node0:/usr/src/dvs/dvk-tests# ls -l /proc/661/ns/*
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/cgroup -> cgroup:[4026531835]
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/ipc -> ipc:[4026532556]
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/mnt -> mnt:[4026532554]
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/net -> net:[4026532559]
		lrwxrwxrwx 1 root root 0 sep 22 09:27 /proc/661/ns/pid -> pid:[4026532557]
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/user -> user:[4026531837]
		lrwxrwxrwx 1 root root 0 sep 22 09:29 /proc/661/ns/uts -> uts:[402653255
			
		FUERA DEL DC1 intento como PAP algunos comandos 
			root@node0:/usr/src/dvs/dvk-tests# su pap
			pap@node0:/usr/src/dvs/dvk-tests$ id
			uid=1000(pap) gid=1000(pap) grupos=1000(pap),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev)
			pap@node0:/usr/src/dvs/dvk-tests$ hostname
			node0
			pap@node0:/usr/src/dvs/dvk-tests$ nsenter -p -u -t$DC1 
			senter: no se puede abrir /proc/661/ns/uts: Permiso denegado <<<< NO ME DEJA
			
		ESTO SUCEDE POR 
			Starting in Linux 3.8, unprivileged processes can create user namespaces, << SOLO ADMITE USER NS 
			and mount, PID, IPC, network, and UTS namespaces can be created with just 
			the CAP_SYS_ADMIN capability in the caller's user namespace.		
			
		LUEGO  entro como usuario PAP (1000) al DC1
			root@node0:/usr/src/dvs/dvk-tests# nsenter -p -u -t$DC1 -S 1000 
			-bash: /root/.bash_profile: Permiso denegado <<<< es porque soy root en DC1
			pap@DC1:/usr/src/dvs/dvk-tests$ who am i
			pap@DC1:/usr/src/dvs/dvk-tests$ id
			uid=1000(pap) gid=0(root) grupos=0(root)
			pap@DC1:/usr/src/dvs/dvk-tests$ hostname
			DC1
			pap@DC1:/usr/src/dvs/dvk-tests$ exit
			
ATENCION:	https://www.systutorials.com/docs/linux/man/7-namespaces/
			Bind mounting (see mount(2)) one of the files in this directory (/proc/xxx/ns) 
			to somewhere else in the filesystem keeps the corresponding namespace of the 
			process specified by pid alive even if all processes currently in the namespace 
			terminate.

			Opening one of the files in this directory (or a file that is bind mounted to 
			one of these files) returns a file handle for the corresponding namespace of 
			the process specified by pid. As long as this file descriptor remains open, 
			the namespace will remain alive, even if all processes in the namespace terminate. 
			The file descriptor can be passed to setns(2).

			EN EL ROOT NAMESPACE
			root@node0:/usr/src/dvs/dvk-tests# grep pap /etc/group
			cdrom:x:24:pap
			floppy:x:25:pap
			audio:x:29:pap
			dip:x:30:pap
			video:x:44:pap
			plugdev:x:46:pap
			netdev:x:108:pap
			pap:x:1000:
			root@node0:/usr/src/dvs/dvk-tests# grep pap /etc/passwd
			pap:x:1000:1000:pap,,,:/home/pap:/bin/bash

			PUEDO INGRESAR AL NS DEL DC1 CON USUARIO 1000 
			root@node0:/usr/src/dvs/dvk-tests# nsenter -p -u -t$DC1 -S 1000  -G 1000 -S 1000
			-bash: /root/.bash_profile: Permiso denegado
			pap@DC1:/usr/src/dvs/dvk-tests$ id
			uid=1000(pap) gid=1000(pap) grupos=1000(pap)
			pap@DC1:/usr/src/dvs/dvk-tests$ 

			SE PUEDE SABER SI EL USUARIOS EXISTE EN SHELL
			root@node0:/usr/src/dvs/dvk-tests# id -u pap  <<< USER 
			1000
			root@node0:/usr/src/dvs/dvk-tests# id -g pap  <<< GROUP 
			1000

PARA MONITOREAR CONTAINERS
			https://sysdig.com/
PARA CREAR MINIMAL ROOTS

			Use https://wiki.debian.org/Debootstrap para crear un minimal rootfs 
			Sume un disco de 20 Gb a la VM de NODE0
			con fdisk cree una particion EXTENDIDA de 20GB y dentro de ella 
			3 particiones de 1 Gb cada una para que cada container use una.
			
			root@node0:~# fdisk -l /dev/sdb
			Disco /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectores
			Unidades: sectores de 1 * 512 = 512 bytes
			TamaÃ±o de sector (lÃ³gico/fÃ­sico): 512 bytes / 512 bytes
			TamaÃ±o de E/S (mÃ­nimo/Ã³ptimo): 512 bytes / 512 bytes
			Tipo de etiqueta de disco: dos
			Identificador del disco: 0x79c16f1c

			Disposit.  Inicio Comienzo    Final Sectores TamaÃ±o Id Tipo
			/dev/sdb1             2048 41943039 41940992    20G  5 Extendida
			/dev/sdb5             4096  2101247  2097152     1G 83 Linux
			/dev/sdb6          2103296  4200447  2097152     1G 83 Linux
			/dev/sdb7          4202496  6299647  2097152     1G 83 Linux

			Monte los directorios 
			root@node0:/# mount | grep sdb
			/dev/sdb5 on /usr/src/dvs/rootfs/dvs type ext2 (rw,relatime,block_validity,barrier,user_xattr,acl)
			/dev/sdb6 on /usr/src/dvs/rootfs/DC1 type ext2 (rw,relatime,block_validity,barrier,user_xattr,acl)
			/dev/sdb7 on /usr/src/dvs/rootfs/DC2 type ext2 (rw,relatime,block_validity,barrier,user_xattr,acl)

			Cree un tar del directorio raiz y lo descomprimi en rootfs/DC1 y DC2
			Se requiere copiar en cada el directorio rootfs/dvs todo lo que los programas necesitan.
				drwxr-xr-x  2 root root     4096 sep 14 13:12 dvk-lib
				drwxr-xr-x  2 root root     4096 sep 16 21:28 dvk-loops
				drwxr-xr-x  3 root root     4096 sep 22 12:35 dvk-tests
				drwxr-xr-x  6 root root     4096 jul 12 19:40 include
				drwxrwxr-x  9 root root     4096 ago 10 18:07 lz4-1.8.2
				drwxr-xr-x  3 root root     4096 sep 14 13:13 dvk-proxies
		
			# rsync -av ../dvk-lib/ dvk-lib  <<<< y cada uno de los directorios de arriba.
			
			Luego hice tar de dvs/rootfs/dvs en rootfs 
				tar cvzf dvs.tar.gz ./dvs/
			Luego en cada uno de los rootfs de los DC1 y DC2 hice el detar.
			
			root@node0:/usr/src/dvs/rootfs/DC1/usr/src# tar xvzf ../../../dvs.tar.gz .
			root@node0:/usr/src/dvs/rootfs/DC2/usr/src# tar xvzf ../../../dvs.tar.gz .

			
	BOOTEAR EL DC e intentar ejecutar algo de prueba desde los ejecutables de su propio rootFS
	
		cd /usr/src/dvs/dvk-tests
		./tests.sh 0 0
		. ./DC0.sh
		nsenter -p -u -t$DC0 -S 1000  -G 1000 -S 1000
		root@node0:/usr/src/dvs/dvk-tests#  nsenter -p -u -t$DC1  chroot /usr/src/dvs/rootfs/DC1 bash 
		root@DC1:/# ls /
		DC1ROOT.txt  bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

	COMO EJECUTAR ENTONCES EN UN DC - EN ESTE CASO DC2
	
		root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 2
		lcl_nodeid=0 dcid=2
		Enter para continuar... 
		mknod: /dev/dvk: El fichero ya existe
		insmod: ERROR: could not insert module dvk.ko: File exists
		local_nodeid=0 Enter para continuar... 
		DEBUG 982:dvk_open:40: Open dvk device file /dev/dvk
		Initializing DVS. Local node ID 0... 
		DEBUG 982:dvk_dvs_init:261: nodeid=0
		DEBUG 982:dvk_dvs_init:265: ioctl ret=-1 errno=317
		ERROR: 982:dvk_dvs_init:266: rcode=-317
		ERROR: test_dvs_init.c:main:171: rcode=-317
		d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		d_max_copybuf=65536 d_max_copylen=1048576
		d_dbglvl=FFFFFF version=2.1 sizeof(proc)=0
		DC2 Enter para continuar... 
		PARENT dc_dcid=2 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC2
		PARENT dc_dcid=2 dc_warn2proc=27342 dc_warnmsg=0
		DEBUG 983:dvk_open:40: Open dvk device file /dev/dvk
		
		CHILD chroot to:  ../rootfs/DC2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< SE HACE EL CHROOT ANTES DE CLONE 
		CHILD  PID=1 PPID=0
		CHILD before dc_dcid=2 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC2
		CHILD before dc_dcid=2 dc_warn2proc=27342 dc_warnmsg=0
		CHILD I am a daemon
		DEBUG 1:dvk_dc_init:80: 
		DEBUG 1:dvk_dc_init:82: ioctl ret=0 errno=0
		DC2 has been initialized on node 0
		DEBUG 1:dvk_getnodeinfo:177: nodeid=0
		DEBUG 1:dvk_getnodeinfo:181: ioctl ret=0 errno=0
		CHILD n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=7 n_name=node0
		DEBUG 1:dvk_getdcinfo:163: dcid=2
		DEBUG 1:dvk_getdcinfo:167: ioctl ret=0 errno=0
		CHILD after  dc_dcid=2 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
		CHILD after  flags=0 dc_nodes=1 dc_pid=984 dc_name=DC2
		CHILD after  dc_dcid=2 dc_warn2proc=27342 dc_warnmsg=0
		CHILD Sysname:  Linux
		CHILD Nodename: DC2
		CHILD Release:  4.9.88
		CHILD Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
		CHILD Machine:  i686
		PARENT Sysname:  Linux
		PARENT Nodename: node0
		PARENT Release:  4.9.88
		PARENT Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
		PARENT Machine:  i686
		PARENT link_name:/proc/983/ns/pid file_name=../rootfs/DC2
		CHILD link_name:/proc/984/ns/pid file_name=../rootfs/DC2
		PARENT link_name:/proc/983/ns/uts file_name=../rootfs/DC2
		CHILD link_name:/proc/984/ns/uts file_name=../rootfs/DC2
		PARENT exiting - child_pid=984
		TCP PROXY Enter para continuar... 
		Enter para continuar... 
		ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
		 0     6      -1        0        0 -----------------------------XXX node0           
		 1     2       1        0        0 ------------------------------XX node1           
		Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
			  1     1    833      834           node1 ------------------------------X-
		ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
		 1 send    833      0      1        0        0  27342  27342  27342 tcp_proxy      
		 1 recv    834      0      1        0        0  27342  27342  27342 tcp_proxy      
		ADDNODE Enter para continuar... 
		dcid=2
		flags=0
		nr_procs=221
		nr_tasks=35
		nr_sysprocs=64
		nr_nodes=32
		dc_nodes=1
		dc_pid=984
		warn2proc=27342
		warnmsg=0
		dc_name=DC2
		nodes 33222222222211111111110000000000
			  10987654321098765432109876543210
			  -------------------------------X
		cpumask=1 
		DEBUG 995:dvk_open:40: Open dvk device file /dev/dvk
		Adding node 1 to DC 2... 
		DEBUG 995:dvk_add_node:233: dcid=2 nodeid=1
		DEBUG 995:dvk_add_node:237: ioctl ret=0 errno=0
		ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
		 0     6      -1        0        0 -----------------------------XXX node0           
		 1     2       1        0        0 -----------------------------XXX node1           
		dcid=2
		flags=0
		nr_procs=221
		nr_tasks=35
		nr_sysprocs=64
		nr_nodes=32
		dc_nodes=3
		dc_pid=984
		warn2proc=27342
		warnmsg=0
		dc_name=DC2
		nodes 33222222222211111111110000000000
			  10987654321098765432109876543210
			  ------------------------------XX
		cpumask=1 
		
	SE SETEA LA VARIABLE DE ENTORNO $DC2 
		root@node0:/usr/src/dvs/dvk-tests# . ./DC2.sh 
	SE EJECUTA LA SHELL PREVIO CHROOT 
		root@node0:/usr/src/dvs/dvk-tests#  nsenter -p -u -t$DC2  chroot /usr/src/dvs/rootfs/DC2 bash
	YA ESTO DENDRO DEL DC2 EN SU PROPIO ROOTFS
		root@DC2:/# cd /usr/src/dvs/dvk-tests/
	ATENCION!! Tengo que crear el dispositivo! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
		root@DC2:/usr/src/dvs/dvk-tests# mknod /dev/dvk c 33 0
	EJECUTO UN PROGRAMA DE M3-IPC
		root@DC2:/usr/src/dvs/dvk-tests# ./test_bind 2 9
		DEBUG 17:dvk_open:40: Open dvk device file /dev/dvk
		PARENT dvk_bind Binding process 17 to DC2 with p_nr=9
		DEBUG 17:dvk_bind_X:536: cmd=0 dcid=2 pid=17 endpoint=9 nodeid=-1
		DEBUG 17:dvk_bind_X:544: ioctl ret=9 errno=0
		DEBUG 17:dvk_getep:102: pid=17
		DEBUG 17:dvk_getep:104: ioctl ret=9 errno=0
		PARENT ep=9 dvk_getep=9
		PARENT dvk_lclbind 18 to DC2 with p_nr+index=10
		DEBUG 17:dvk_bind_X:536: cmd=1 dcid=2 pid=18 endpoint=10 nodeid=-1
		DEBUG 17:dvk_bind_X:544: ioctl ret=10 errno=0
		DEBUG 17:dvk_getep:102: pid=18
		DEBUG 17:dvk_getep:104: ioctl ret=10 errno=0
		PARENT ep=10 dvk_getep=10
		PARENT waiting child index=2
		CHILD[2] dvk_replbind Binding process 19 to DC2 with p_nr=11
		CHILD[1] dvk_lclbind
		DEBUG 19:dvk_bind_X:536: cmd=4 dcid=2 pid=19 endpoint=11 nodeid=-1
		DEBUG 19:dvk_bind_X:544: ioctl ret=11 errno=0
		DEBUG 19:dvk_getep:102: pid=19
		DEBUG 19:dvk_getep:104: ioctl ret=11 errno=0
		CHILD[2] ep=11 dvk_getep=11
		DEBUG 18:dvk_getep:102: pid=18
		DEBUG 18:dvk_getep:104: ioctl ret=10 errno=0
		CHILD[1] dvk_getep=10
		CHILD[2] exit
		PARENT waiting child index=1
		CHILD[1] exit
		root@DC2:/usr/src/dvs/dvk-tests# 

 ------------------------------------------------------------------------------------
20180923:
		Migre:
			SYSTASK
			LIB/TIMERS
			LIB/SYSLIB
			LIB/MOLLIB
			LIB/CONFIG
			PM
			IS
			RS
			
			LA ESTRUCTURA DE DIRCTORIOS ES 
			dvs		
			├── chardev-ioctl
			├── dvk-lib
			├── dvk-loops
			├── dvk-mod
			├── dvk-proxies
			│   └── test
			├── dvk-tests
			├── dvs-apps
			│   └── dvsd
			├── include     <<<<<<<<<<<<<<<<<< COMPARTIDO POR TODOS 
			│   ├── com
			│   ├── dvk
			│   ├── dvs
			│   └── generic
			├── lkm_example
			├── lz4-1.8.2
			├── reljmp-master
			├── spread-src-5.0.1
			└── vos
				├── lwuk			<<<<< LWIP UNIKERNEL 
				├── mol				<<<<< MOL 
				│   ├── include     <<<<<  SOLO INCLUDES DE MOL 
				│   ├── lib
				│   │   ├── config
				│   │   ├── ip
				│   │   ├── mollib
				│   │   ├── syslib
				│   │   └── timers
				│   ├── servers
				│   │   ├── pm
				│   │   ├── is
				│   │   ├── fs
				│   │   └── rs
				│   └── tasks
				│       └── systask
				└── rootfs			<<<< AQUI VAN TODOS LOS FS DE LOS CONTAINERS 
					├── DC0         
					├── DC1
					└── dvs	        <<<< PARA MONTAR , COPIA NO ACTUALIZADA DEL DVS 

		
	FALTA PROBAR SYSTASK EN EL DC
		
		cd /usr/src/dvs/dvk-tests
		./tests.sh 0 0
		. ./DC0.sh
		
		nsenter -p -u -t$DC0 
		
	CONSIDERACIONES PARA ARRANCAR SPREAD.	
		1) mencionar el archivo de configuracion
			/usr/local/sbin/spread -c /etc/spread.conf > spread.txt &
		2) dar de alta usuario spread y grupo spread
			useradd spread
			groupadd spread
		3) se requiere para hacer chroot 
			mkdir /var/run/spread
	
------------------------------------------------------------------------------------
20180924/25:
		Se  migro RDISK pero integrandolo con LIBDRIVER.
		Se  migro de M3NWEB y M3FTP
		Se  migro de MSGQ a TCP al DVSD que se incluyo dentro de dvk-apps
		
		Arquitectura DVSD:
			DVSCMD <--tcp--> DVSD <--spread--> CLUSTER DE NODOS
		Ejemplo: DVSINIT
			NODEx				NODEy					NODEz
			=====				=====					=====
			DVSCMD----tcp----> 	DVSD(dvsd) 
								DVSD(gcsd) --->spread-->DVSD(gcsd)
														dvk_dvsinit()
								DVSD(gcsd) <---spread---DVSINIT_ACK
			DVSCMD <---tcp ---	DVSD(dvsd)	


------------------------------------------------------------------------------------
20180926:
		Se trabajo en DVSD para soportar los comandos 
				DVSINIT	 
				DVSEND	 
				DVSINFO	 
				DCINFO	 
				NODEINFO 
				PROXYINFO
			    PROCINFO 
		
	Se probo la ejecucion de comando remoto
	Se hizo la siguiente shell en NODE1
	root@node1:/home# cat node1.sh
		#!/bin/bash
		echo This is node1.sh to be executed in node0
		cat /proc/cpuinfo
		echo Esto deberia almacenarse en node0 > /tmp/node0.txt
		echo good bye!
		exit 0

	Toda la STDOUT salio como era de esperarse en NODE1
	Pero el archivo /tmp/node0.txt se creo en NODE0 
	
			
---------------------------------------------------------------------------------
20180927/28:

		Modifique  GCSD para contemplar las funciones 
				DVSINIT	 
				DVSEND	 
				DVSINFO	 
				DCINFO	 
				NODEINFO 
				PROXYINFO
			    PROCINFO 
		
		root@node0:/usr/src/dvs/dvs-apps/dvsd# ./dvscmd 0 DVSINFO
		 dvscmd.c:main:787:cmd_nodeid=0 cmd_ptr=>DVSINFO<
		 dvscmd.c:main:791:cmd_str[1]=>DVSINIT< cmd_ptr=>DVSINFO<
		 dvscmd.c:main:791:cmd_str[2]=>DVSEND< cmd_ptr=>DVSINFO<
		 dvscmd.c:main:791:cmd_str[3]=>DVSINFO< cmd_ptr=>DVSINFO<
		 dvscmd.c:main:803:cmd_ptr=DVSINFO cmd_argc=1 cmd_nr=3
		 dvscmd.c:main:805:      cmd_arg[0]=DVSINFO
		 dvscmd.c:tcp_connect:701:DVSCMD: connect to DVSD server running at TCP port=7000
		 dvscmd.c:tcp_connect:712:DVSCMD: remote host address 0: 127.0.0.1
		 dvscmd.c:tcp_connect:712:DVSCMD: remote host address 1: 127.0.0.1
		 dvscmd.c:tcp_connect:719:DVSCMD: running at  IP=127.0.0.1
		 dvscmd.c:dvscmd_init:741:dvscmd_pid=637
		 dvscmd.c:dvscmd_init:743:Initialize the call vector to a safe default handler.
		 dvscmd.c:dvscmd_init:745:Initilizing vector 0 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 1 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 2 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 3 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 4 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 5 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 6 on address=0x41b5da
		 dvscmd.c:dvscmd_init:745:Initilizing vector 7 on address=0x41b5da
		 dvscmd.c:dvscmd_init:750:Initilizing vector 1 on address=0x41b633
		 dvscmd.c:dvscmd_init:752:Initilizing vector 2 on address=0x41bf46
		 dvscmd.c:dvscmd_init:755:Initilizing vector 3 on address=0x41c398
		 dvscmd.c:dvscmd_init:757:Initilizing vector 4 on address=0x41c954
		 dvscmd.c:dvscmd_init:759:Initilizing vector 5 on address=0x41cf7c
		 dvscmd.c:dvscmd_init:761:Initilizing vector 6 on address=0x41d57b
		 dvscmd.c:dvscmd_init:763:Initilizing vector 7 on address=0x41dd1b
		 dvscmd.c:cmd_dvsinfo:301:DVSINFO REQUEST dvscmd_ptr:dvs_cmd=0x3 dvs_snode=-1 dvs_dnode=0 dvs_rcode=0 dvs_lines=0 dvs_paylen=0 dvs_bmnodes=0x0  
		 dvscmd.c:cmd_dvsinfo:307:DVSINFO REQUEST: bytes=28 <<<<<<<<< ESTE ES EL RESULTADO DEL SENT !!! OK 
		ERROR: dvscmd.c:cmd_dvsinfo:311: rcode=111 <<<<<<<<<<<<<<<<<< ESTE ES EL DEL RECEIVE 
		 dvscmd.c:cmd_dvsinfo:313:DVSINFO REPLY: bytes=-1
		 dvscmd.c:cmd_dvsinfo:316:DVSINFO REPLY cmd_ptr:dvs_cmd=0x3 dvs_snode=-1 dvs_dnode=0 dvs_rcode=0 dvs_lines=0 dvs_paylen=0 dvs_bmnodes=0x0  
		ERROR: dvscmd.c:cmd_dvsinfo:318: rcode=-339
		ERROR: dvscmd.c:main:818: rcode=-339

		
	Hice un telnet al dvsd y da violacion de segmento
	root@node0:/usr/src/dvs/dvs-apps/dvsd# ./dvsd 0
		 dvsd.c:main:159:DVSD: local_nodeid=0
		 dvsd.c:dvsd_init:107:dvsd_pid=616
		 dvsd.c:dvsd_init:109:Initialize the call vector to a safe default handler.
		 dvsd.c:dvsd_init:111:Initilizing vector 0 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 1 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 2 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 3 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 4 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 5 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 6 on address=0x4ecf56
		 dvsd.c:dvsd_init:111:Initilizing vector 7 on address=0x4ecf56
		 dvsd.c:dvsd_init:118:Initializing GCS
		 gcsd.c:init_gcs:317:group name=DVS
		 gcsd.c:init_gcs:318:user  name=DVS.0
		 gcsd.c:init_gcs:328:Spread library version is 5.0.1
		 gcsd.c:init_gcs:345:User node.0: connected to 4803 with private group #node.0#localhost <<<<<<<<<<<<<<<<
		 dvsd.c:dvsd_init:121:Starting GCS thread
		 gcsd.c:gcs_loop:516:sender=DVS Private_group=#node.0#localhost service_type=4352 SP_bytes=56 
		 gcsd.c:gcs_loop:627:Received REGULAR membership for group DVS with 1 members, where I am member 0:
		 gcsd.c:get_nodeid:37:mbr_string: #node.0#localhost
		 gcsd.c:get_nodeid:55:member= nodeid=0
		 gcsd.c:gcs_loop:636:   :0<<<<<<<<<<<<<<<<<< 
		 gcsd.c:gcs_loop:641:num_groups=1 OLD bm_init=0 NEW bm_init=1
		 gcsd.c:gcs_loop:649:Due to the JOIN of #node.0#localhost
		 gcsd.c:get_nodeid:37:mbr_string: #node.0#localhost
		 gcsd.c:get_nodeid:55:member= nodeid=0
		 gcsd.c:sp_join:371:FSM_state=0 new_member=0 init_nodes=1 bm_init=1
		 gcsd.c:sp_join:383:Wake up dvsd: new_mbr=0
		 dvsd.c:dvsd_init:127:DVSD has been signaled by the GCS thread  FSM_state=1
		 dvsd.c:tcp_connect:72:DVSD: running at port=7000
		 dvsd.c:tcp_connect:88:DVSD: is bound to port=7000 socket=4
		 dvsd.c:main:182:DVSD: Waiting for connection.
		 dvsd.c:main:188:DVSD: Remote sender [127.0.0.1] connected on dvscmd_sd [5]. Getting remote command.
		 dvsd.c:main:190:DVSD is waiting for requests
		 dvsd.c:main:192:DVSD recv bytes=0 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
		 dvsd.c:main:206:DVSD REQUEST incmd_ptr:dvs_cmd=0x0 dvs_snode=0 dvs_dnode=0 dvs_rcode=0 dvs_lines=0 dvs_paylen=0 dvs_bmnodes=0x0  
		 dvsd.c:main:208:DVSD cmd_nr=0
		ERROR: dvsd.c:main:210: rcode=-107
		 dvsd.c:main:232:REPLY outcmd_ptr:dvs_cmd=0x0 dvs_snode=0 dvs_dnode=0 dvs_rcode=0 dvs_lines=0 dvs_paylen=0 dvs_bmnodes=0x0  
		ViolaciÃ³n de segmento

---------------------------------------------------------------------------------
20181003/04:
		Se hizo un programa de prueba CLIENT que era equivalente a GETDVSINFO al DVSD
		Funciono OK.
		Habia 2 problemas GROSSOS 
		1- Usaba las structuras parm_XXXX pero estas tenian punteros a las estructura en lugar de las estructuras completas.
		2- En sockfd = socket(AF_INET, SOCK_STREAM, 0)) <<< decia SOCK_DGRAM !!!!!! 
		
		
	NODE0:
		nsenter -p -u -t$DC0 ./loop_r-s_server <children> <loops> 
root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_r-s_server 1 10
DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 2:dvk_getdcinfo:163: dcid=0
DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
 loop_r-s_server.c:main:118:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
 loop_r-s_server.c:main:119:flags=0 dc_nodes=3 dc_pid=660 dc_name=DC0
 loop_r-s_server.c:main:140:MAIN SERVER m_ptr=0x1058000
DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=2 endpoint=0 nodeid=-1
DEBUG 2:dvk_bind_X:544: ioctl ret=0 errno=0
 loop_r-s_server.c:main:149:BIND MAIN SERVER dcid=0 svr_pid=2 SVR_NR=0 svr_ep=0
DEBUG 2:dvk_bind_X:536: cmd=2 dcid=0 pid=-1082065132 endpoint=1 nodeid=1
DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0
 loop_r-s_server.c:main:160:MAIN SERVER dvk_rmtbind 1: process client1 on node 1 
 loop_r-s_server.c:main:164:child fork 0
 loop_r-s_server.c:main:169:MAIN SERVER child_pid[0]=3
 loop_r-s_server.c:main:173:MAIN SERVER: START synchronization from 1 children: REQUEST
DEBUG 2:dvk_receive_T:362: endpoint=2 timeout=-1
DEBUG 2:dvk_receive_T:367: ioctl ret=-1 errno=108
ERROR: 2:dvk_receive_T:368: rcode=-108
 loop_r-s_server.c:child_function:19:child 0: loops=10 child_nr=2
DEBUG 3:dvk_bind_X:536: cmd=0 dcid=0 pid=3 endpoint=2 nodeid=-1
DEBUG 3:dvk_bind_X:544: ioctl ret=2 errno=0
 loop_r-s_server.c:child_function:25:CHILD child=0 child_nr=2 child_ep=2 child_pid=3
DEBUG 3:dvk_bind_X:536: cmd=2 dcid=0 pid=-1082065240 endpoint=3 nodeid=1
DEBUG 3:dvk_bind_X:544: ioctl ret=3 errno=0
DEBUG 3:dvk_sendrec_T:379: endpoint=0 timeout=-1
DEBUG 2:dvk_receive_T:362: endpoint=2 timeout=-1
DEBUG 2:dvk_receive_T:367: ioctl ret=76 errno=108
 loop_r-s_server.c:main:186:MAIN SERVER: START synchronization from 1 children: REPLY 
DEBUG 2:dvk_send_T:345: endpoint=2 timeout=-1
DEBUG 2:dvk_send_T:350: ioctl ret=76 errno=0
 loop_r-s_server.c:main:197:MAIN SERVER: Waiting START message from remote CLIENT
DEBUG 2:dvk_receive_T:362: endpoint=31438 timeout=-1
DEBUG 3:dvk_sendrec_T:384: ioctl ret=0 errno=0
 loop_r-s_server.c:child_function:48:CHILD 0: Starting loop
DEBUG 3:dvk_receive_T:362: endpoint=3 timeout=-1
DEBUG 3:dvk_receive_T:367: ioctl ret=-1 errno=64
ERROR: 3:dvk_receive_T:368: rcode=-64
CHILD 0: dvk_receive ret=-64
ERROR: loop_r-s_server.c:child_function:53: rcode=-64
DEBUG 2:dvk_receive_T:367: ioctl ret=0 errno=0
DEBUG 2:dvk_send_T:345: endpoint=1 timeout=-1
DEBUG 2:dvk_send_T:350: ioctl ret=0 errno=0
 loop_r-s_server.c:main:207:MAIN SERVER: Waiting STOP message from remote MAIN CLIENT
DEBUG 2:dvk_receive_T:362: endpoint=1 timeout=-1

		
	NODE1:
		nsenter -p -u -t$DC0 ./loop_sr_client <children> <loops> 
root@node1:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_sr_client 1 10
DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 2:dvk_getdcinfo:163: dcid=0
DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
 loop_sr_client.c:main:110:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
 loop_sr_client.c:main:111:flags=0 dc_nodes=3 dc_pid=634 dc_name=DC0
MAIN CLIENT m_ptr=0x1cce000
DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=2 endpoint=1 nodeid=-1
DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0
BIND MAIN CLIENT dcid=0 clt_pid=2 CLT_NR=1 clt_ep=1
child fork 0
MAIN CLIENT child_pid[0]=3
MAIN CLIENT: START 1 children synchronization: REQUEST
DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1
DEBUG 2:dvk_receive_T:367: ioctl ret=-1 errno=108
ERROR: 2:dvk_receive_T:368: rcode=-108
child 0: loops=10 child_nr=3
DEBUG 3:dvk_bind_X:536: cmd=2 dcid=0 pid=-1074018776 endpoint=2 nodeid=0
DEBUG 3:dvk_bind_X:544: ioctl ret=2 errno=0
DEBUG 3:dvk_bind_X:536: cmd=0 dcid=0 pid=3 endpoint=3 nodeid=-1
DEBUG 3:dvk_bind_X:544: ioctl ret=3 errno=0
CHILD child=0 child_nr=3 child_ep=3 child_pid=3
DEBUG 3:dvk_sendrec_T:379: endpoint=1 timeout=-1
DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1
DEBUG 2:dvk_receive_T:367: ioctl ret=76 errno=108
DEBUG 2:dvk_bind_X:536: cmd=2 dcid=0 pid=-1074018672 endpoint=0 nodeid=0
DEBUG 2:dvk_bind_X:544: ioctl ret=0 errno=0
MAIN CLIENT dvk_rmtbind 0: process server0 on node 0 
MAIN CLIENT: Sending START message to remote SERVER
DEBUG 2:dvk_sendrec_T:379: endpoint=0 timeout=-1
DEBUG 2:dvk_sendrec_T:384: ioctl ret=0 errno=0
MAIN CLIENT: START 1 children synchronization: REPLY 
DEBUG 2:dvk_send_T:345: endpoint=3 timeout=-1
DEBUG 2:dvk_send_T:350: ioctl ret=76 errno=0
DEBUG 3:dvk_sendrec_T:384: ioctl ret=0 errno=0
CHILD 0: Starting loop
DEBUG 3:dvk_sendrec_T:379: endpoint=2 timeout=-1
MAIN CLIENT: STOP 1 children synchronization: REQUEST
DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1


OJO:  MODIFIQUE DVK-LIB para mantener en 0 a errno si no hay error y ahora al ejecutar el programa

root@node0:/usr/src/dvs/dvk-proxies/test# 

DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 2:dvk_getdcinfo:163: dcid=0
DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
 loop_r-s_server.c:main:118:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
 loop_r-s_server.c:main:119:flags=0 dc_nodes=3 dc_pid=686 dc_name=DC0
 loop_r-s_server.c:main:140:MAIN SERVER m_ptr=0xb01000
DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=0 nodeid=-1
DEBUG 2:dvk_bind_X:544: ioctl ret=0 errno=0  <<<<<<<<<<<<<<<< SE COLGABA AQUI
 loop_r-s_server.c:main:149:BIND MAIN SERVER dcid=0 svr_pid=2 SVR_NR=0 svr_ep=0
DEBUG 2:dvk_bind_X:536: cmd=2 dcid=0 pid=-1075401116 endpoint=1 nodeid=1    
DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0 <<<<<<<<<<<<<<<< SE CUELGA AQUI 
	
	
root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -t$DC0 ./loop_r-s_server 1 10

DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 2:dvk_getdcinfo:163: dcid=0
DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
 loop_r-s_server.c:main:118:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=35 dc_nr_sysprocs=64 dc_nr_nodes=32
 loop_r-s_server.c:main:119:flags=0 dc_nodes=3 dc_pid=566 dc_name=DC0
 loop_r-s_server.c:main:140:MAIN SERVER m_ptr=0xabc000  <<<<<<<<<<<<<<<< SE CUELGA AQUI

 
---------------------------------------------------------------------------------
20181005: 
	Funciono DVSD completo.
	
	Problema en el dvk_bind();
	
	
---------------------------------------------------------------------------------
20181006/07:
		El problema era que cuando era SELFBIND hacia un 
			UNLOCK_TASK_LIST
		pero no lo habia lockeado antes

		SE HIZO LA  PRUEBA multiple peer remoto con proxy TCP normal.
		
		t_start=1538918306.48 t_stop=1538918321.09 t_total=14.61
		Children = 5
		Loops = 100
		Total msg transfers = 500
		Time for a pair of SENDREC/RECEIVE-SEND= 29.216084[ms]
		Throuhput = 34.227722 [SENDREC/RECEIVE-SEND/s]

---------------------------------------------------------------------------------
20181012: 
		
	Se probo proxy con BATCH DE MENSAJES
		NODO0:
		root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_r-s_server 4 100

		NODO1:
		root@node1:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_sr_client 4 100

	    En NODO0:
			t_start=1539426376.54 t_stop=1539426393.16 t_total=16.62
			Children = 4
			Loops = 100
			Total msg transfers = 400
			Time for a pair of SENDREC/RECEIVE-SEND= 41.555027[ms]
			Throuhput = 24.064477 [SENDREC/RECEIVE-SEND/s]
			
			En SPROXY NODE0 
			 tcp_proxy_bat.c:ps_start_serving:473:SPROXY: new BATCHED COMMAND batch_nr=3 <<<< 1 + 3 BATCHED 
			En RPROXY NODE0
			 tcp_proxy_bat.c:pr_process_message:181:RPROXY: batch_nr=7
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[0]:cmd=0x2001 dcid=0 src=9 dst=8 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=0 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[1]:cmd=0x2001 dcid=0 src=5 dst=4 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=0 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[2]:cmd=0x2001 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=0 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[3]:cmd=0x3 dcid=0 src=7 dst=6 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=76 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[4]:cmd=0x3 dcid=0 src=9 dst=8 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=76 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[5]:cmd=0x3 dcid=0 src=5 dst=4 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=76 errno=0
			 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[6]:cmd=0x3 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
			DEBUG 646:dvk_put2lcl:219: 
			DEBUG 646:dvk_put2lcl:223: ioctl ret=76 errno=0

		EN NODE1:
			En SPROXY NODE1
				tcp_proxy_bat.c:ps_start_serving:473:SPROXY: new BATCHED COMMAND batch_nr=7
			En RPROXY NODE1
				 tcp_proxy_bat.c:pr_process_message:181:RPROXY: batch_nr=3
				 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[0]:cmd=0x1 dcid=0 src=8 dst=9 snode=0 dnode=1 rcode=0 len=0
				DEBUG 666:dvk_put2lcl:219: 
				DEBUG 666:dvk_put2lcl:223: ioctl ret=76 errno=0
				 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[1]:cmd=0x1 dcid=0 src=4 dst=5 snode=0 dnode=1 rcode=0 len=0
				DEBUG 666:dvk_put2lcl:219: 
				DEBUG 666:dvk_put2lcl:223: ioctl ret=76 errno=0
				 tcp_proxy_bat.c:pr_process_message:191:RPROXY: bat_cmd[2]:cmd=0x1 dcid=0 src=2 dst=3 snode=0 dnode=1 rcode=0 len=0
				DEBUG 666:dvk_put2lcl:219: 
				DEBUG 666:dvk_put2lcl:223: ioctl ret=76 errno=0
				
PROBAR:		
			SYSTASK
			cd /usr/src/dvs/vos/mol/tasks/systask
				root@node0:/usr/src/dvs/vos/mol/tasks/systask# nsenter -p -u -t$DC0 ./systask
				DEBUG 23:dvk_open:40: Open dvk device file /dev/dvk
				DEBUG 23:dvk_getdvsinfo:113: 
				DEBUG 23:dvk_getdvsinfo:115: ioctl ret=0
				 system.c:main:51:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
				 system.c:main:53:local_nodeid=0
				DEBUG 23:dvk_getdcinfo:163: dcid=0
				DEBUG 23:dvk_getdcinfo:167: ioctl ret=0 errno=0
				DEBUG 23:dvk_getnodeinfo:177: nodeid=0
				DEBUG 23:dvk_getnodeinfo:181: ioctl ret=0 errno=0
				 system.c:init_systask:226:Binding to DC 0 with sys_nr=-2 sys_pid=23
				DEBUG 23:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=-2 nodeid=-1
				DEBUG 23:dvk_bind_X:544: ioctl ret=-1 errno=2
				ERROR: 23:dvk_bind_X:551: rcode=-2
				 system.c:init_systask:229:has binded with p_endpoint=-2 
				 system.c:init_systask:242:Initialize the call vector to a safe default handler.
				 system.c:init_systask:316:Map kernel process table on /sys/kernel/debug/dvs/DC0/procs
				 system.c:init_systask:322:open debug_fd=4
				 system.c:init_systask:327:mmap 19
				mmap 19
				ERROR: system.c:init_systask:329: rcode=-19 <<<< EDVSNODEV        (_SIGN 19)  /* no such device */

			  !!! ENODEV The underlying filesystem of the specified file does not support memory mapping.!!!
			
			root@node0:/usr/src/linux# grep CONFIG_DEBUG_FS  /boot/config-4.9.88
				CONFIG_DEBUG_FS=y
			
---------------------------------------------------------------------------------
20181013:
			El problema era con debugfs al crearlo cambio la posibilidad de mmap.
			hay que reemplazar debugfs_create_file() x debugfs_create_file_unsafe() <<<<<<<<<<
			
		root@node0:~# cat /proc/dvs/DC0/procs 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   590/11     0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   589/10     0    8   20 31438 27342 27342 27342 systask   

			 
		EJECUTAR minix.sh asi
			# . ./minix.sh  
			DETENER en SYSTASK 
			
		root@node0:/usr/src/dvs/dvk-tests# cd ../vos/mol/tasks/systask/
		root@node0:/usr/src/dvs/vos/mol/tasks/systask# nohup nsenter -p -u -t$DC0 ./systask -d 0  > st_out$lcl.txt 2> st_err$lcl.txt &
		[3] 575
		root@node0:/usr/src/dvs/vos/mol/tasks/systask# cat /proc/dvs/DC0/procs 
		DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
		 0 -34   -34   577/3      0    0   80 27342 27342 27342 27342 systask        
		 0  -2    -2   576/2      0    8   20 31438 27342 27342 27342 systask        
		root@node0:/usr/src/dvs/vos/mol/tasks/systask# ps -efL | grep systask <<<<<<<<<<<<<<<<<<<<<<<<< -L lista THREADS -NLWP
		UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
		root       575   532   575  0    1 19:34 pts/0    00:00:00 nsenter -p -u -t555 ./systask -d 0
		root       576   575   576  0    2 19:34 pts/0    00:00:00 ./systask -d 0
		root       576   575   577  0    2 19:34 pts/0    00:00:00 ./systask -d 0
		root       594   532   594  0    1 19:35 pts/0    00:00:00 grep systask
	
			 
	PROBLEMAS A RESOLVER:
			1) Ver si arrancando . ./minix.sh resuelve el problema de DC0
			2) Como arrancar nsenter en background 
			
---------------------------------------------------------------------------------
20181014:			

	RESOLUCION:
			Hacer una shell st.sh 		
				#!/bin/bash
				cd /usr/src/dvs/vos/mol/tasks/systask
				nohup ./systask -d 0  > st_out0.txt 2> st_err0.txt & 
				exit 0

			luego se arranca 
				cd /usr/src/dvs/vos/mol/tasks/systask
				nsenter -p -u -F -t$DC0 ./st.sh

			En ps -efL 
				root       559     1   559  0    2 18:34 pts/0    00:00:00 ./systask -d 0
				root       559     1   561  0    2 18:34 pts/0    00:00:00 ./systask -d 0
				root       564     1   564  0    1 18:34 pts/0    00:00:00 ./pm 0
				root       568     1   568  0    1 18:34 pts/0    00:00:00 ./rs 0


				root@node0:/usr/src/dvs/vos/mol/tasks/systask# cat /proc/dvs/DC0/procs 
				DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
				 0 -34   -34   561/5      0    0   80 27342 27342 27342 27342 systask        
				 0  -2    -2   559/4      0    8   20 31438 27342 27342 27342 systask        
				 0   0     0   564/7      0    8   A0 31438 27342 27342 27342 pm             
				 0   2     2   568/10     0    0   20 27342 27342 27342 27342 cmdline       
			 

PARA EJECUTAR:
			root@node0:~# cd /usr/src/dvs/dvk-tests/
			root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 0
			root@node0:/usr/src/dvs/dvk-tests# . ./DC0.sh
			root@node0:/usr/src/dvs/dvk-tests# cd /usr/src/dvs/vos/mol
			root@node0:/usr/src/dvs/vos/mol# nsenter -p -u -F -t$DC0 ./minix.sh 0	
		
			root@node0:/usr/src/dvs/vos/mol# ps -efL
			root       630     1   630  0    2 20:16 pts/0    00:00:00 ./systask -d 0
			root       630     1   631  0    2 20:16 pts/0    00:00:00 ./systask -d 0
			root       635     1   635  0    1 20:16 pts/0    00:00:00 ./pm 0
			root       639     1   639  0    1 20:16 pts/0    00:00:00 ./rs 0
			root       645   608   645  0    1 20:16 ?        00:00:00 /usr/src/dvs/vos/mol/servers/fs/fs /usr/src/

			root@node0:/usr/src/dvs/vos/mol/servers/rs# cat /proc/dvs/DC0/procs
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   631/5      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   630/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   635/7      0    8   A0 31438 27342 27342 27342 pm             
			 0   1     1   645/16     0    8   20 31438 27342 27342 27342 fs             
			 0   2     2   639/10     0    0   20 27342 27342 27342 27342 cmdline 
 
 
		
			nsenter -p -u -F -t$DC0 ./demonize -l node0 0 0 1 0 "/usr/src/dvs/vos/mol/servers/fs/fs /usr/src/dvs/vos/mol/servers/fs/molfs_DC0.cfg" > fs0.txt 2> fserr0.txt &

		
EL DEMONIZE --UDP--> RS 
19:27:15.410758 IP node0.55203 > node0.cisco-sccp: UDP, length 161
E.....@.@..6...d...d................................P......................................................./usr/src/dvs/vos/mol/servers/fs/fs /usr/src/dvs/vos/mol/servers/fs/molfs_DC0.cfg.
EL RS ---UDP---> DEMONIZE 
19:27:15.413507 IP node0.cisco-sccp > node0.55203: UDP, length 161
E.....@.@..5...d...d........D................................................................................................................................................................

		
En DEMONIZE TODO ESTA BIEN
 demonize.c:main:277:arg_len=80
 demonize.c:main:278:arg_v= >/usr/src/dvs/vos/mol/servers/fs/fs /usr/src/dvs/vos/mol/servers/fs/molfs_DC0.cfg<
En RS ESTA MAL
 rs.c:deamonize:245:deamon_nodeid=0 deamon_type=1 deamon_ep=1
 rs.c:deamonize:247:nodeid=0 mnxpid=01
 rs.c:deamonize:248:arg_v= arg_len=80 <<<<< ARGV VACIO!!
 rs.c:deamonize:257:deamon_ep=1
 rs.c:deamonize:264:deamon_nodeid=0
 rs.c:deamonize:276:mnxpid=0

 rs.c:deamonize:347:CHILD: arg_len=80/0 execvpe >< 
 rs.c:deamonize:353:CHILD: arg_v[0]=(null)
		
---------------------------------------------------------------------------------
20181015:		
			Se probo m3ftpd/m3ftp incluyendolo en minix.sh 
			root       700     1   700  0    2 10:26 pts/0    00:00:00 ./systask -d 0
			root       700     1   701  0    2 10:26 pts/0    00:00:00 ./systask -d 0
			root       705     1   705  0    1 10:26 pts/0    00:00:00 ./pm 0
			root       709     1   709  0    1 10:26 pts/0    00:00:00 ./rs 0
			root       717   677   717  0    1 10:26 ?        00:00:00 /usr/src/dvs/vos/mol/servers/fs/fs /tmp/molfs0.c
			root       727   677   727  0    1 10:26 ?        00:00:00 /usr/src/dvs/vos/mol/servers/m3ftp m3ftpd /usr/s
			root       803   677   803  0    1 10:38 ?        00:00:00 [m3ftp] <defunct>
	
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   701/5      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   700/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   705/7      0    8   A0 31438 27342 27342 27342 pm             
			 0   1     1   717/17     0    8   20 31438 27342 27342 27342 fs             
			 0   2     2   709/10     0    0   20 27342 27342 27342 27342 cmdline    << RS ¿¿ PORQUE SALE ASI
			 0  20    20   727/25     0    8   20 31438 27342 27342 27342 m3ftpd  
		
		
			COMANDO EJECUTADO: /usr/src/dvs/vos/mol/servers/m3ftp/m3ftp -g 20 file10M.txt /tmp/file10M.txt
			RESULTADO:
			root@node0:/usr/src/dvs/vos/mol/commands/demonize# ls -l /tmp
			total 12
			-rw-r----- 1 root root    0 oct 15 10:38 file10M.txt

			
			Se probo m3nweb y funcion OK!!!
			Atencion se tuvo que formatear mkfs desde MINIX real  !!!!!
			
			
	QUE RESOLVER
				POR QUE RS SE PRESENTA
			0   2     2   709/10     0    0   20 27342 27342 27342 27342 cmdline    << RS ¿¿ PORQUE SALE ASI

	
---------------------------------------------------------------------------------
20181016/21:
		Se creo dvs-apps/dc_init/dc_init 
		En este se mezclan test_dc_init y https://wvi.cz/diyC/ para crear containers-from-scratch
		El script tests.sh autogenera el archivo de configuracion
		root@node0:/usr/src/dvs/dvs-apps/dc_init# more DC0.cfg 
				# dc_init config file
				dc DC0 {
				dcid 0;
				nr_procs 221;
				nr_tasks 32;
				nr_sysprocs 64;
				nr_nodes 32;
				warn2proc 0;
				warnmsg 1;
				ip_addr "192.168.10.100";
				memory 512;
				image "/usr/src/dvs/vos/images/debian0.img";
				mount "/usr/src/dvs/vos/rootfs/DC0";
				};

		
---------------------------------------------------------------------------------
20181027:
root@node0:~# cd /usr/src/dvs/dvk-tests/
root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 0
lcl_nodeid=0 dcid=0
Enter para continuar... 
Spread Enter para continuar... 
partition 5
mount Enter para continuar... 
local_nodeid=0 Enter para continuar... 
DEBUG 535:dvk_open:40: Open dvk device file /dev/dvk
Initializing DVS. Local node ID 0... 
DEBUG 535:dvk_dvs_init:261: nodeid=0
DEBUG 535:dvk_dvs_init:265: ioctl ret=0 errno=0
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
d_max_copybuf=65536 d_max_copylen=1048576
d_dbglvl=FFFFFF version=2.1 sizeof(proc)=0
DC0 Enter para continuar... 
 dc_read_config.c:search_dc_config:282:search_dc_config[0] line=2
 dc_read_config.c:search_dc_tkn:246:token dc dc_read_config.c:search_dc_tkn:249:DC0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=3 word=dcid
 dc_read_config.c:search_ident:83:line[3] MATCH identifier dcid
 dc_read_config.c:search_ident:94:dc_dcid=0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=4 word=nr_procs
 dc_read_config.c:search_ident:83:line[4] MATCH identifier nr_procs
 dc_read_config.c:search_ident:106:dc_nr_procs=221
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=5 word=nr_tasks
 dc_read_config.c:search_ident:83:line[5] MATCH identifier nr_tasks
 dc_read_config.c:search_ident:118:dc_nr_tasks=32
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=6 word=nr_sysprocs
 dc_read_config.c:search_ident:83:line[6] MATCH identifier nr_sysprocs
 dc_read_config.c:search_ident:130:dc_nr_sysprocs=64
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=7 word=nr_nodes
 dc_read_config.c:search_ident:83:line[7] MATCH identifier nr_nodes
 dc_read_config.c:search_ident:142:dc_nr_nodes=32
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=8 word=warn2proc
 dc_read_config.c:search_ident:83:line[8] MATCH identifier warn2proc
 dc_read_config.c:search_ident:154:dc_warn2proc=0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=9 word=warnmsg
 dc_read_config.c:search_ident:83:line[9] MATCH identifier warnmsg
 dc_read_config.c:search_ident:168:dc_warnmsg=1
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=10 word=ip_addr
 dc_read_config.c:search_ident:83:line[10] MATCH identifier ip_addr
 dc_read_config.c:search_ident:177:c_ip_addr=192.168.10.100
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=11 word=memory
 dc_read_config.c:search_ident:83:line[11] MATCH identifier memory
 dc_read_config.c:search_ident:185:c_memory=512
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=12 word=image
 dc_read_config.c:search_ident:83:line[12] MATCH identifier image
 dc_read_config.c:search_ident:197:c_image=/usr/src/dvs/vos/images/debian0.img
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=13 word=mount
 dc_read_config.c:search_ident:83:line[13] MATCH identifier mount
 dc_read_config.c:search_ident:205:c_mount=/usr/src/dvs/vos/rootfs/DC0
 dc_init.c:main:103:nr_containers=1
 dc_init.c:main:124:PARENT dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=32 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:main:125:PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
 dc_init.c:main:126:PARENT dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
DEBUG 536:dvk_open:40: Open dvk device file /dev/dvk
 dc_init.c:main:151:PARENT c_mount=/usr/src/dvs/vos/rootfs/DC0
 dc_init.c:create_peer:565:PARENT set_int=ip link add veth0 type veth peer name veth1
 dc_init.c:create_peer:570:PARENT set_int_up=ip link set veth0 up
 dc_init.c:create_peer:575:PARENT add_to_bridge=ip link set veth0 master 4743868
Error: argument "4743868" is wrong: Device does not exist

PARENT Sysname:  Linux
PARENT Nodename: node0
PARENT Release:  4.9.88
PARENT Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
PARENT Machine:  i686
PARENT link_name:/proc/536/ns/pid root_dir=pid:[4026531836]
CHILD link_name:/proc/554/ns/pid root_dir=pid:[4026532501]
PARENT link_name:/proc/536/ns/uts root_dir=uts:[4026531838]
CHILD link_name:/proc/554/ns/uts root_dir=uts:[4026532499]
DEBUG 536:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 536:dvk_getdvsinfo:113: 
DEBUG 536:dvk_getdvsinfo:115: ioctl ret=0
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
local_nodeid=0
 dc_init.c:network_setup:591:set_pid_ns=ip link set veth1 netns 554
 dc_init.c:init_dc:247:Waiting for parent to finish setup
 dc_init.c:cgroup_setup:518:Setting up cgroups with memory limit 512 MB (536870912)
 dc_init.c:cgroup_setup:521:cgroup_dir /sys/fs/cgroup/memory/554
 dc_init.c:cgroup_setup:527:cgroup_file /sys/fs/cgroup/memory/554/memory.limit_in_bytes
 dc_init.c:cgroup_setup:545:cgroup_file /sys/fs/cgroup/memory/554/cgroup.procs
PARENT exiting - child_pid=554
 dc_init.c:init_dc:253:CHILD  PID=1 PPID=0
 dc_init.c:init_dc:256:CHILD before dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=32 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:init_dc:257:CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
 dc_init.c:init_dc:258:CHILD before dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
 dc_init.c:init_dc:270:CHILD I am a daemon
DEBUG 1:dvk_dc_init:80: 
DEBUG 1:dvk_dc_init:82: ioctl ret=0 errno=0
DC0 has been initialized on node 0
DEBUG 1:dvk_getnodeinfo:177: nodeid=0
DEBUG 1:dvk_getnodeinfo:181: ioctl ret=0 errno=0
 dc_init.c:init_dc:279:CHILD n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=1 n_name=node0
DEBUG 1:dvk_getdcinfo:163: dcid=0
DEBUG 1:dvk_getdcinfo:167: ioctl ret=0 errno=0
 dc_init.c:init_dc:283:CHILD after  dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=32 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:init_dc:284:CHILD after  flags=0 dc_nodes=1 dc_pid=554 dc_name=DC0
 dc_init.c:init_dc:285:CHILD after  dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
CHILD Sysname:  Linux
CHILD Nodename: DC0
CHILD Release:  4.9.88
CHILD Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
CHILD Machine:  i686
CHILD chroot to:  /usr/src/dvs/vos/rootfs/DC0
 dc_init.c:init_dc:360:/proc mounted
 dc_init.c:init_dc:372:/dev mounted
 dc_init.c:init_dc:379:Setting env variables
 dc_init.c:init_dc:381:unsetenv LC_ALL
 dc_init.c:init_dc:409:sleep looping
TCP PROXY Enter para continuar... 
Enter para continuar... 
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     6      -1        0        0 -------------------------------X node0           
 1     2       1        0        0 -------------------------------- node1           
Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
      1     1    588      589           node1 ------------------------------X-
ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
 1 send    588      0      1        0        0  27342  27342  27342 tcp_proxy_bat  
 1 recv    589      0      1        0        0  27342  27342  27342 tcp_proxy_bat  
ADDNODE Enter para continuar... 
dcid=0
flags=0
nr_procs=221
nr_tasks=32
nr_sysprocs=64
nr_nodes=32
dc_nodes=1
dc_pid=554
warn2proc=0
warnmsg=1
dc_name=DC0
nodes 33222222222211111111110000000000
      10987654321098765432109876543210
      -------------------------------X
cpumask=1 
DEBUG 594:dvk_open:40: Open dvk device file /dev/dvk
Adding node 1 to DC 0... 
DEBUG 594:dvk_add_node:233: dcid=0 nodeid=1
DEBUG 594:dvk_add_node:237: ioctl ret=0 errno=0
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     6      -1        0        0 -------------------------------X node0           
 1     2       1        0        0 -------------------------------X node1           
dcid=0
flags=0
nr_procs=221
nr_tasks=32
nr_sysprocs=64
nr_nodes=32
dc_nodes=3
dc_pid=554
warn2proc=0
warnmsg=1
dc_name=DC0
nodes 33222222222211111111110000000000
      10987654321098765432109876543210
      ------------------------------XX
cpumask=1 


---------------------------------------------------------------------------------
20181027: SE DESARROLLO spread_proxy_bat 

root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 0
lcl_nodeid=0 dcid=0
Enter para continuar... 
Spread Enter para continuar... 
partition 5
mount Enter para continuar... 
local_nodeid=0 Enter para continuar... 
DEBUG 558:dvk_open:40: Open dvk device file /dev/dvk
Initializing DVS. Local node ID 0... 
DEBUG 558:dvk_dvs_init:261: nodeid=0
DEBUG 558:dvk_dvs_init:265: ioctl ret=0 errno=0
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
d_max_copybuf=65536 d_max_copylen=1048576
d_dbglvl=FFFFFF version=2.1 sizeof(proc)=0
DC0 Enter para continuar... 
 dc_read_config.c:search_dc_config:282:search_dc_config[0] line=2
 dc_read_config.c:search_dc_tkn:246:token dc dc_read_config.c:search_dc_tkn:249:DC0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=3 word=dcid
 dc_read_config.c:search_ident:83:line[3] MATCH identifier dcid
 dc_read_config.c:search_ident:94:dc_dcid=0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=4 word=nr_procs
 dc_read_config.c:search_ident:83:line[4] MATCH identifier nr_procs
 dc_read_config.c:search_ident:106:dc_nr_procs=221
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=5 word=nr_tasks
 dc_read_config.c:search_ident:83:line[5] MATCH identifier nr_tasks
 dc_read_config.c:search_ident:118:dc_nr_tasks=34
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=6 word=nr_sysprocs
 dc_read_config.c:search_ident:83:line[6] MATCH identifier nr_sysprocs
 dc_read_config.c:search_ident:130:dc_nr_sysprocs=64
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=7 word=nr_nodes
 dc_read_config.c:search_ident:83:line[7] MATCH identifier nr_nodes
 dc_read_config.c:search_ident:142:dc_nr_nodes=32
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=8 word=warn2proc
 dc_read_config.c:search_ident:83:line[8] MATCH identifier warn2proc
 dc_read_config.c:search_ident:154:dc_warn2proc=0
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=9 word=warnmsg
 dc_read_config.c:search_ident:83:line[9] MATCH identifier warnmsg
 dc_read_config.c:search_ident:168:dc_warnmsg=1
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=10 word=ip_addr
 dc_read_config.c:search_ident:83:line[10] MATCH identifier ip_addr
 dc_read_config.c:search_ident:177:c_ip_addr=192.168.10.100
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=11 word=memory
 dc_read_config.c:search_ident:83:line[11] MATCH identifier memory
 dc_read_config.c:search_ident:185:c_memory=512
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=12 word=image
 dc_read_config.c:search_ident:83:line[12] MATCH identifier image
 dc_read_config.c:search_ident:197:c_image=/usr/src/dvs/vos/images/debian0.img
 dc_read_config.c:read_lines:228:read_lines type=200
 dc_read_config.c:search_ident:80:search_ident[0] line=13 word=mount
 dc_read_config.c:search_ident:83:line[13] MATCH identifier mount
 dc_read_config.c:search_ident:205:c_mount=/usr/src/dvs/vos/rootfs/DC0
 dc_init.c:main:103:nr_containers=1
 dc_init.c:main:124:PARENT dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:main:125:PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
 dc_init.c:main:126:PARENT dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
DEBUG 559:dvk_open:40: Open dvk device file /dev/dvk
 dc_init.c:main:151:PARENT c_mount=/usr/src/dvs/vos/rootfs/DC0
 dc_init.c:create_peer:565:PARENT set_int=ip link add veth0 type veth peer name veth1
 dc_init.c:create_peer:570:PARENT set_int_up=ip link set veth0 up
 dc_init.c:create_peer:575:PARENT add_to_bridge=ip link set veth0 master 4854460
Error: argument "4854460" is wrong: Device does not exist

PARENT Sysname:  Linux
PARENT Nodename: node0
PARENT Release:  4.9.88
PARENT Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
PARENT Machine:  i686
PARENT link_name:/proc/559/ns/pid root_dir=pid:[4026531836]
CHILD link_name:/proc/576/ns/pid root_dir=pid:[4026532501]
PARENT link_name:/proc/559/ns/uts root_dir=uts:[4026531838]
CHILD link_name:/proc/576/ns/uts root_dir=uts:[4026532499]
DEBUG 559:dvk_open:40: Open dvk device file /dev/dvk
DEBUG 559:dvk_getdvsinfo:113: 
DEBUG 559:dvk_getdvsinfo:115: ioctl ret=0
d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
local_nodeid=0
 dc_init.c:network_setup:591:set_pid_ns=ip link set veth1 netns 576
 dc_init.c:init_dc:247:Waiting for parent to finish setup
 dc_init.c:cgroup_setup:518:Setting up cgroups with memory limit 512 MB (536870912)
 dc_init.c:cgroup_setup:521:cgroup_dir /sys/fs/cgroup/memory/576
 dc_init.c:cgroup_setup:527:cgroup_file /sys/fs/cgroup/memory/576/memory.limit_in_bytes
 dc_init.c:cgroup_setup:545:cgroup_file /sys/fs/cgroup/memory/576/cgroup.procs
PARENT exiting - child_pid=576
 dc_init.c:init_dc:253:CHILD  PID=1 PPID=0
 dc_init.c:init_dc:256:CHILD before dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:init_dc:257:CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
 dc_init.c:init_dc:258:CHILD before dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
 dc_init.c:init_dc:270:CHILD I am a daemon
DEBUG 1:dvk_dc_init:80: 
DEBUG 1:dvk_dc_init:82: ioctl ret=0 errno=0
DC0 has been initialized on node 0
DEBUG 1:dvk_getnodeinfo:177: nodeid=0
DEBUG 1:dvk_getnodeinfo:181: ioctl ret=0 errno=0
 dc_init.c:init_dc:279:CHILD n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=1 n_name=node0
DEBUG 1:dvk_getdcinfo:163: dcid=0
DEBUG 1:dvk_getdcinfo:167: ioctl ret=0 errno=0
 dc_init.c:init_dc:283:CHILD after  dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 dc_init.c:init_dc:284:CHILD after  flags=0 dc_nodes=1 dc_pid=576 dc_name=DC0
 dc_init.c:init_dc:285:CHILD after  dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
CHILD Sysname:  Linux
CHILD Nodename: DC0
CHILD Release:  4.9.88
CHILD Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
CHILD Machine:  i686
CHILD chroot to:  /usr/src/dvs/vos/rootfs/DC0
 dc_init.c:init_dc:360:/proc mounted
 dc_init.c:init_dc:372:/dev mounted
 dc_init.c:init_dc:379:Setting env variables
 dc_init.c:init_dc:381:unsetenv LC_ALL
 dc_init.c:init_dc:409:sleep looping
SPREAD PROXY Enter para continuar... 
Enter para continuar... 
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     6      -1        0        0 -------------------------------X node0           
 1     E       1        0        0 -------------------------------- node1           
Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
      1     7    612      609           node1 ------------------------------X-
ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
 1 send    612      8      3        0        0  31438  27342  27342 sp_proxy_bat   
 1 recv    609      0      3        0        0  27342  27342  27342 sp_proxy_bat   
ADDNODE Enter para continuar... 
dcid=0
flags=0
nr_procs=221
nr_tasks=34
nr_sysprocs=64
nr_nodes=32
dc_nodes=1
dc_pid=576
warn2proc=0
warnmsg=1
dc_name=DC0
nodes 33222222222211111111110000000000
      10987654321098765432109876543210
      -------------------------------X
cpumask=1 
DEBUG 617:dvk_open:40: Open dvk device file /dev/dvk
Adding node 1 to DC 0... 
DEBUG 617:dvk_add_node:233: dcid=0 nodeid=1
DEBUG 617:dvk_add_node:237: ioctl ret=0 errno=0
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     6      -1        0        0 -------------------------------X node0           
 1     E       1        0        0 -------------------------------X node1           
dcid=0
flags=0
nr_procs=221
nr_tasks=34
nr_sysprocs=64
nr_nodes=32
dc_nodes=3
dc_pid=576
warn2proc=0
warnmsg=1
dc_name=DC0
nodes 33222222222211111111110000000000
      10987654321098765432109876543210
      ------------------------------XX
cpumask=1 


				
root@node0:/usr/src/dvs/vos/mol# cat /proc/dvs/proxies/procs 
ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
 1 send    589      8      3        0        0  31438  27342  27342 sp_proxy_bat   
 1 recv    586      0      3        0        0  27342  27342  27342 sp_proxy_bat
 
root@node0:/usr/src/dvs/vos/mol# ps -eLf	
root       576     1   576  0    1 20:29 ?        00:00:00 ./dc_init DC0.cfg
root       609     1   609  0    3 20:29 pts/0    00:00:00 ./sp_proxy_bat node1 1
root       609     1   611  0    3 20:29 pts/0    00:00:00 ./sp_proxy_bat node1 1
root       609     1   612  0    3 20:29 pts/0    00:00:00 ./sp_proxy_bat node1 1
root       635     1   635  0    2 20:30 pts/0    00:00:00 ./systask -d 0
root       635     1   636  0    2 20:30 pts/0    00:00:00 ./systask -d 0


	
root@node0:/usr/src/dvs/vos/mol# cat /proc/dvs/proxies/procs 
ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
 1 send    612      8      3        0        0  31438  27342  27342 sp_proxy_bat   
 1 recv    609      0      3        0        0  27342  27342  27342 sp_proxy_bat   



ATENCION: Se solucion poniendo  SELFTASK en lugar del propio PID o del thread.
SEGURAMENTE ESTO TIENE QUE VER CON QUE AHORA EJECUTA EN EL CONTAINER 
Aunque no deberia tener problemas ya que se tiene en considerasion el NS al que pertenece .
			task_ptr = pid_task(find_pid_ns(param_pid, dc_ptr->dc_pid_ns), PIDTYPE_PID);

ES PORQUE NO LO EJECUTE CON nsenter !!!!!!

			
			
#define SELFTASK (-1) 
	pm_ep = dvk_replbind(dcid, SELFTASK, PM_PROC_NR);
 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0 -34   -34   636/5      0    0   80 27342 27342 27342 27342 systask        
 0  -2    -2   635/4      0    8   20 31438 27342 27342 27342 systask        
 0   0     0   639/7      0    8   A0 31438 27342 27342 27342 pm             
 0   1     1   651/17     0    8   20 31438 27342 27342 27342 fs             
 0   2     2   643/10     0    0   20 27342 27342 27342 27342 cmdline 
 

PROBAR TRANSFERENCIAS CON SPREAD
---------------------------------------------------------------------------------
20181104:

NODE0:
	root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_r-s_server 1 10
	DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
	DEBUG 2:dvk_getdcinfo:163: dcid=0
	DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
	 loop_r-s_server.c:main:118:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
	 loop_r-s_server.c:main:119:flags=0 dc_nodes=3 dc_pid=685 dc_name=DC0
	 loop_r-s_server.c:main:140:MAIN SERVER m_ptr=0xaf3000
	DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=0 nodeid=-1
	DEBUG 2:dvk_bind_X:544: ioctl ret=0 errno=0
	 loop_r-s_server.c:main:149:BIND MAIN SERVER dcid=0 svr_pid=2 SVR_NR=0 svr_ep=0
	DEBUG 2:dvk_bind_X:536: cmd=2 dcid=0 pid=-1074675068 endpoint=1 nodeid=1
	DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0
	 loop_r-s_server.c:main:160:MAIN SERVER dvk_rmtbind 1: process client1 on node 1 
	 loop_r-s_server.c:main:164:child fork 0
	 loop_r-s_server.c:main:169:MAIN SERVER child_pid[0]=3
	 loop_r-s_server.c:main:173:MAIN SERVER: START synchronization from 1 children: REQUEST
	DEBUG 2:dvk_receive_T:362: endpoint=2 timeout=-1
	DEBUG 2:dvk_receive_T:367: ioctl ret=-1 errno=108 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	ERROR: 2:dvk_receive_T:368: rcode=-108
	 loop_r-s_server.c:child_function:19:child 0: loops=10 child_nr=2
	DEBUG 3:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=2 nodeid=-1
	DEBUG 3:dvk_bind_X:544: ioctl ret=2 errno=0
	 loop_r-s_server.c:child_function:25:CHILD child=0 child_nr=2 child_ep=2 child_pid=3
	DEBUG 3:dvk_bind_X:536: cmd=2 dcid=0 pid=-1074675176 endpoint=3 nodeid=1
	DEBUG 3:dvk_bind_X:544: ioctl ret=3 errno=0
	DEBUG 3:dvk_sendrec_T:379: endpoint=0 timeout=-1
	DEBUG 2:dvk_receive_T:362: endpoint=2 timeout=-1
	DEBUG 2:dvk_receive_T:367: ioctl ret=76 errno=108 
	 loop_r-s_server.c:main:186:MAIN SERVER: START synchronization from 1 children: REPLY 
	DEBUG 2:dvk_send_T:345: endpoint=2 timeout=-1
	DEBUG 2:dvk_send_T:350: ioctl ret=76 errno=0
	 loop_r-s_server.c:main:197:MAIN SERVER: Waiting START message from remote CLIENT
	DEBUG 2:dvk_receive_T:362: endpoint=31438 timeout=-1
	DEBUG 3:dvk_sendrec_T:384: ioctl ret=0 errno=0
	 loop_r-s_server.c:child_function:48:CHILD 0: Starting loop
	DEBUG 3:dvk_receive_T:362: endpoint=3 timeout=-1

NODE1: 
	root@node1:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_sr_client 1 10
	DEBUG 2:dvk_open:40: Open dvk device file /dev/dvk
	DEBUG 2:dvk_getdcinfo:163: dcid=0
	DEBUG 2:dvk_getdcinfo:167: ioctl ret=0 errno=0
	 loop_sr_client.c:main:110:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
	 loop_sr_client.c:main:111:flags=0 dc_nodes=3 dc_pid=880 dc_name=DC0
	MAIN CLIENT m_ptr=0x1961000
	DEBUG 2:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=1 nodeid=-1
	DEBUG 2:dvk_bind_X:544: ioctl ret=1 errno=0
	BIND MAIN CLIENT dcid=0 clt_pid=2 CLT_NR=1 clt_ep=1
	child fork 0
	MAIN CLIENT child_pid[0]=3
	MAIN CLIENT: START 1 children synchronization: REQUEST
	DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1
	DEBUG 2:dvk_receive_T:367: ioctl ret=-1 errno=108
	ERROR: 2:dvk_receive_T:368: rcode=-108 			<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	child 0: loops=10 child_nr=3
	DEBUG 3:dvk_bind_X:536: cmd=2 dcid=0 pid=-1077664104 endpoint=2 nodeid=0
	DEBUG 3:dvk_bind_X:544: ioctl ret=2 errno=0
	DEBUG 3:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=3 nodeid=-1
	DEBUG 3:dvk_bind_X:544: ioctl ret=3 errno=0
	CHILD child=0 child_nr=3 child_ep=3 child_pid=3
	DEBUG 3:dvk_sendrec_T:379: endpoint=1 timeout=-1
	DEBUG 2:dvk_receive_T:362: endpoint=3 timeout=-1
	DEBUG 2:dvk_receive_T:367: ioctl ret=76 errno=108 
	DEBUG 2:dvk_bind_X:536: cmd=2 dcid=0 pid=-1077664000 endpoint=0 nodeid=0
	DEBUG 2:dvk_bind_X:544: ioctl ret=0 errno=0
	MAIN CLIENT dvk_rmtbind 0: process server0 on node 0 
	MAIN CLIENT: Sending START message to remote SERVER
	DEBUG 2:dvk_sendrec_T:379: endpoint=0 timeout=-1


root@node0:/usr/src/dvs# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   0     0   714/2      0    8   20 31438 27342 27342 27342 loop_r-s_server
 0   1     1    -1/-1     1 1000    0 27342 27342 27342 27342 client1        
 0   2     2   715/3      0    8   20     3 27342 27342 27342 loop_r-s_server
 0   3     3    -1/-1     1 1000    0 27342 27342 27342 27342 client3        
root@node0:/usr/src/dvs# cat /proc/dvs/DC0/
info   procs  stats  
root@node0:/usr/src/dvs# cat /proc/dvs/DC0/stats 
DC pnr -endp -lpid/vpid- nd --lsnt-- --rsnt-- -lcopy-- -rcopy-- name
 0   0     0   714/    2  0        1        0        0        0 loop_r-s_server
 0   1     1    -1/   -1  1        0        0        0        0 client1        
 0   2     2   715/    3  0        1        0        0        0 loop_r-s_server
 0   3     3    -1/   -1  1        0        0        0        0 client3    
 
root@node0:/usr/src/dvs# cat /proc/dvs/nodes 
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     6      -1        0        0 -------------------------------X node0           
 1     E       1        0        0 -------------------------------X node1   
 
	
root@node1:/usr/src/dvs# cat /proc/dvs/DC0/stats 
DC pnr -endp -lpid/vpid- nd --lsnt-- --rsnt-- -lcopy-- -rcopy-- name
 0   0     0    -1/   -1  0        0        0        0        0 server0        
 0   1     1   670/    2  1        0        0        0        0 loop_sr_client 
 0   2     2    -1/   -1  0        0        0        0        0 server2        
 0   3     3   671/    3  1        0        0        0        0 loop_sr_client 
root@node1:/usr/src/dvs# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   0     0    -1/-1     0 1000    0 27342 27342 27342 27342 server0        
 0   1     1   670/2      1    8   20     0 27342 27342 27342 loop_sr_client 
 0   2     2    -1/-1     0 1000    0 27342 27342 27342 27342 server2        
 0   3     3   671/3      1    8   20     1 27342 27342 27342 loop_sr_client
 
root@node1:/usr/src/dvs# cat /proc/dvs/nodes 
ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
 0     E       0        1        0 -------------------------------X node0   <<<<<< APARENTEMENTE ENVIO UN MENSAJE         
 1     6      -1        0        0 -------------------------------X node1 

 
 sp_proxy_bat.c:spread_receive:216:RPROXY Spread waiting a message
 sp_proxy_bat.c:spread_receive:241:sender=PROXY Private_group=#proxy.1#localhost service_type=4352 SP_bytes=56 
 sp_proxy_bat.c:spread_receive:265:Received REGULAR membership for group PROXY with 1 members, where I am member 0:
 sp_proxy_bat.c:get_nodeid:110:member=#proxy nodeid=0
 sp_proxy_bat.c:spread_receive:274:	#proxy:0
 sp_proxy_bat.c:spread_receive:279:num_groups=1 OLD bm_active=0 NEW bm_active=1
 sp_proxy_bat.c:spread_receive:287:Due to the JOIN of #proxy.1#localhost
 sp_proxy_bat.c:get_nodeid:110:member=#proxy nodeid=0
 
  sp_proxy_bat.c:spread_receive:216:RPROXY Spread waiting a message
 sp_proxy_bat.c:spread_receive:241:sender=PROXY Private_group=#proxy.0#localhost service_type=4352 SP_bytes=56 
 sp_proxy_bat.c:spread_receive:265:Received REGULAR membership for group PROXY with 1 members, where I am member 0:
 sp_proxy_bat.c:get_nodeid:110:member=#proxy nodeid=0
 sp_proxy_bat.c:spread_receive:274:	#proxy:0
 sp_proxy_bat.c:spread_receive:279:num_groups=1 OLD bm_active=0 NEW bm_active=1
 sp_proxy_bat.c:spread_receive:287:Due to the JOIN of #proxy.0#localhost
 sp_proxy_bat.c:get_nodeid:110:member=#proxy nodeid=0

 HAY ALGUN PROBLEMA CON EL get_nodeid 
 
 ------------------------------------------------------------------------------------------------------------
 20181107:
		Se soluciono el problema del get_nodeid porque el nombre del usuario estaba mal construido 
		Se construye asi 
			sprintf( User, "%d.%d", local_nodeid, px.px_id);
		
		Luego habia un problema con SPREAD que no se vei el node0 con node1
		Se removio de /etc/spread.conf la configuracion del segmento de localhost 
			#Spread_Segment 127.0.0.255
			#{
			#       localhost               127.0.0.1
			#}
					 
 En NODE0 despues de ejecutar 
		root@node0:/usr/src/dvs/dvk-proxies/test# nsenter -p -u -t$DC0 ./loop_r-s_server 1 10
HAY UN FAULT EN EL RPROXY

  loop_r-s_server.c:main:186:MAIN SERVER: START synchronization from 1 children: REPLY 
DEBUG 2:dvk_send_T:345: endpoint=2 timeout=-1
DEBUG 2:dvk_send_T:350: ioctl ret=76 errno=0
 loop_r-s_server.c:main:197:MAIN SERVER: Waiting START message from remote CLIENT
DEBUG 2:dvk_receive_T:362: endpoint=31438 timeout=-1
DEBUG 3:dvk_sendrec_T:384: ioctl ret=0 errno=0
 loop_r-s_server.c:child_function:48:CHILD 0: Starting loop

DEBUG 3:dvk_receive_T:362: endpoint=3 timeout=-1

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.749243] CPU: 0 PID: 587 Comm: sp_proxy_bat Tainted: G           O    4.9.88 #12

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.750417] Hardware name: VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform, BIOS 6.00 07/02/2015

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.752984] task: d44309c0 task.stack: d4456000

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.763823] Stack:

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.765480]  00000000 0000024b f8dc0558 0000039c 00000249 00000000 fffffea2 00bc2000

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.767311]  0000004c 00000040 00000000 b6101034 00bc2000 ebb44600 00000001 ebb44400

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.769240]  d4457dbc ca0c3347 00000000 00000004 00000000 00000000 13756e11 ebb44600

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.771157] Call Trace:

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.773079]  [<ca0c3347>] ? vprintk_default+0x37/0x40

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.775040]  [<f8dadaf4>] ? send_rmt2lcl+0x2ff/0x3e4 [dvk]

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.777096]  [<f8db1925>] ? new_put2lcl+0xee4/0x17fb [dvk]

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.779152]  [<f8d9348c>] ? io_put2lcl+0x6a/0xbc [dvk]

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.781243]  [<f8d921e8>] ? dvk_ioctl+0xf0/0x184 [dvk]

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.783350]  [<f8d920f8>] ? dvk_write+0x3e/0x3e [dvk]

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.785478]  [<ca1efbd4>] ? do_vfs_ioctl+0x94/0x730

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.787654]  [<ca1dc66d>] ? vfs_write+0x15d/0x1c0

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.789838]  [<ca1f02d0>] ? SyS_ioctl+0x60/0x70

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.792091]  [<ca003728>] ? do_fast_syscall_32+0x98/0x160

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.794340]  [<ca5b7942>] ? sysenter_past_esp+0x47/0x75

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.796624] Code: e8 01 30 3c d1 83 86 38 01 00 00 01 8d 86 2c 01 00 00 c7 04 24 00 00 00 00 b9 01 00 00 00 ba 01 00 00 00 e8 7d 3c 30 d1 8b 4d c0 <c7> 81 38 01 00 00 ff ff ff ff c7 41 60 00 00 00 00 8b 81 d4 01

Message from syslogd@node0 at Nov  7 20:48:47 ...
 kernel:[  226.803896] EIP: [<f8da5dd6>] 

 ------------------------------------------------------------------------------------------------------------
 20181110: FUNCIONO LA TRANSFERENCIA DE MENSAJES PERO HAY UN BATCH MAL ARMADO 
 
 EN NODE0
 sp_proxy_bat.c:ps_start_serving:661:SPROXY 616: Getting more messages
DEBUG 613:dvk_get2rmt_T:464: timeout=0
DEBUG 613:dvk_get2rmt_T:469: ioctl ret=-1 errno=61
 sp_proxy_bat.c:ps_send_remote:593:SPROXY:cmd=0x1 dcid=0 src=2 dst=3 snode=0 dnode=1 rcode=0 len=0
 sp_proxy_bat.c:ps_send_header:544:SPROXY: send hdrlen=128 group:SP_PROXY cmd=1 
 sp_proxy_bat.c:ps_start_serving:623:SPROXY 616: Waiting a message
DEBUG 613:dvk_get2rmt_T:464: timeout=30000
 sp_proxy_bat.c:spread_receive:242:sender=#0.1#node0 Private_group=#0.1#node0 service_type=4 SP_bytes=128 
 sp_proxy_bat.c:spread_receive:251:message from #0.1#node0, of type 1, (endian 0) to 1 groups (128 bytes)
 sp_proxy_bat.c:spread_receive:217:RPROXY Spread waiting a message
 sp_proxy_bat.c:spread_receive:242:sender=#1.0#node1 Private_group=#0.1#node0 service_type=4 SP_bytes=256 
 sp_proxy_bat.c:spread_receive:251:message from #1.0#node1, of type 8193, (endian 0) to 1 groups (256 bytes)
 sp_proxy_bat.c:spread_receive:254:VALID PROXY MESSAGE RECEIVED from #1.0#node1(256 bytes)
 sp_proxy_bat.c:pr_process_message:399:RPROXY: cmd=0x2001 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=128
 sp_proxy_bat.c:pr_process_message:403:RPROXY: payload_size=128
 sp_proxy_bat.c:pr_process_message:421:RPROXY: put2lcl td_header=B6201000
DEBUG 613:dvk_put2lcl:219: 
DEBUG 613:dvk_put2lcl:223: ioctl ret=0 errno=0
 sp_proxy_bat.c:pr_process_message:427:RPROXY: rtd_ptr->td_batch_nr=1 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 sp_proxy_bat.c:pr_process_message:437:RPROXY: bat_cmd[0]:cmd=0x0 dcid=0 src=0 dst=0 snode=0 dnode=0 rcode=0 len=0 <<<<<<<<<<<<<<<<<<<<<
DEBUG 613:dvk_put2lcl:219: 
DEBUG 613:dvk_get2rmt_T:469: ioctl ret=-1 errno=61
 sp_proxy_bat.c:ps_start_serving:629:SPROXY: Sending HELLO 
 sp_proxy_bat.c:ps_send_remote:593:SPROXY:cmd=0x0 dcid=0 src=2 dst=3 snode=0 dnode=1 rcode=0 len=0
 sp_proxy_bat.c:ps_send_header:544:SPROXY: send hdrlen=128 group:SP_PROXY cmd=0 
 sp_proxy_bat.c:ps_start_serving:623:SPROXY 616: Waiting a message

 
	
EN NODE1

 sp_proxy_bat.c:ps_send_remote:593:SPROXY:cmd=0x3 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
 sp_proxy_bat.c:ps_send_header:544:SPROXY: send hdrlen=128 group:SP_PROXY cmd=3 
 sp_proxy_bat.c:ps_start_serving:623:SPROXY 578: Waiting a message
 
  sp_proxy_bat.c:ps_start_serving:647:SPROXY: 578 cmd=0x2001 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
 sp_proxy_bat.c:ps_start_serving:661:SPROXY 578: Getting more messages
DEBUG 575:dvk_get2rmt_T:464: timeout=0
DEBUG 575:dvk_get2rmt_T:469: ioctl ret=0 errno=0
 sp_proxy_bat.c:ps_start_serving:678:SPROXY: 578 cmd=0x2001 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=0
 sp_proxy_bat.c:ps_start_serving:689:SPROXY: new BATCHED COMMAND std_ptr->td_batch_nr=1
 sp_proxy_bat.c:ps_start_serving:661:SPROXY 578: Getting more messages
DEBUG 575:dvk_get2rmt_T:464: timeout=0
DEBUG 575:dvk_get2rmt_T:469: ioctl ret=-1 errno=61
 sp_proxy_bat.c:ps_start_serving:695:SPROXY: sending BATCHED COMMANDS std_ptr->td_batch_nr=1
 sp_proxy_bat.c:ps_send_remote:593:SPROXY:cmd=0x2001 dcid=0 src=3 dst=2 snode=1 dnode=0 rcode=0 len=128
 sp_proxy_bat.c:ps_send_remote:600:SPROXY: send header+payload paylen=128
 sp_proxy_bat.c:ps_send_hdr_pay:566:SPROXY: send hdrlen=128 paylen=128 group:SP_PROXY cmd=8193 


 ------------------------------------------------------------------------------------------------------------
 20181216: 	Se adapto RDISK para que funcione con RADAR
			Se migro RADAR 
				Radar escuchará en grupos SPREAD conformados por nombre
				"#xxxxxNN.dd" 
				"#xxxxx"
				Siendo 	NN=local_nodeid
						dd= DCID 
				Por ejemplo
					#RDISK01.05
				Indica que el servicio es RDISK, en el nodo 1, DCID=5
				El grupo privado del nodo (para UNICAST) es #RDISK01.05#node1	
				conformado por el nombre del grupo concatenado con el nombre
				del nodo 
				
			Rdisk ya arranca en NODO0
			
			Arrancar en los nodos RDISK el script 
			root@node0:/usr/src/dvs/scripts# ./rdisk.sh 0 0
			root@node0:/usr/src/dvs/scripts# . /usr/src/dvs/dvs-apps/dc_init/DC0.sh 
			root@node0:/usr/src/dvs/scripts# cd /usr/src/dvs/vos/mol/tasks/rdisk
			root@node0:/usr/src/dvs/vos/mol/tasks/rdisk# nsenter -p -u -F -t$DC0 ./rdisk.sh 0 &
			
			
	PROBLEMA:
		Al arrancar los 2 RDISK de NODO0 y NODO1  sin SYSTASK los enpoints utilizados por la sincronizacion
		de imagenes no estan bindeados remotamente
		
 ------------------------------------------------------------------------------------------------------------
 20181224:   
	
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   3     3   603/4      0    8   A0 31438 27342 27342 27342 rdisk 
 
 DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   3     3   589/4      1    0   A0 27342 27342 27342 27342 rdisk   
 
 			
 ------------------------------------------------------------------------------------------------------------
20181230:	

	NODO0: RDISK
		replicate.c:replica_loop:280:Received REGULAR membership for group RDISK00 with 2 members, where I am member 0:
		 replicate.c:replica_loop:288:	#RDISK0.0#node0
		 replicate.c:get_nodeid:1321:grp_name=#RDISK mbr_string=#RDISK0.0#node0 len=6
		 replicate.c:get_nodeid:1331:member=#RDISK0 nodeid=0
		 replicate.c:replica_loop:288:	#RADAR1.0#node1
		 replicate.c:replica_loop:294:bm_nodes=1
		 replicate.c:replica_loop:303:Due to the JOIN of #RADAR1.0#node1 service_type=4352
		 replicate.c:get_nodeid:1321:grp_name=#RADAR mbr_string=#RADAR1.0#node1 len=6
		 replicate.c:get_nodeid:1331:member=#RADAR1 nodeid=1
		 replicate.c:replica_loop:312:JOIN - nr_radar=0 bm_radar=0
		 replicate.c:replica_loop:315:JOIN end - nr_radar=1 bm_radar=2 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		 replicate.c:send_status_info:1358:local_nodeid=0, nr_nodes=1, nr_sync=1 <<<<<<<<<<<<<<<<<<<
		 replicate.c:replica_loop:423:MTX_UNLOCK bk_mutex 
		 replicate.c:replica_loop:163:sender=#RDISK0.0#node0 Private_group=#RDISK0.0#node0 dc_name=DC0 service_type=32
		 replicate.c:replica_loop:170:MTX_LOCK bk_mutex 
		 replicate.c:replica_loop:172:dynup_flag:1 - DO_DYNUPDATES:1
		 replicate.c:replica_loop:174:dynup_flag:1 - DO_DYNUPDATES:1
		 replicate.c:replica_loop:186:message from #RDISK0.0#node0, of type 129, (endian 0) to 1 groups (76 bytes)
		 replicate.c:replica_loop:251:source=0 type=129 m2i1=1 m2i2=1 m2i3=1 m2l1=1 m2l2=1 m2p1=0x2
		 replicate.c:mc_status_info:1226:source=0 type=129 m2i1=1 m2i2=1 m2i3=1 m2l1=1 m2l2=1 m2p1=0x2
		 replicate.c:replica_loop:423:MTX_UNLOCK bk_mutex 
 
			LUEGO, PARA PROBAR SE HACE KILL DE RDISK 
			LUEGO, PARA PROBAR SE HACER SHUTDOWN DE NODE0 

 NODO1: RADAR 
		root@node1:/usr/src/dvs/dvs-apps/radar# ./radar 0 3 RDISK
		DEBUG 592:dvk_open:40: Open dvk device file /dev/dvk
		DEBUG 592:dvk_getdvsinfo:113: 
		DEBUG 592:dvk_getdvsinfo:115: ioctl ret=1
		 radar.c:main:47:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
		 radar.c:main:48:local_nodeid=1
		DEBUG 592:dvk_getdcinfo:163: dcid=0
		DEBUG 592:dvk_getdcinfo:167: ioctl ret=0 errno=0
		 radar.c:main:72:RADAR: dcid=0 svr_ep=3 svr_name=RDISK
		 radar.c:init_radar:112:Spread library version is 5.0.1
		 radar.c:init_radar:121:spread_group=RDISK00
		 radar.c:init_radar:124:mbr_name=RADAR1.0
		 radar.c:init_radar:133:mbr_name RADAR1.0: connected to 4803 with private group #RADAR1.0#node1
		 radar.c:radar_loop:195:sender=RDISK00 Private_group=#RADAR1.0#node1 dc_name=DC0 service_type=4352
		 radar.c:radar_loop:231:Received REGULAR membership for group RDISK00 with 2 members, where I am member 1:
		 radar.c:radar_loop:239:        #RDISK0.0#node0
		 radar.c:radar_loop:239:        #RADAR1.0#node1
		 radar.c:radar_loop:249:Due to the JOIN of #RADAR1.0#node1 service_type=4352
		 radar.c:get_nodeid:458:grp_name=#RADAR mbr_string=#RADAR1.0#node1 len=6
		 radar.c:get_nodeid:467:member=#RADAR1 nodeid=1
		 radar.c:radar_loop:252:JOIN - nr_radar=0 bm_radar=0
		 radar.c:radar_loop:255:JOIN end - nr_radar=2 bm_radar=2
		 radar.c:radar_loop:195:sender=#RDISK0.0#node0 Private_group=#RADAR1.0#node1 dc_name=DC0 service_type=32
		 radar.c:radar_loop:207:message from #RDISK0.0#node0, of type 129, (endian 0) to 1 groups (76 bytes)
		 radar.c:mc_status_info:370:primary_mbr=-1  primary_old=-1 primary_new=0
		radar.c:mc_status_info:410:nr_nodes=1 nr_sync=1 nr_radar=1 bm_nodes=1 bm_sync=1 bm_radar=2

 
		PRUEBA 1: SE HACE KILL DE RDISK 

		 radar.c:radar_loop:263:Due to the LEAVE or DISCONNECT of #RDISK0.0#node0
		 radar.c:get_nodeid:458:grp_name=#RDISK mbr_string=#RDISK0.0#node0 len=6
		 radar.c:get_nodeid:467:member=#RDISK0 nodeid=0

		PRUEBA 1: SE HACER SHUTDOWN DE NODE0 

		 radar.c:radar_loop:195:sender=RDISK00 Private_group=#RADAR1.0#node1 dc_name=DC0 service_type=8192
		 radar.c:radar_loop:336:received TRANSITIONAL membership for group RDISK00
		 radar.c:radar_loop:340:received incorrecty membership message of type 0x2000
		 radar.c:radar_loop:195:sender=RDISK00 Private_group=#RADAR1.0#node1 dc_name=DC0 service_type=6144
		 radar.c:radar_loop:231:Received REGULAR membership for group RDISK00 with 1 members, where I am member 0:
		 radar.c:radar_loop:279:Due to NETWORK change with 1 VS sets
		 radar.c:radar_loop:299:LOCAL VS set 0 has 1 members:
		 radar.c:radar_loop:311:        #RADAR1.0#node1
		 radar.c:get_nodeid:463:grp_name=#RADAR mbr_string=#RADAR1.0#node1 len=6
		 radar.c:get_nodeid:472:member=#RADAR1 nodeid=1
		 radar.c:radar_loop:327:old bm_sync=1 bm_nodes=0 primary_mbr=0 nr_radar=1 bm_radar=2
		 radar.c:no_primary_net:442:
		 radar.c:radar_loop:334:new bm_sync=0 bm_nodes=0 primary_mbr=-3 nr_radar=1 bm_radar=2

------------------------------------------------------------------------------------------------------------
20181231:
			Modifique el TCP PROXY para que haga el AUTOMATIC BIND de clientes remotos. 
			
			Modifique RADAR e hice test_radar 
			
			Despues de arrancar RDISK en NODE0 y RADAR en NODE1 pruebo ejecutar
			
			root@node1:/usr/src/dvs/dvs-apps/radar# ./test_radar 0 3 66
			DEBUG 607:dvk_open:40: Open dvk device file /dev/dvk
			DEBUG 607:dvk_getprocinfo:512: dcid=0 p_nr=3 
			DEBUG 607:dvk_getprocinfo:517: ioctl ret=0 errno=0
			nr=3 endp=3 dcid=0 flags=1000 misc=0 lpid=-1 vpid=-1 nodeid=0 name=RDISK 
			endp=3 dcid=0 flags=1000 p_getfrom=27342 p_sendto=27342 p_waitmigr=27342 p_waitunbind=27342 p_proxy=27342
			nr=3 endp=3 dcid=0 p_lclsent=0 p_rmtsent=0 p_lclcopy=0 p_rmtcopy=0 
			DEBUG 607:dvk_bind_X:536: cmd=0 dcid=0 pid=-1 endpoint=66 nodeid=-1
			DEBUG 607:dvk_bind_X:544: ioctl ret=66 errno=0
			CLIENT BIND dcid=0 clt_pid=607 clt_nr=66 clt_ep=66 m_ptr=0x1e0d008
			CLIENT pause before SENDREC
			CLIENT FIRST SENDREC msg:source=0 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			DEBUG 607:dvk_sendrec_T:379: endpoint=3 timeout=-1
			DEBUG 607:dvk_sendrec_T:384: ioctl ret=0 errno=0
			CLIEN FIRST REPLY msg:source=3 type=68 m1i1=2 m1i2=0 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil)

			
		El proxy de node0 en NODE1
			 tcp_proxy.c:ps_start_serving:449:SPROXY 553: Waiting a message
			DEBUG 553:dvk_get2rmt_T:464: timeout=30000
			DEBUG 553:dvk_get2rmt_T:469: ioctl ret=0 errno=61
			 tcp_proxy.c:ps_start_serving:469:SPROXY: 553 cmd=0x3 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
			 tcp_proxy.c:ps_start_serving:476:SPROXY: source=66 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
			 tcp_proxy.c:ps_send_remote:420:SPROXY:cmd=0x3 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
			 tcp_proxy.c:ps_send_header:356:SPROXY: send header=128 
			 tcp_proxy.c:ps_send_header:374:SPROXY: socket=4 sent header=128 		

			 
		El proxy de node1 en NODE0
		 tcp_proxy.c:pr_process_message:138:RPROXY: About to receive header
		 tcp_proxy.c:pr_receive_header:108:socket=5
		 tcp_proxy.c:pr_receive_header:114:RPROXY: n:128 | received:128 | HEADER_SIZE:128
		 tcp_proxy.c:pr_receive_header:116:RPROXY: cmd=0x3 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
		 tcp_proxy.c:pr_process_message:141:RPROXY:cmd=0x3 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
		 tcp_proxy.c:pr_process_message:160:RPROXY: source=66 type=10 m1i1=1 m1i2=2 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		 tcp_proxy.c:pr_process_message:171:RPROXY: put2lcl
		DEBUG 585:dvk_put2lcl:219: 
		DEBUG 585:dvk_put2lcl:223: ioctl ret=-1 errno=310
		 tcp_proxy.c:pr_process_message:179:RPROXY: REMOTE CLIENT BINDING rcode=-310
		DEBUG 585:dvk_bind_X:536: cmd=2 dcid=0 pid=4603202 endpoint=66 nodeid=1
		DEBUG 585:dvk_bind_X:544: ioctl ret=66 errno=310
		 tcp_proxy.c:pr_process_message:238:RPROXY: put2lcl (autobind)
		DEBUG 585:dvk_put2lcl:219: 
		DEBUG 585:dvk_put2lcl:223: ioctl ret=76 errno=0
		 tcp_proxy.c:pr_start_serving:282:RPROXY: Message processing failure [-310]
		 tcp_proxy.c:pr_process_message:138:RPROXY: About to receive header
		 tcp_proxy.c:pr_receive_header:108:socket=5
		DEBUG 584:dvk_get2rmt_T:464: timeout=30000
		DEBUG 584:dvk_get2rmt_T:469: ioctl ret=0 errno=61
		 tcp_proxy.c:ps_start_serving:469:SPROXY: 584 cmd=0x1 dcid=0 src=3 dst=66 snode=0 dnode=1 rcode=0 len=0
		 tcp_proxy.c:ps_start_serving:476:SPROXY: source=3 type=68 m1i1=2 m1i2=0 m1i3=3 m1p1=(nil) m1p2=(nil) m1p3=(nil) 
		 tcp_proxy.c:ps_send_remote:420:SPROXY:cmd=0x1 dcid=0 src=3 dst=66 snode=0 dnode=1 rcode=0 len=0
		 tcp_proxy.c:ps_send_header:356:SPROXY: send header=128 
		 tcp_proxy.c:ps_send_header:374:SPROXY: socket=4 sent header=128 
		 tcp_proxy.c:ps_start_serving:449:SPROXY 584: Waiting a message
		 tcp_proxy.c:pr_receive_header:114:RPROXY: n:128 | received:128 | HEADER_SIZE:128
		 tcp_proxy.c:pr_receive_header:116:RPROXY: cmd=0x2001 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
		 tcp_proxy.c:pr_process_message:141:RPROXY:cmd=0x2001 dcid=0 src=66 dst=3 snode=1 dnode=0 rcode=0 len=0
		 tcp_proxy.c:pr_process_message:171:RPROXY: put2lcl
		DEBUG 585:dvk_put2lcl:219: 
		DEBUG 585:dvk_put2lcl:223: ioctl ret=0 errno=0
			
			
------------------------------------------------------------------------------------------------------------
20190106:
			MODIFIQUE RADAR Y RDISK Y DVKLIB

			PRUEBA 1: PRIMERO  RDISK EN NODE0 Y LUEGO SE ARRANCA RADAR EN NODE1 
			
	EN NODE0:
	cd /usr/src/dvs/scripts/
	./rdisk.sh 0 0
	. /usr/src/dvs/dvs-apps/dc_init/DC0.sh
	cd /usr/src/dvs/vos/mol/tasks/rdisk
	nsenter -p -u -F -t$DC0 ./rdisk.sh 0
	cat /proc/dvs/DC0/procs
	
	EN NODE1: 
	cd /usr/src/dvs/scripts/
	./rdisk.sh 1 0
	cd ../dvs-apps/radar/
	./radar 0 3 RDISK	
	
			
root@node1:/usr/src/dvs/dvs-apps/radar# ./radar 0 3 RDISK
DEBUG 777:dvk_open:40: Open dvk device file /dev/dvk
 radar.c:init_spread:152:Spread library version is 5.0.1
DEBUG 777:dvk_getdvsinfo:113: 
DEBUG 777:dvk_getdvsinfo:115: ioctl ret=1
 radar.c:main:52:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
 radar.c:main:53:local_nodeid=1
DEBUG 777:dvk_getdcinfo:163: dcid=0
DEBUG 777:dvk_getdcinfo:167: ioctl ret=0 errno=0
 radar.c:main:61:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 radar.c:main:62:flags=0 dc_nodes=7 dc_pid=556 dc_name=DC0
 radar.c:main:96:Starting CONTROL thread[1] 
 radar.c:main:97:rad_dcid=0 rad_ep=3 rad_len=5 rad_svrname=RDISK rad_mbr_name=
 radar.c:main:98:rad_primary_mbr=-1 rad_primary_old=-1 rad_nr_nodes=0 rad_nr_init=0 rad_nr_radar=0
 radar.c:main:99:rad_bm_nodes=0 rad_bm_init=0 rad_bm_radar=0
 radar.c:connect_to_spread:171:spread_group=RDISK00
 radar.c:connect_to_spread:174:rad_mbr_name=RADAR1.0
 radar.c:connect_to_spread:185:rad_mbr_name RADAR1.0: connected to 4803 with private group #RADAR1.0#node1
 radar.c:radar_loop:254: sender=RDISK Private_group=RDISK00 service_type=34377896
 radar.c:radar_loop:289:RDISK: Received REGULAR membership for group RDISK00 with 2 members, where I am member 1:
 radar.c:radar_loop:297:        #RDISK0.0#node0
 radar.c:radar_loop:297:        #RADAR1.0#node1
 radar.c:radar_loop:307:RDISK: Due to the JOIN of #RADAR1.0#node1 service_type=4352
 radar.c:get_nodeid:564:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_nodeid:575:member=RADAR1.0#node1 nodeid=1
 radar.c:get_dcid:592:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_dcid:605:member=RADAR1.0#node1 dcid=0
 radar.c:radar_loop:312:RDISK: JOIN - nr_radar=0 bm_radar=0
 radar.c:radar_loop:316:RDISK: JOIN end - nr_radar=2 bm_radar=2

 RDISK ENVIA EL MULTICAST DEL ESTADO 
 radar.c:radar_loop:254: sender=RDISK Private_group=#RDISK0.0#node0 service_type=34377896
 radar.c:radar_loop:266:RDISK: message from #RDISK0.0#node0, of type 129, (endian 0) to 1 groups (76 bytes)
 radar.c:radar_loop:274:RDISK: Ignored message type 81
 radar.c:radar_loop:254: sender=RDISK Private_group=#RDISK0.0#node0 service_type=34377896
 radar.c:radar_loop:266:RDISK: message from #RDISK0.0#node0, of type 218, (endian 0) to 1 groups (76 bytes)
 radar.c:mc_status_info:447:RDISK: primary_mbr=-1  primary_old=-1 primary_new=0
DEBUG 777:dvk_getprocinfo:512: dcid=0 p_nr=3 
DEBUG 777:dvk_getprocinfo:517: ioctl ret=0 errno=0
 radar.c:mc_status_info:453:RDISK: nr=3 endp=3 dcid=0 flags=1800 misc=0 lpid=-1 vpid=-1 nodeid=0 name=RDISK 
 radar.c:mc_status_info:499:RDISK: rad_dcid=0 rad_ep=3 rad_len=5 rad_svrname=RDISK rad_mbr_name=RADAR1.0
 radar.c:mc_status_info:500:RDISK: rad_primary_mbr=0 rad_primary_old=-1 rad_nr_nodes=1 rad_nr_init=1 rad_nr_radar=1
 radar.c:mc_status_info:501:RDISK: rad_bm_nodes=1 rad_bm_init=1 rad_bm_radar=2


 SE DESCONECTA LA PLACA ETHERNET DE NODE0
 radar.c:radar_loop:254: sender=RDISK Private_group=RDISK00 service_type=34377896
 radar.c:radar_loop:414:received TRANSITIONAL membership for group RDISK00
 radar.c:radar_loop:418:received incorrecty membership message of type 0x2000
 radar.c:radar_loop:254: sender=RDISK Private_group=RDISK00 service_type=34377896
 radar.c:radar_loop:289:RDISK: Received REGULAR membership for group RDISK00 with 1 members, where I am member 0:
 radar.c:radar_loop:348:RDISK: Due to NETWORK change with 492608405 VS sets
 radar.c:radar_loop:369:LOCAL VS set 0 has 1 members:
 radar.c:radar_loop:381:        #RADAR1.0#node1
 radar.c:get_nodeid:564:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_nodeid:575:member=RADAR1.0#node1 nodeid=1
 radar.c:get_dcid:592:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_dcid:605:member=RADAR1.0#node1 dcid=0
 radar.c:radar_loop:402:RDISK: old bm_init=1 bm_nodes=0 primary_mbr=0 nr_radar=1 bm_radar=2
 radar.c:no_primary_net:536:RDISK BEFORE: rad_primary_mbr=0  rad_primary_old=-1 
DEBUG 777:dvk_migrate_X:586: cmd=(null) pid=-1 dcid=0 endpoint=3 nodeid=-1
DEBUG 777:dvk_migrate_X:593: ioctl ret=-1 errno=332
ERROR: 777:dvk_migrate_X:594: rcode=-332
 radar.c:no_primary_net:543:RDISK ARTER: rad_primary_mbr=-3  rad_primary_old=0 
 radar.c:radar_loop:412:RDISK: new bm_init=0 bm_nodes=0 primary_mbr=-3 nr_radar=1 bm_radar=2



 radar.c:radar_loop:254: sender=RDISK Private_group=RDISK00 service_type=34377896
 radar.c:radar_loop:289:RDISK: Received REGULAR membership for group RDISK00 with 2 members, where I am member 1:
 radar.c:radar_loop:348:RDISK: Due to NETWORK change with 25584897 VS sets
 radar.c:radar_loop:369:OTHER VS set 0 has 1 members:
 radar.c:radar_loop:381:        #RDISK0.0#node0
 radar.c:get_nodeid:564:grp_name=RDISK mbr_string=RDISK0.0#node0 len=5
 radar.c:get_nodeid:575:member=RDISK0.0#node0 nodeid=0
 radar.c:get_dcid:592:grp_name=RDISK mbr_string=RDISK0.0#node0 len=5
 radar.c:get_dcid:605:member=RDISK0.0#node0 dcid=0
 radar.c:radar_loop:402:RDISK: old bm_init=0 bm_nodes=1 primary_mbr=-3 nr_radar=1 bm_radar=2
 radar.c:radar_loop:369:LOCAL VS set 1 has 1 members:
 radar.c:radar_loop:381:        #RADAR1.0#node1
 radar.c:get_nodeid:564:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_nodeid:575:member=RADAR1.0#node1 nodeid=1
 radar.c:get_dcid:592:grp_name=RADAR mbr_string=RADAR1.0#node1 len=5
 radar.c:get_dcid:605:member=RADAR1.0#node1 dcid=0
 radar.c:radar_loop:402:RDISK: old bm_init=0 bm_nodes=1 primary_mbr=-3 nr_radar=1 bm_radar=2
 radar.c:no_primary_net:536:RDISK BEFORE: rad_primary_mbr=-3  rad_primary_old=0 
DEBUG 777:dvk_migrate_X:586: cmd=(null) pid=-1 dcid=0 endpoint=3 nodeid=-1
DEBUG 777:dvk_migrate_X:593: ioctl ret=-1 errno=332
ERROR: 777:dvk_migrate_X:594: rcode=-332
 radar.c:no_primary_net:543:RDISK ARTER: rad_primary_mbr=-3  rad_primary_old=-3 
 radar.c:radar_loop:412:RDISK: new bm_init=0 bm_nodes=1 primary_mbr=-3 nr_radar=1 bm_radar=2

 radar.c:radar_loop:254: sender=RDISK Private_group=#RDISK0.0#node0 service_type=34377896
 radar.c:radar_loop:266:RDISK: message from #RDISK0.0#node0, of type 129, (endian 0) to 1 groups (76 bytes)
 radar.c:radar_loop:274:RDISK: Ignored message type 81
 radar.c:radar_loop:254: sender=RDISK Private_group=#RDISK0.0#node0 service_type=34377896
 radar.c:radar_loop:266:RDISK: message from #RDISK0.0#node0, of type 218, (endian 0) to 1 groups (76 bytes)
 radar.c:mc_status_info:447:RDISK: primary_mbr=-3  primary_old=-3 primary_new=0
 radar.c:mc_status_info:478:RDISK: The old primary its on other PARTITION
ViolaciÃ³n de segmento

------------------------------------------------------------------------------------------------------------
20190107:
		se verifica en RADAR que el endpoint a controlar no este corriendo en el local_nodeid
		SE CAMBIO EL ORDEN DEL NODEID Y DCID en el nombre del usuario del grupo.
		 
		  * format of mbr_string "#xxxxxNODEID.DCID#nodename" 

			UNA VEZ ARRANCADO RDISK EN NODE 0 SE ARRANCA RADAR EN NODE1 
		  
root@node1:/usr/src/dvs/dvs-apps/radar# ./radar 0 3 RDISK
DEBUG 895:dvk_open:40: Open dvk device file /dev/dvk
 radar.c:init_spread:171:Spread library version is 5.0.1
DEBUG 895:dvk_getdvsinfo:113: 
DEBUG 895:dvk_getdvsinfo:115: ioctl ret=1
 radar.c:main:53:d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
 radar.c:main:54:local_nodeid=1
DEBUG 895:dvk_getdcinfo:163: dcid=0
DEBUG 895:dvk_getdcinfo:167: ioctl ret=0 errno=0
 radar.c:main:62:dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
 radar.c:main:63:flags=0 dc_nodes=7 dc_pid=721 dc_name=DC0
DEBUG 895:dvk_getprocinfo:512: dcid=0 p_nr=3 
DEBUG 895:dvk_getprocinfo:517: ioctl ret=0 errno=0
 radar.c:main:83:nr=3 endp=3 dcid=0 flags=1000 misc=0 lpid=-1 vpid=-1 nodeid=0 name=RDISK 
 radar.c:main:115:Starting CONTROL thread[1] 
 radar.c:main:116:rad_dcid=0 rad_ep=3 rad_len=5 rad_svrname=RDISK rad_mbr_name=
 radar.c:main:117:rad_primary_mbr=-1 rad_primary_old=-1 rad_nr_nodes=0 rad_nr_init=0 
 radar.c:main:118:rad_bm_nodes=0 rad_bm_init=0
 radar.c:connect_to_spread:190:spread_group=RDISK00 <<<<<<<<<<<<<<<<<<<< NOMBRE DEL GRUPO "RDISK<dcid>"
 radar.c:connect_to_spread:193:rad_mbr_name=RADAR00.01 <<<<<<<<<<<<<<<<< NOMBRE DEL MIEMBRO "RDISK<dcid>.<nodeid>"
 radar.c:connect_to_spread:204:rad_mbr_name RADAR00.01: connected to 4803 with private group #RADAR00.01#node1 <<<<<< GRUPO PRIVADO DEL MIEMBRO 
 radar.c:radar_loop:273: sender=RDISK Private_group=RDISK00 service_type=30826664
 radar.c:radar_loop:308:RDISK: Received REGULAR membership for group RDISK00 with 2 members, where I am member 1:
 radar.c:radar_loop:316:        #RDISK00.00#node0 
 radar.c:radar_loop:316:        #RADAR00.01#node1
 radar.c:radar_loop:326:RDISK: Due to the JOIN of #RADAR00.01#node1 service_type=4352
 radar.c:get_nodeid:611:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_nodeid:624:member=RADAR00.01#node1 nid=1
 radar.c:get_dcid:583:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_dcid:594:member=RADAR00.01#node1 dcid=0
 radar.c:radar_loop:331:RDISK: JOIN - nr_radar=0 bm_radar=0
 radar.c:radar_loop:335:RDISK: JOIN end - nr_radar=2 bm_radar=2

  RDISK HACE UN MULTICAST RADAR INFO Y RADAR DE NODE1 SE ACTUALIZA SUS VARIABLES DE ESTADO 
 radar.c:radar_loop:273: sender=RDISK Private_group=#RDISK00.00#node0 service_type=30826664
 radar.c:radar_loop:285:RDISK: message from #RDISK00.00#node0, of type 218, (endian 0) to 1 groups (76 bytes)
 radar.c:get_radar_info:465:RDISK: primary_mbr=-1 primary_old=-1 primary_new=0
DEBUG 895:dvk_getprocinfo:512: dcid=0 p_nr=3 
DEBUG 895:dvk_getprocinfo:517: ioctl ret=0 errno=0
 radar.c:get_radar_info:472:RDISK: nr=3 endp=3 dcid=0 flags=1000 misc=0 lpid=-1 vpid=-1 nodeid=0 name=RDISK 
 radar.c:get_radar_info:518:RDISK: rad_dcid=0 rad_ep=3 rad_len=5 rad_svrname=RDISK rad_mbr_name=RADAR00.01
 radar.c:get_radar_info:519:RDISK: rad_primary_mbr=0 rad_primary_old=-1 rad_nr_nodes=3 rad_nr_init=1 
 radar.c:get_radar_info:520:RDISK: rad_bm_nodes=1 rad_bm_init=1

 LUEGO SE BAJA LA INTERFACE ETHERNET DE NODE 0 Y SPREAD LO DETECTA 
 radar.c:radar_loop:273: sender=RDISK Private_group=RDISK00 service_type=30826664
 radar.c:radar_loop:432:received TRANSITIONAL membership for group RDISK00
 radar.c:radar_loop:436:received incorrecty membership message of type 0x2000

 AHORA NODE1 ES EL UNICO MIEMBRO DEL GRUPO RDISK 
 radar.c:radar_loop:273: sender=RDISK Private_group=RDISK00 service_type=30826664
 radar.c:radar_loop:308:RDISK: Received REGULAR membership for group RDISK00 with 1 members, where I am member 0:
 radar.c:radar_loop:367:RDISK: Due to NETWORK change with 492608405 VS sets
 radar.c:radar_loop:388:LOCAL VS set 0 has 1 members:
 radar.c:radar_loop:400:        #RADAR00.01#node1
 radar.c:get_nodeid:611:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_nodeid:624:member=RADAR00.01#node1 nid=1
 radar.c:get_dcid:583:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_dcid:594:member=RADAR00.01#node1 dcid=0
 radar.c:radar_loop:421:RDISK: old bm_init=1 bm_nodes=0 primary_mbr=0 nr_radar=2 bm_radar=2
 radar.c:no_primary_net:555:RDISK BEFORE: rad_primary_mbr=0  rad_primary_old=-1 
DEBUG 895:dvk_migrate_X:585: cmd=0 pid=-1 dcid=0 endpoint=3 nodeid=-1
DEBUG 895:dvk_migrate_X:592: ioctl ret=0 errno=0
 radar.c:no_primary_net:562:RDISK ARTER: rad_primary_mbr=-3 (NO_PRIMARY_NET) rad_primary_old=0 <<<<<< VIEJO PRIMARIO  
 radar.c:radar_loop:430:RDISK: new bm_init=1 bm_nodes=0 primary_mbr=-3 nr_radar=2 bm_radar=2

 MENSAJE DE NETWORK MERGE DE SPREAD 
 radar.c:radar_loop:273: sender=RDISK Private_group=RDISK00 service_type=30826664
 radar.c:radar_loop:308:RDISK: Received REGULAR membership for group RDISK00 with 2 members, where I am member 1:
 radar.c:radar_loop:367:RDISK: Due to NETWORK change with 25584897 VS sets
 radar.c:radar_loop:388:OTHER VS set 0 has 1 members:
 radar.c:radar_loop:400:        #RDISK00.00#node0
 radar.c:get_nodeid:611:grp_name=RDISK mbr_string=RDISK00.00#node0 len=5
 radar.c:get_nodeid:624:member=RDISK00.00#node0 nid=0
 radar.c:get_dcid:583:grp_name=RDISK mbr_string=RDISK00.00#node0 len=5
 radar.c:get_dcid:594:member=RDISK00.00#node0 dcid=0
 radar.c:radar_loop:421:RDISK: old bm_init=1 bm_nodes=1 primary_mbr=-3 nr_radar=2 bm_radar=2
 radar.c:radar_loop:388:LOCAL VS set 1 has 1 members:
 radar.c:radar_loop:400:        #RADAR00.01#node1
 radar.c:get_nodeid:611:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_nodeid:624:member=RADAR00.01#node1 nid=1
 radar.c:get_dcid:583:grp_name=RADAR mbr_string=RADAR00.01#node1 len=5
 radar.c:get_dcid:594:member=RADAR00.01#node1 dcid=0
 radar.c:radar_loop:421:RDISK: old bm_init=1 bm_nodes=1 primary_mbr=-3 nr_radar=2 bm_radar=2
 radar.c:radar_loop:430:RDISK: new bm_init=1 bm_nodes=1 primary_mbr=-3 nr_radar=2 bm_radar=2

 RDISK HACE MULTICAST DE ESTADO PARA RADAR 
 radar.c:radar_loop:273: sender=RDISK Private_group=#RDISK00.00#node0 service_type=30826664
 radar.c:radar_loop:285:RDISK: message from #RDISK00.00#node0, of type 218, (endian 0) to 1 groups (76 bytes)
 radar.c:get_radar_info:465:RDISK: primary_mbr=-3 primary_old=0 primary_new=0
 radar.c:get_radar_info:496:RDISK: The old primary was on other PARTITION <<<<<<<<<<<< 
 radar.c:get_radar_info:502:RDISK: new primary is the same as old primary <<<<<<<<<<<< 
DEBUG 895:dvk_migrate_X:585: cmd=2 pid=-1 dcid=0 endpoint=3 nodeid=-1
DEBUG 895:dvk_migrate_X:592: ioctl ret=0 errno=0
 radar.c:get_radar_info:518:RDISK: rad_dcid=0 rad_ep=3 rad_len=5 rad_svrname=RDISK rad_mbr_name=RADAR00.01
 radar.c:get_radar_info:519:RDISK: rad_primary_mbr=0 rad_primary_old=0 rad_nr_nodes=1 rad_nr_init=1 
 radar.c:get_radar_info:520:RDISK: rad_bm_nodes=1 rad_bm_init=1
		
		
root@node1:/usr/src/dvs/dvs-apps/radar# cat /proc/dvs/DC0/procs 
DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
 0   3     3    -1/-1     0 1000    0 27342 27342 27342 27342 RDISK   


 TODO:  VERIFICAR QUE HACE RDISK CUANDO SE PRODUCE UNA PARTICION DE RED Y UN MERGE 
 
 	
 
------------------------------------------------------------------------------------------------------------
20190203:
			Cambie la denominacion de mol/tasks por mol/drivers al igual que MINIX 
			
			Migre el driver ETH que en realidad trabaja sobre TAP 
			
			Este crea THREADS pero aparentemente no se estan bindeando correctamente porque cuando se hace 
				un copy_usr2usr da FAULT 

			El que ejecuta esto es el TRHEAD 805, pero segun new_mini_sendrec el caller_pid=804  	
				[ 1270.043133] DEBUG 805:new_mini_sendrec:595: dcid=0 caller_pid=804 caller_nr=6 srcdst_ep=-2 
			Luego cuando se hace 
			[ 1270.043139] DEBUG 805:copy_usr2usr:886: rqtr_ep=6 src_ep=6 src_lpid=804 src_vpid=49 src_addr=b74a2000
					ATENCION: rqtr_ep = src_ep !!! 
					
			[ 1270.043141] DEBUG 805:copy_usr2usr:889: dst_ep=-2 dst_lpid=614 dst_vpid=4 dst_addr=00536f40 bytes=76
			[ 1270.043142] DEBUG 805:copy_usr2usr:893: task_pid_nr(current)=805
			[ 1270.043143] DEBUG 805:copy_usr2usr:913: COPY3 bytes=76
			
			[ 1270.055676] EIP is at copy_usr2usr+0x66e/0xaff [dvk]

			DICE ADEMAS 
			[ 1270.043840] kernel BUG at /usr/src/dvs/dvk-mod/dvk_utils.c:919!

			LA LINEA 919 ES 
					BUG_ON(rqtr_ptr == NULL);
			El valor de rqtr_ptr
					rqtr_ptr = current->task_proc;
					
		SOLUCIONADO!!!		
		if( thread_group_leader(current)){ /* Caller is the Group Leader */
			rqtr_ptr = current->task_proc;
		}else{
			rqtr_ptr = current->group_leader->task_proc;			
		}			
 
	PARA VER EL LOGGING DE LOS PROCESOS DEMONIZADOS CON demonize hay que ir al directorio de  RS 
	
	------------------------------ CORRIDA COMPLETA ---------------------------------------------------
	root@node0:~# cd /usr/src/dvs/dvk-tests/
	root@node0:/usr/src/dvs/dvk-tests# ./tests.sh 0 0
			lcl_nodeid=0 dcid=0
			Enter para continuar... 
			Spread Enter para continuar... 
			partition 5
			mount Enter para continuar... 
			local_nodeid=0 Enter para continuar... 
			DEBUG 520:dvk_open:40: Open dvk device file /dev/dvk
			Initializing DVS. Local node ID 0... 
			DEBUG 520:dvk_dvs_init:261: nodeid=0
			DEBUG 520:dvk_dvs_init:265: ioctl ret=0 errno=0
			d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
			d_max_copybuf=65536 d_max_copylen=1048576
			d_dbglvl=FFFFFF version=2.1 sizeof(proc)=0
			Get DVS info
			DEBUG 520:dvk_getdvsinfo:113: 
			DEBUG 520:dvk_getdvsinfo:115: ioctl ret=0
			local node ID 0... 
			d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
			d_max_copybuf=65536 d_max_copylen=1048576
			d_dbglvl=FFFFFFFF version=2.1 sizeof(proc)=512
			DC0 Enter para continuar... 
			 configfile.c:config_read:459:file=DC0.cfg flags=400
			 configfile.c:read_file:412:file=DC0.cfg
			 configfile.c:allocate:65:size=16
			 configfile.c:read_list:357:
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=23
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=24
			 configfile.c:allocate:65:size=20
			 configfile.c:read_list:357:
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=25
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=22
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=29
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=24
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=29
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=23
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=32
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=23
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=29
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=23
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=30
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=22
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=28
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=22
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=28
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=35
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=27
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=24
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=26
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=85
			 configfile.c:allocate:65:size=56
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=26
			 configfile.c:read_word:179:
			 configfile.c:allocate:65:size=53
			 configfile.c:allocate:65:size=48
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:allocate:65:size=20
			 configfile.c:read_line:315:
			 configfile.c:allocate:65:size=32
			 dc_read_config.c:search_dc_config:282:search_dc_config[0] line=2
			 dc_read_config.c:search_dc_tkn:246:token dc dc_read_config.c:search_dc_tkn:249:DC0
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=3 word=dcid
			 dc_read_config.c:search_ident:83:line[3] MATCH identifier dcid
			 dc_read_config.c:search_ident:94:dc_dcid=0
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=4 word=nr_procs
			 dc_read_config.c:search_ident:83:line[4] MATCH identifier nr_procs
			 dc_read_config.c:search_ident:106:dc_nr_procs=221
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=5 word=nr_tasks
			 dc_read_config.c:search_ident:83:line[5] MATCH identifier nr_tasks
			 dc_read_config.c:search_ident:118:dc_nr_tasks=34
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=6 word=nr_sysprocs
			 dc_read_config.c:search_ident:83:line[6] MATCH identifier nr_sysprocs
			 dc_read_config.c:search_ident:130:dc_nr_sysprocs=64
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=7 word=nr_nodes
			 dc_read_config.c:search_ident:83:line[7] MATCH identifier nr_nodes
			 dc_read_config.c:search_ident:142:dc_nr_nodes=32
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=8 word=warn2proc
			 dc_read_config.c:search_ident:83:line[8] MATCH identifier warn2proc
			 dc_read_config.c:search_ident:154:dc_warn2proc=0
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=9 word=warnmsg
			 dc_read_config.c:search_ident:83:line[9] MATCH identifier warnmsg
			 dc_read_config.c:search_ident:168:dc_warnmsg=1
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=10 word=ip_addr
			 dc_read_config.c:search_ident:83:line[10] MATCH identifier ip_addr
			 dc_read_config.c:search_ident:177:c_ip_addr=192.168.10.100
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=11 word=memory
			 dc_read_config.c:search_ident:83:line[11] MATCH identifier memory
			 dc_read_config.c:search_ident:185:c_memory=512
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=12 word=image
			 dc_read_config.c:search_ident:83:line[12] MATCH identifier image
			 dc_read_config.c:search_ident:197:c_image=/usr/src/dvs/vos/images/debian0.img
			 dc_read_config.c:read_lines:228:read_lines type=200
			 dc_read_config.c:search_ident:80:search_ident[0] line=13 word=mount
			 dc_read_config.c:search_ident:83:line[13] MATCH identifier mount
			 dc_read_config.c:search_ident:205:c_mount=/usr/src/dvs/vos/rootfs/DC0
			 dc_init.c:main:103:nr_containers=1
			 dc_init.c:main:124:PARENT dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
			 dc_init.c:main:125:PARENT flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
			 dc_init.c:main:126:PARENT dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
			DEBUG 521:dvk_open:40: Open dvk device file /dev/dvk
			 dc_init.c:main:151:PARENT c_mount=/usr/src/dvs/vos/rootfs/DC0
			 dc_init.c:create_peer:565:PARENT set_int=ip link add veth0 type veth peer name veth1
			 dc_init.c:create_peer:570:PARENT set_int_up=ip link set veth0 up
			 dc_init.c:create_peer:575:PARENT add_to_bridge=ip link set veth0 master 4825788
			Error: argument "4825788" is wrong: Device does not exist

			PARENT Sysname:  Linux
			PARENT Nodename: node0
			PARENT Release:  4.9.88
			PARENT Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
			PARENT Machine:  i686
			PARENT link_name:/proc/521/ns/pid root_dir=pid:[4026531836]
			CHILD link_name:/proc/536/ns/pid root_dir=pid:[4026532501]
			PARENT link_name:/proc/521/ns/uts root_dir=uts:[4026531838]
			CHILD link_name:/proc/536/ns/uts root_dir=uts:[4026532499]
			DEBUG 521:dvk_open:40: Open dvk device file /dev/dvk
			DEBUG 521:dvk_getdvsinfo:113: 
			DEBUG 521:dvk_getdvsinfo:115: ioctl ret=0
			d_nr_dcs=32 d_nr_nodes=32 d_nr_procs=221 d_nr_tasks=35 d_nr_sysprocs=64 
			local_nodeid=0
			 dc_init.c:network_setup:591:set_pid_ns=ip link set veth1 netns 536
			 dc_init.c:init_dc:247:Waiting for parent to finish setup
			 dc_init.c:cgroup_setup:518:Setting up cgroups with memory limit 512 MB (536870912)
			 dc_init.c:cgroup_setup:521:cgroup_dir /sys/fs/cgroup/memory/536
			 dc_init.c:cgroup_setup:527:cgroup_file /sys/fs/cgroup/memory/536/memory.limit_in_bytes
			 dc_init.c:cgroup_setup:545:cgroup_file /sys/fs/cgroup/memory/536/cgroup.procs
			PARENT exiting - child_pid=536
			 dc_init.c:init_dc:253:CHILD  PID=1 PPID=0
			 dc_init.c:init_dc:256:CHILD before dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
			 dc_init.c:init_dc:257:CHILD before flags=0 dc_nodes=0 dc_pid=0 dc_name=DC0
			 dc_init.c:init_dc:258:CHILD before dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
			 dc_init.c:init_dc:270:CHILD I am a daemon
			DEBUG 1:dvk_dc_init:80: 
			DEBUG 1:dvk_dc_init:82: ioctl ret=0 errno=0
			DC0 has been initialized on node 0
			DEBUG 1:dvk_getnodeinfo:177: nodeid=0
			DEBUG 1:dvk_getnodeinfo:181: ioctl ret=0 errno=0
			 dc_init.c:init_dc:279:CHILD n_nodeid=0 n_proxies=-1 n_flags=6 n_dcs=1 n_name=node0
			DEBUG 1:dvk_getdcinfo:163: dcid=0
			DEBUG 1:dvk_getdcinfo:167: ioctl ret=0 errno=0
			 dc_init.c:init_dc:283:CHILD after  dc_dcid=0 dc_nr_procs=221 dc_nr_tasks=34 dc_nr_sysprocs=64 dc_nr_nodes=32
			 dc_init.c:init_dc:284:CHILD after  flags=0 dc_nodes=1 dc_pid=536 dc_name=DC0
			 dc_init.c:init_dc:285:CHILD after  dc_dcid=0 dc_warn2proc=0 dc_warnmsg=1
			CHILD Sysname:  Linux
			CHILD Nodename: DC0
			CHILD Release:  4.9.88
			CHILD Version:  #12 SMP Sat Sep 15 13:28:24 -03 2018
			CHILD Machine:  i686
			CHILD chroot to:  /usr/src/dvs/vos/rootfs/DC0
			 dc_init.c:init_dc:360:/proc mounted
			 dc_init.c:init_dc:372:/dev mounted
			 dc_init.c:init_dc:379:Setting env variables
			 dc_init.c:init_dc:381:unsetenv LC_ALL
			 dc_init.c:init_dc:409:sleep looping
			SPREAD PROXY Enter para continuar... 
			Enter para continuar... 
			ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
			 0     6      -1        0        0 -------------------------------X node0           
			 1     E       1        0        0 -------------------------------- node1           
			Proxies Flags Sender Receiver --Proxies_Name- 10987654321098765432109876543210 
				  1     7    574      573           node1 ------------------------------X-
			ID Type -lpid- -flag- -misc- -pxsent- -pxrcvd- -getf- -sendt -wmig- name
			 1 send    574      8      3        0        0  31438  27342  27342 sp_proxy_bat   
			 1 recv    573      0      3        0        0  27342  27342  27342 sp_proxy_bat   
			ADDNODE Enter para continuar... 
			dcid=0
			flags=0
			nr_procs=221
			nr_tasks=34
			nr_sysprocs=64
			nr_nodes=32
			dc_nodes=1
			dc_pid=536
			warn2proc=0
			warnmsg=1
			dc_name=DC0
			nodes 33222222222211111111110000000000
				  10987654321098765432109876543210
				  -------------------------------X
			cpumask=1 
			DEBUG 579:dvk_open:40: Open dvk device file /dev/dvk
			Adding node 1 to DC 0... 
			DEBUG 579:dvk_add_node:233: dcid=0 nodeid=1
			DEBUG 579:dvk_add_node:237: ioctl ret=0 errno=0
			ID Flags Proxies -pxsent- -pxrcvd- 10987654321098765432109876543210 Name
			 0     6      -1        0        0 -------------------------------X node0           
			 1     E       1        0        0 -------------------------------X node1           
			dcid=0
			flags=0
			nr_procs=221
			nr_tasks=34
			nr_sysprocs=64
			nr_nodes=32
			dc_nodes=3
			dc_pid=536
			warn2proc=0
			warnmsg=1
			dc_name=DC0
			nodes 33222222222211111111110000000000
				  10987654321098765432109876543210
				  ------------------------------XX
			cpumask=1 
	root@node0:/usr/src/dvs/dvk-tests# cd ../dvs-apps/dc_init/
	root@node0:/usr/src/dvs/dvs-apps/dc_init# . ./DC0.sh 
	root@node0:/usr/src/dvs/dvs-apps/dc_init# cd ../../vos/mol/
	root@node0:/usr/src/dvs/vos/mol# nsenter -p -u -F -t$DC0 ./minix.sh 0
			lcl=0
			dcid=0
			Enter para continuar... 
			SYSTASK Enter para continuar... 
			PID DC0=536
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			================= building /tmp/rdisk0.cfg ====================
			device MY_FILE_IMG {
					major                   3;
					minor                   0;
					type                    FILE_IMAGE;
					image_file              "/usr/src/dvs/vos/mol/images/minixweb.img";
					volatile                NO;
					replicated              YES;
			};
			Enter para continuar... 
			RDISK Enter para continuar... 
			./rdisk -rdDec /tmp/rdisk0.cfg > rdisk0.txt 2> rdisk_err0.txt
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			 0   3     3   605/10     0    8   A0 31438 27342 27342 27342 rdisk          
			PM Enter para continuar... 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   613/17     0    8   A0 31438 27342 27342 27342 pm             
			 0   3     3   605/10     0    8   A0 31438 27342 27342 27342 rdisk          
			RS Enter para continuar... 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   613/17     0    8   A0 31438 27342 27342 27342 pm             
			 0   2     2   618/21     0    0   20 27342 27342 27342 27342 cmdline        
			 0   3     3   605/10     0    8   A0 31438 27342 27342 27342 rdisk          
			FS Enter para continuar... 
			================= building /tmp/molfs0.cfg ====================
			device MY_FILE_IMG {
					major                   1;
					minor                   0;
					type                    FILE_IMG;
					filename                "/usr/src/dvs/vos/mol/images/minixweb.img";
					volatile                NO;
					root_dev                YES;
					buffer_size             4096;
			};
			Enter para continuar... 
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   613/17     0    8   A0 31438 27342 27342 27342 pm             
			 0   1     1   628/29     0    8   20 31438 27342 27342 27342 fs             
			 0   2     2   618/21     0    0   20 27342 27342 27342 27342 cmdline        
			 0   3     3   605/10     0    8   A0 31438 27342 27342 27342 rdisk          
			Config TAP and BR: Enter para continuar... 
			crw-rw-rw- 1 root root 36, 16 feb  3 23:08 /dev/tap0
			Configuring tap0. Enter para continuar... 
			tap0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
			DC pnr -endp -lpid/vpid- nd flag misc -getf -sndt -wmig -prxy name
			 0 -34   -34   599/6      0    0   80 27342 27342 27342 27342 systask        
			 0  -2    -2   597/4      0    8   20 31438 27342 27342 27342 systask        
			 0   0     0   613/17     0    8   A0 31438 27342 27342 27342 pm             
			 0   1     1   628/29     0    8   20 31438 27342 27342 27342 fs             
			 0   2     2   618/21     0    0   20 27342 27342 27342 27342 cmdline        
			 0   3     3   605/10     0    8   A0 31438 27342 27342 27342 rdisk          
			ETHERNET Enter para continuar... 
			Configuring tap9. Enter para continuar... 
			crw-rw-rw- 1 root root 36, 25 feb  3 23:08 /dev/tap9
			tap9: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
	root@node0:/usr/src/dvs/vos/mol#

 
 ------------------------------------------------------------------------------------------------------------
20190204:
		Migre INET, hay un error al compilar 
		Modifique ETH para que tenga main thread y inet_thread, tap_receiver, tap_sender. 
		Modifique el script que configura el bridge y tap  
	
 ------------------------------------------------------------------------------------------------------------
20190205:
		Solucione el problema de hton.h modificando sys_config.h
		Cambie grub.conf para que en lugar de denominar esn33 se denomine eth0 
		Elimine la configuracion de TAP del programa dc_init.c
		incorpore a tests.sh el arranque de TAP y BR usando inittap.sh
	
PROBLEMA:  SSH se me cae la sesion despues de que inittap.sh se ejecuta. 	
		
 ------------------------------------------------------------------------------------------------------------
20190211:		
			Modifique ETH - Ahora solo tiene el main thread y el receive_thread.
			
			El main es el que se comunica con M3-IPC
			El receiver_thread es que el que hace el select  y notifica a main con dvk_hdw_notify()
			Cuando main lo recibe, hace el read del FD del TAP  y almacena en los buffers ring y notifica a INET 
			Luego , cuando INET quiere leer datos, entonces se copian desde los buffers a INET 
			
			Las escrituras son sincronicas, es decir que cuando INET solicita un Write, este write se hace en el FD del TAP
			
 ------------------------------------------------------------------------------------------------------------
20190217:	Preparando la documentacion para el uso del DVS veo que fallan las pruebas remotas en el lado server.
			
			nsenter -p -t$DC0 ./loop_r-s_server 1 10 0

ATENCION:
			LAS PRUEBAS DABAN ERROR DADO QUE EL DC ESTABA CONFIGURADO PARA MOL
			echo "warn2proc 0;"     			>> DC$dcid.cfg
			echo "warnmsg 1;"     				>> DC$dcid.cfg
			
			
 =========================================================================================
ULTIMO_LOG

  		TODO:  Probar arranque de RADAR en NODE2
			
		PROBLEMA:
			En NODE2, RADAR va a dar de alta el nodo de RDISK.
			Pero, como hace NODE0 y NODE1 para dar de alta un nodo cliente ?????????????????????????

		Se podria implementar en RDISK y RADAR que reciben peticiones para hacer RMTBIND
			CLIENT2--rmtbind-->RADAR2 ---------->RDISK0
								 \-------------->RDISK1
		El problema es que no se puede hacer unbind.
		
		VOLVER AL AUTOBIND ???
		
		Otra posibilidad es
			PARENT2		CHILD2		RADAR
			radar_bind-------------->RADAR2 ---------->RDISK0
								       \-------------->RDISK1
			fork()		CLIENT2
						waitforbind()
			lclbind()			
						process()
						exit()
			waitfor()
			
			radar_unbind-------------->RADAR2 ---------->RDISK0
								       \-------------->RDISK1
			
		radar/radard deberia funcionar en forma similar a RS/demonize 
		
		Modalidades de OPERACION DE RADAR
		RADAR es un server (radard) que tienen dos hilos
			1) escucha por un socket que recibe peticiones de "radar"
			2) escucha SPREAD 
		
		radar aplicacion de linea de comandos que se comunica con radard  
			Le envia diferentes ordenes contenidas en un archivo de configuracion a radard 
			radard -c <archivo de configuracion>
			
			Le indica al grupo RDISK que se ha bindeado el cliente con endpoint clt_ep 	
			radar -b <clt_ep> -d <dcid> -g "#RDISK" <client> <args> 
			Le indica al grupo RDISK que se ha unbindeado el cliente con endpoint clt_ep 	
			radar -u <clt_ep> -d <dcid> -g "#RDISK" 
			
			Habria que hacer una libradar que tenga 
				radar_bind()
				radar_unbind()		 
		 
		

	PROBLEMA RADAR 
	
		 
PROBLEMA:
		FUNCIONO BIEN LA TRANSFERENCIA DE MENSAJES SI SE LE ANULA EL BATCHING
			#ifdef USE_BATCHING			
		QUIERE DECIR Q ALLI ESTA EL PROBLEMA
		

PARA INCLUIR EN SPREAD PROXY
		Cada vez que hay un JOIN es que hay que hacer el 
			int dvk_node_up(char name[], int nodeid, int pxid)
		cada vez que hay un DISCONNECT 
			int dvk_node_down(int nodeid)
 
PROBAR TRANSFERENICAS DE BLOQUES CON TCP_BAT

INCLUIR UN NOMBRE AL DVS  
 
	
	QUEDAN PROBAR 
			RDISK
			IS
			FS-FAT
			FAT-FUSE
			MOL-FUSE 
						
			
			https://github.com/w-vi/diyC
			https://wvi.cz/diyC/
			http://libcg.sourceforge.net/
			https://www.cloudsigma.com/howto-cgroups/
			https://ericchiang.github.io/post/containers-from-scratch/
			https://doc.opensuse.org/documentation/leap/tuning/html/book.sle.tuning/cha.tuning.cgroups.html
				
			RDISK
			M3NWEB
			M3FTP
			PM
			RS
			IS
			FS
						

	
ssh root@node0 "bash -s" < node1.sh	
	
ssh user@remotehost "bash -s" < local_script.sh
	-s makes bash read from standard input.
If you need to pass arguments to your script:
ssh user@remotehost "bash -s" -- < local_script.sh "your_arg" "--aswitch" "avalue"
To be short, do not forget to put this at the end of local_script.sh:
exit 0	
	
TODO:		Modificar todos los campos de bitmaps a tipo BITMAP como hace MINIX
			Esto implica modificacion en la SETBIT, GETBIT y en la impresion del contenido del bitmap.
	
TODO:		Nuevo DVK CALLS para obtener estadisticas de uso (que estan en /proc)
				GETDCSTATS
				GETNODESTATS
					
TODO:		Definir los address de espacio de usuario 
				void __user xxxxx
TODO: 		Probar el proxy con batching de comandos
TODO : 		Ver porque no compilan los proxies con LZ4

TODO:		VER EL TEME DE CGROUPS 
TODO:		Lo mas conveniente es crear un USER y GROUP por cada DC .
			
		
TODO:		Migrar (SE NECESITA PARA EL PROXY TCP DE KERNEL)
			copy_krn2usr
			copy_usr2krn
		
		POSIBLE SOLUCION:
			Cargar el modulo de DVK 
			Cargar el modulo de TCPIP en modo KERNEL - pero queda deshabilitado
			Crear un proceso en modo usuario con 2 hilos 
			pseudo_sproxy: 1 hilo con un buffer para salida por cada nodo.
			pseudo_rproxy: 1 hilo con un buffer para entrada por cada nodo.
			Este proceso mediante IOCTL (diferente al DVK) activa el proxy 
			de kernel correspondiente al nodo a atender pasandole las direcciones
			en modo usuario de los buffers.
			
			PSEUDO PROXY SENDER
				El proceso de usuario emisor, al invocar al kernel puede hacer
				un copy_usr2usr desde el espacio del usuario emisor al espacio
				de usuario del pseudo_sproxy.
				Luego, desde el pseudo_sproxy copy_from_user al KTCP sproxy.
				
			PSEUDO PROXY RECEIVER
				El kernel recibe el mensaje/dato por TCP, lo copia con copy_to_user
				al buffer de modo usuario del pseudo_rproxy
				del pseudo_rproxy al buffer de proceso de usuario mediante
				copy_usr2usr
				
TODO: PROBAR 
			new_migrate
			new_dvs_end
			new_dc_end

ERROR: 	Hay un problema en el dvk_unbind explicito ???
		
TODO: 	Modificar copy_usr2usr tripartito.
		Para hacer una copia donde
						Requester ¡= Source ¡= Destination
		Y todos en el mismo nodo.
		Tambien pueden intervenir el proxy sender.

		OPCION 1:
		SourceàRequester, buffer , Requester -> Source
		Esto se soluciona con copy_to_usr y copy_from_user
						PROBLEMA: se requiere buffer en el kernel
						SE PUEDE HACER con un único buffer y copiar de a pedazos, lo cual seria mas lento.
						IMPOSIBLE!! Dado que copy_to_user y copy_from_user deben hacerse desde el contexto del propio proceso.
								  Y en este caso los datos están en el sender y deben copiarse al requester y deben enviarse al destination-
		 
		OPCION 1B:
						Modificar el código de  Linux para que pueda hacer
						
		Dvk_copy_u2k: seria equivalente dvk_vm_rw desde usuario a kernel
		Dvk_copy_k2u: seria equivalente dvk_vm_rw desde kernel a  usuario.
		 
		OPCION 2:
		Como tanto el Source como el Destination ESTAN BLOQUEADOS para permitir la copia
		El requester podría desbloquear al Source por ejemplo, con algún código de un UPCALL de tal
		Forma que el Source realice la copia (Write) desde Source a Destination y luego
		Vuelva a bloquarse
						PROBLEMA: Posible problema de seguridad porque permitiría a cualquier Requester
													   Ordenar  una copia de datos.
		Este código debería incluirse en las funciones sleep_proc
		 
		En sleep proc del sender
		1)      Debe chequear que este ONCOPY el sender y el destination
		2)      Se le debe indicar que debe ejecutar una upcall o funcion trampoline
		3)      Los datos de la transferencia deberían estar en el proc descriptor del requester
		4)      Como info al sender se le pasa el proc_ptr del requester.

		HAY QUE RESOLVER
				Como se copia desde/hacia el modo KERNEL  de un proceso XXXX , al modo USUARIO de otro proceso YYYY.
				SOLUCION SIMILAR A USR2USR COPY TRIPARTITO
				KRN->USR: 
					Los datos de la copia  se completan en el propio  descriptor del proceso destino (que debe estar BLOQUEADO ONCOPY)
		Proc_ptr->vcopy_t
		Se hace un wakeup del destinatario, con un código de ERROR especial .
		 

		Do {
			if( timeout < 0) {
				ret = wait_event_interruptible(proc->p_wqhead, (proc->p_pseudosem >= 0));
			} else {
				ret = wait_event_interruptible_timeout(proc->p_wqhead,
						(proc->p_pseudosem >= 0),msecs_to_jiffies(timeout));
			}
			If ( rcode ==  or EDVSKRN2USR o EDVSUSR2KRN)
					 // The parameters of the copy are in the proc_ptr->p_vcopy fields
		   ret = back_vopy();
		   // ret == EDVSUSR2USR or EDVSKRN2USR o EDVSUSR2KRN; another copy is needed
		   // ret ¡= EDVSUSR2USR or EDVSKRN2USR o EDVSUSR2KRN, break the  loop
		   // the return code of back_vcopy() to the requester are returned in in the bytes field of the proc_ptr->p_vcopy struct
		   // bytes < 0: error
		   // bytes == 0; no copy done
		   // bytes different from original , partial copy
		   // bytes == original bytes => OK

		} While ( ret ¡= EDVSUSR2USR or EDVSKRN2USR o EDVSUSR2KRN);
		TODO: Los errores del demonio deberian ir al syslog


		
	SEGUN LINUX Admite ambos tipos de LOCK  
				/*
			 * look up a PID in the hash table. Must be called with the tasklist_lock 	<<<<<<<<
			 * or rcu_read_lock() held.													<<<<<<<<
			 *
			 * find_pid_ns() finds the pid in the namespace specified
			 * find_vpid() finds the pid by its virtual id, i.e. in the current namespace
			 *
			 * see also find_task_by_vpid() set in include/linux/sched.h
			 */
			extern struct pid *find_pid_ns(int nr, struct pid_namespace *ns); <<<<<<<<<< ATENCION DEVUELVE struct pid
			extern struct pid *find_vpid(int nr);

			/*
			 * the helpers to get the pid's id seen from different namespaces
			 *
			 * pid_nr()    : global id, i.e. the id seen from the init namespace;
			 * pid_vnr()   : virtual id, i.e. the id seen from the pid namespace of
			 *               current.
			 * pid_nr_ns() : id seen from the ns specified.
			 *
			 * see also task_xid_nr() etc in include/linux/sched.h
		 */
			 
			 struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)
			{
				return ns_of_pid(task_pid(tsk));
			}
			EXPORT_SYMBOL_GPL(task_active_pid_ns);

			/* transfer_pid is an optimization of attach_pid(new), detach_pid(old) */
			void transfer_pid(struct task_struct *old, struct task_struct *new,
						   enum pid_type type)
			{
				new->pids[type].pid = old->pids[type].pid;
				hlist_replace_rcu(&old->pids[type].node, &new->pids[type].node);
			}
			

struct pid_namespace * task_active_pid_ns(struct task_struct *tsk)
Retorna el PID NS de la tarea indicada.
Cuando se crea DC se debería crear el Container en el nodo local.
Esto significa el CGROUP para todos los recursos y el NS para todos los tipos de nombres
En la estructura dc_struct deberían estar los punteros a todas las estructuras del kernel
Existen 
	ipc_namespace.h
	Mnt_namespace.h
	Pid_namespace.h
	User_namespace.h
	kobject_ns.h PARA net
	utsname.h para UTS

Todos están apuntados en la task_struct por nsproxy
struct nsproxy {
       atomic_t count;
       struct uts_namespace *uts_ns;
       struct ipc_namespace *ipc_ns;
       struct mnt_namespace *mnt_ns;
       struct pid_namespace *pid_ns_for_children;
       struct net         *net_ns;
       struct cgroup_namespace *cgroup_ns;
};
 
struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)
{
       return ns_of_pid(task_pid(tsk));
}
EXPORT_SYMBOL_GPL(task_active_pid_ns);
 
 
* The pid namespace is an exception -- it's accessed using
 * task_active_pid_ns.  The pid namespace here is the
 * namespace that children will use.
*
 * the helpers to get the task's different pids as they are seen
 * from various namespaces
 *
 * task_xid_nr()     : global id, i.e. the id seen from the init namespace;
 * task_xid_vnr()    : virtual id, i.e. the id seen from the pid namespace of
 *                     current.
 * task_xid_nr_ns()  : id seen from the ns specified;
 *
 * set_task_vxid()   : assigns a virtual id to a task;
 *
 * see also pid_nr() etc in include/linux/pid.h
 */
 

Three system calls are used for namespaces: ● clone() - creates a new process and a new namespace; the process is attached to the new namespace. – Process creation and process termination methods, fork() and exit() methods, were patched to handle the new namespace CLONE_NEW* flags. ● unshare() - does not create a new process; creates a new namespace and attaches the current process to it. – unshare() was added in 2005, but not for namespaces only, but also for security. see “new system call, unshare” : http://lwn.net/Articles/135266/ ● setns() - a new system call was added, for joining an existing namespace.


/include/uapi/linux/sched.h
#define CLONE_VM     0x00000100    /* set if VM shared between processes */
#define CLONE_FS     0x00000200    /* set if fs info shared between processes */
#define CLONE_FILES  0x00000400    /* set if open files shared between processes */
#define CLONE_SIGHAND       0x00000800    /* set if signal handlers and blocked signals shared */
#define CLONE_PTRACE 0x00002000    /* set if we want to let tracing continue on the child too */
#define CLONE_VFORK  0x00004000    /* set if the parent wants the child to wake it up on mm_release */
#define CLONE_PARENT 0x00008000    /* set if we want to have the same parent as the cloner */
#define CLONE_THREAD 0x00010000    /* Same thread group? */
#define CLONE_NEWNS  0x00020000    /* New mount namespace group */
#define CLONE_SYSVSEM       0x00040000    /* share system V SEM_UNDO semantics */
#define CLONE_SETTLS 0x00080000    /* create a new TLS for the child */
#define CLONE_PARENT_SETTID 0x00100000    /* set the TID in the parent */
#define CLONE_CHILD_CLEARTID       0x00200000    /* clear the TID in the child */
#define CLONE_DETACHED            0x00400000    /* Unused, ignored */
#define CLONE_UNTRACED            0x00800000    /* set if the tracing process can't force CLONE_PTRACE on this clone */
#define CLONE_CHILD_SETTID  0x01000000    /* set the TID in the child */
#define CLONE_NEWCGROUP           0x02000000    /* New cgroup namespace */
#define CLONE_NEWUTS        0x04000000    /* New utsname namespace */
#define CLONE_NEWIPC        0x08000000    /* New ipc namespace */
#define CLONE_NEWUSER             0x10000000    /* New user namespace */
#define CLONE_NEWPID        0x20000000    /* New pid namespace */
#define CLONE_NEWNET        0x40000000    /* New network namespace */
#define CLONE_IO           0x80000000    /* Clone io context */
 

KERNEL SELF TEST
/tools/testing/selftests/kselftest.h

ATENCION, EXCELENTE CON MULTIPLES PROGRAMAS
http://man7.org/tlpi/code/online/dist/namespaces/


ENTONCES:
Es necesario incluir en dc_struct
struct pid_namespace *dc_ns;       // para apuntar al ns de usuarios
struct nsproxy       dc_nsproxy;   // para contener a los  punteros del resto de los NS

Supongamos que usamos test_dc_init lanza un primer proceso para crear un DC/CGROUP/NS
	Se hace un CLONE a un nuevo NS y el proceso child denominado DC_INIT hace un detach 
	El DC_INIT en el nodo local crea el DC utilizando dvk_dc_init: 
	de esta forma los NSs a los que apuntan las estructuras del DC son ahora el los del NS del proceso DC_INIT.
	DC_INIT DEBE QUEDAR VIVO en forma permanente hasta finalizar el DC.
		a.      int clone(int (*fn)(void *), void *child_stack,   int flags, void *arg, ...    /* pid_t *ptid, void *newtls, pid_t *ctid */ );
		b.      http://man7.org/tlpi/code/online/dist/procexec/demo_clone.c.html

	DE ESTA FORMA SE SOLUCIONA PROBLEMA: Si el unico proceso en el nuevo NS finaliza, finaliza el NS ?
		Normally, a PID namespace will also be destroyed when its init process terminates. However, there is an unusual corner case: the namespace won't be destroyed as long as a /proc/PID/ns/pid file for one of the processes in that namespaces is bind mounted or held open. However, it is not possible to create new processes in the namespace (via setns() plus fork()): the lack of an init process is detected during the fork() call, which fails with an ENOMEM error (the traditional error indicating that a PID cannot be allocated). In other words, the PID namespace continues to exist, but is no longer usable

	PROBLEMA: Como finalizo el DC?
		El dc_struct tambien deberia tener un puntero hacia el proceso DC_INIT de tal forma que despues de hacer		
		dvk_dc_end() deberia enviar un KILL a DC_INIT.
		DC_INIT deberia ser inmortal hasta que desde afuera lo maten.
	
		OTRA FORMA: es incrementar el uso del namespace get_ns
			static inline struct pid_namespace *get_pid_ns(struct pid_namespace *ns)
	
IMPORTANTE:
		Se puede utilizar el truco de reljmp.c para INTERCEPTAR LLAMADAS AL SISTEMA!!
					
PROBLEMAS 
=========


 
1) Como hacer el usr2usr_copy() dado que la gestion de memoria puede haber cambiado sustantivamente
	process_vm_readv,  process_vm_writev  - transfer data between process
       address spaces file to anothe
	https://elixir.bootlin.com/linux/v4.9.88/source/mm/process_vm_access.c
	https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=fcf634098c00dd9cd247447368495f0b79be12d1
			SYSCALL_DEFINE6(process_vm_readv, pid_t, pid, const struct iovec __user *, lvec,
					unsigned long, liovcnt, const struct iovec __user *, rvec,
					unsigned long, riovcnt,	unsigned long, flags)
			{
				return process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 0);
			}

			SYSCALL_DEFINE6(process_vm_writev, pid_t, pid,
					const struct iovec __user *, lvec,
					unsigned long, liovcnt, const struct iovec __user *, rvec,
					unsigned long, riovcnt,	unsigned long, flags)
			{
				return process_vm_rw(pid, lvec, liovcnt, rvec, riovcnt, flags, 1);
			}	 
			
 
	
	
2) Para usar ioctl() se necesita hacer un open() para que retorne el FD del driver. Como hacer para que un proceso ya haga el open() en forma transparente? 
	RESPUESTA: oculto en el fork() ya que el padre le transfiere al hijo el FD abierto.
	
3) PROBLEMAS DEL IOCTL.			
	- EL DEVICE /dev/dvs, por ejemplo, está en el root filesystem
		- CGROUPS: como hacer para que ese mismo dispositivo esté disponible dentro del container?
		- UML: como hacer para que ese mismo dispositivo esté disponible en el rootfs?
		
Formato de archivo  de configuracion.

# This group of configuration parameters are global for all DVS.
dvs DVSNAME {
	d_nr_dcs		32 ;
	d_nr_nodes		32;
	d_nr_procs		221;	
	d_nr_tasks		64;
	d_nr_sysprocs	32;
	d_max_copybuf	65536;
	d_max_copylen   1048576;
	d_dbglvl		0;
} 

# This group of configuration parameters specific on NODE0.
node	NODE0{
	nodeid			0;
	hosts			host0;
	proxy PROXY_01 {
		px_idA			0;
		px_idB			1;	
		px_nodeA		node0;
		px_nodeB		node1;
		px_program		/usr/src/dvs/dvk-proxies/tcp_proxy_bat;
	}
	# only parameter for local settings 
	dc DC0 {
		dcid 		0;
		ip_addr 	192.168.10.100;	
		memory 		512;    
	}
	dc DC1 {
		dcid 		1;
		ip_addr 	192.168.10.101;
		memory 		1024;
	}
} 

# This group of configuration parameters specific on NODE1.
node	NODE1{
	nodeid			1;
	hosts			host0;
	proxy PROXY_01 {
		px_idA			0;
		px_idB			1;	
		px_nodeA		node0;
		px_nodeB		node1;
		px_program		/usr/src/dvs/dvk-proxies/tcp_proxy_bat;
	}
	# only parameter for local settings 
	dc DC0 {
		dcid 		0;
		memory 		256;    
	}
}


# This group of configuration parameters are specific for DC0 on NODE0, NODE1, NODE5.
dc DC0 {     			
	dcid 		0;				
	dc_nodes 	NODE0, NODE1, NODE5;
	nr_procs 	221;    			
	nr_tasks 	34;  				
	nr_sysprocs 64;  			
	nr_nodes 	3;    				
	warn2proc 	0;     			
	warnmsg 	1;
}

# This group of configuration parameters are specific for DC0 on NODE0, NODE2, NODE3, NODE4.
dc DC1 {     			
	dcid 		1;				
	dc_nodes 	NODE0, NODE2, NODE3, NODE4;
	nr_procs 	200;    			
	nr_tasks 	34;  				
	nr_sysprocs 44;  			
	nr_nodes 	4;    				
	warn2proc 	0;     			
	warnmsg 	1;
}

# This group of configuration parameters are specific for MOL 
vos MOL {
		

}

						
https://www.kernel.org/doc/html/v4.10/process/adding-syscalls.html
http://blog.techveda.org/adding-system-calls-linux-kernel-3-5-x/
https://medium.com/@ssreehari/implementing-a-system-call-in-linux-kernel-4-7-1-6f98250a8c38
http://www.franksthinktank.com/howto/addsyscall/
http://impact.asu.edu/cse430fa12/CSE430%20FA%202012%20-%20HW2.pdf

https://stackoverflow.com/questions/7407652/implementation-of-system-calls-traps-within-linux-kernel-source		
http://articles.manugarg.com/systemcallinlinux2_6.html
https://notes.shichao.io/lkd/
https://legacy.gitbook.com/book/0xax/linux-insides/details
https://lwn.net/Articles/604287/
https://lwn.net/Articles/604515/ 
https://gist.github.com/ilammy/f39b7366f9dd2f15479d  Linux kernel system call table hooking
http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.5.5078&rep=rep1&type=pdf
https://filippo.io/linux-syscall-table/
https://sourceware.org/ml/systemtap/2006-q1/msg00617.html
https://www.kernel.org/doc/Documentation/kprobes.txt
https://www.ibm.com/developerworks/library/l-kprobes/index.html
https://vjordan.info/log/fpga/how-linux-kprobes-works.html






